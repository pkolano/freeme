#!/usr/bin/perl
#
# Notices
# FreeMe
# Copyright (C) 2019-2021 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
# 
# FreeMe contains 3rd party code.
# Copyright notices for 3rd party code below. The license can be found
# at https://dev.perl.org/licenses/artistic.html.
#
# Perl modules Date::Parse, Mail::Address, Mail::Box::Manager, Mail::Message
# Copyright (c) 1995-2009 Graham Barr.  Copyrights 1995-2000 Graham Barr
# <gbarr@pobox.com> and 2001-2017 Mark Overmeer <perl@overmeer.net>.
# Copyrights 2001-2019 by [Mark Overmeer].  For other contributors see ChangeLog.
# Copyrights 2001-2019 by [Mark Overmeer <markov@cpan.org>].  For other
# contributors see ChangeLog.
#
# Disclaimers
#
# No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
# WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
# INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
# WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
# INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR FREE,
# OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE
# SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN
# ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS,
# RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS
# RESULTING FROM USE OF THE SUBJECT SOFTWARE. FURTHER, GOVERNMENT AGENCY
# DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD?PARTY SOFTWARE,
# IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS."
#
# Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
# AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
# THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
# EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
# PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
# SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE REMEDY FOR
# ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS
# AGREEMENT.
#

use strict;
require Date::Parse;
use File::Basename;
use File::Path;
use Getopt::Long qw(:config bundling no_auto_abbrev no_ignore_case require_order);
use List::Util qw(max);
require Mail::Box::Manager;
require Mail::Message;
use POSIX qw(strftime);
use Term::ANSIColor;
use Text::ParseWords;

our $VERSION = 1.1;

# solarized foreground colors
my @colors = qw(
    #b58900 #cb4b16 #dc322f #d33682 #6c71c4 #268bd2 #2aa198 #859900
);

my @tcolors = qw(
    yellow red magenta blue cyan green
);

# second string conversions
my %seconds = (
    s => 1,
    m => 60,
    h => 60 * 60,
    d => 24 * 60 * 60,
    w => 7 * 24 * 60 * 60,
);

# default configuration
my %conf = (
    base_dir => "~/.freeme",
);
my %accts;
my %opts;
my %names;
my %subs;
my %tos;

my $cmd0 = shift @ARGV;
die usage() if ($cmd0 !~ /deliver|ignore|list|process|send|show|(un)?subscribe/);

# parse configuration
foreach my $file ("/etc/freemerc", (getpwuid($<))[7] . "/.freemerc") {
    open(FILE, '<', $file) or next;
    my $mline;
    while (my $line = <FILE>) {
        # strip whitespace and comments
        $line =~ s/^\s+|\s+$|\s*#.*//g;
        next if (!$line);
        # support line continuation operator
        $mline .= $line;
        next if ($mline =~ s/\s*\\$/ /);
        if ($mline =~ /^(\S+)\s+(.*)/) {
            my ($key, $val) = ($1, $2);
            $conf{$key} = $val;
        }
        $mline = undef;
    }
    close FILE;
}

my $file = glob $conf{base_dir};
$conf{base_dir} = $file if ($file);
$file = glob $conf{log_file};
$conf{log_file} = $file if ($file);

my $log_fh;
if ($conf{log_file}) {
    open($log_fh, '>>', $conf{log_file});
} else {
    $log_fh = \*STDOUT;
}

foreach my $sub (grep(/^sub_/, keys %conf)) {
    my ($name, $to) = split(/:/, $sub);
    $name =~ s/^sub_//;
    $names{$name} = $to;
    $tos{$to} = $name;
    $accts{$_} = $to foreach (split(/\s+/, $conf{$sub}));
}

my $mgr = Mail::Box::Manager->new;
$mgr->defaultTrace('NONE');

######################
#### command line ####
######################
if ($cmd0 eq 'deliver') {
    load_subs();
    deliver();
} elsif ($cmd0 eq 'process') {
    load_subs();
    if (!scalar(@ARGV)) {
        my $msg = Mail::Message->read(\*STDIN);
        process_msg($msg, {});
    } else {
        process_box(@ARGV);
    }
} else {
    my $user = getpwuid($<);
    my $to = $accts{$user};
    if (!defined $to) {
        print "ERROR: No destination exists for $user\n";
    } else {
        print process_cmd([$cmd0, @ARGV], $to);
    }
}

####################
#### build_body ####
####################
sub build_body {
    my ($msg, $type, $toc) = @_;
    return if (!$type);
    my $body;
    my $from = ($msg->sender)[0]->address;
    my $stamp = localtime($msg->timestamp);
    my $subj = $msg->subject;
    my $header = "$stamp $from $subj";
    push(@{$toc}, $header);
    my $i = scalar(@{$toc});
    if ($type eq 'headers') {
        $body = $header . "\n";
    } elsif ($type eq 'digest') {
        if ($cmd0 ne 'show') {
            my $color = $colors[($i - 1) % scalar(@colors)];
            $body .= "<div style=\"color:$color\"/>\n";
            $body .= "<a name=\"digest_msg$i\"/>\n";
            $body .= "<pre>";
        }
        $body .= "-" x 60 . "\n";
        $body .= "\nMessage: $i";
        $body .= "\nDate: $stamp";
        $body .= "\nFrom: $from";
        my $to = $msg->get('To');
        $to = $msg->get('Delivered-To') if (!$to);
        $to = $msg->get('X-Original-To') if (!$to);
        $body .= "\nTo: $to";
        $body .= "\nSubject: $subj";
        $body .= "\nMessage-ID: " . $msg->messageId;
        $body .= "\nContent-Type: " . $msg->contentType;
        $body .= "\n\n" . $msg->decoded->string . "\n";
        if ($cmd0 eq 'show') {
            print color 'reset';
        } else {
            $body .= "</pre>\n";
        }
    }
    if ($cmd0 eq 'show' && $type ne 'headers') {
        my $color = $tcolors[($i - 1) % scalar(@tcolors)];
        return colored($body, $color);
    } else {
        return $body;
    }
}

#################
#### deliver ####
#################
sub deliver {
    log_("" . localtime(time), " delivering");
    my $last;
    my $time = time;
    if (open(FILE, '<', "$conf{base_dir}/time")) {
        $last = <FILE>;
        chomp $last;
        close FILE;
    } else {
        log_("" . localtime(time), "  unable to read time file");
    }
    $last = $time if (!$last);
    if (open(FILE, '>', "$conf{base_dir}/time")) {
        print FILE $time;
        close FILE;
    } else {
        log_("" . localtime(time), "  unable to write time file");
    }

    # send matching periodic non-ignored digest/headers to any subscribed users
    foreach my $to (keys %subs) {
        foreach my $sub (@{$subs{$to}}) {
            # period is only defined for subscribe's
            next if (!$sub->{period});
            my $period = $sub->{period};
            if ($period =~ /^([1-9]\d*)([smhdw])?$/i) {
                my $unit = defined $2 ? $2 : 's';
                $period = $1 * $seconds{lc $unit};
            }
            next if (int($last / $period) >= int($time / $period));
            # time to send it
            my $body;
            my $toc = [];

            my $start = $period * int($last / $period);
            my $end = $period * int($time / $period);
            for (my $t = $start; $t <= max($end, $start + $seconds{d});
                    $t += $seconds{d}) {
                my $name = strftime("$conf{base_dir}/mail/%Y/%m/%d",
                    localtime $t);
                # disable warnings about missing files
                local $SIG{__WARN__} = sub {};
                my $box = $mgr->open(
                    access => 'r',
                    folder => $name,
                );
                next if (!$box);
                MESSAGE: foreach my $msg ($box->messages) {
                    next if ($msg->timestamp < $start ||                                                                              $msg->timestamp >= $end || !match_msg($msg, $sub));
                    foreach my $sub2 (@{$subs{$to}}) {
                        next MESSAGE if ($sub2->{cmd} eq 'ignore' &&
                            $sub->{type} eq $sub2->{type} && match_msg($msg, $sub2));
                    }
                    $body .= build_body($msg, $sub->{type}, $toc);
                }
                $box->close;
            }
            if (scalar(@{$toc})) {
                my $subj = "subscribe " . join(" ",
                    map {"--$_=$sub->{$_}"} grep(!/^cmd$/, keys(%{$sub})));
                if ($cmd0 ne 'show' && $sub->{type} ne 'headers') {
                    my $html = "<html><head><title>$subj</title></head><body>\n";
                    my $i = 1;
                    foreach my $head (@{$toc}) {
                        $html .= "$i: <a href=\"#digest_msg$i\">$head</a><br/>\n";
                        $i++;
                    }
                    $html .= "$body\n</body></html>\n";
                    $body = $html;
                }
                my $reply = Mail::Message->build(
                    'Content-Type' => "text/" .
                        ($cmd0 eq 'show' || $sub->{type} eq 'headers' ?
                            "plain" : "html"),
                    data => $body,
                    Subject => "Fwd: $subj",
                    To => $to =~ /@/ ? $to : 'freeme@localhost',
                );
                send_msg($reply, $to);
                log_("" . localtime(time), "   delivered ", $to,
                    " ", $subj);
            }
        }
    }
    log_("" . localtime(time), "   done delivering");
}

###################
#### load_subs ####
###################
sub load_subs {
    foreach my $file (glob("$conf{base_dir}/subs/*")) {
        my $name = basename($file);
        next if (!$names{$name});
        if (open(FILE, $file)) {
            while (<FILE>) {
                process_cmd($_, $names{$name}, 1);
            }
            close FILE;
        }
    }
}

##############
#### log_ ####
##############
sub log_ {
    print $log_fh @_, "\n";
}

###################
#### match_msg ####
###################
sub match_msg {
    my ($msg, $sub) = @_;
    my $head = $msg->head;
    foreach my $key (keys %{$sub}) {
        next if ($key =~ /^(?:cmd|date|period|type)$/);
        my $re = $sub->{$key};
        # header fields regexes are stored under head-field
        if ($key eq 'body') {
            return 0 if ($msg->decoded->string !~ qr/$re/i);
        } elsif ($key =~ s/^head-//) {
            my $val = join(" ", $head->get($key));
            return 0 if ($val !~ qr/$re/i);
        }
    }
    # match
    return 1;
}

#####################
#### process_box ####
#####################
sub process_box {
    my $opens = {};
    foreach my $name (@_) {
        my $box = $mgr->open(
            access => 'r',
            create => 0,
            folder => $name,
        );
        next if (!$box);
        process_msg($_, $opens) foreach ($box->messages);
        $box->close;
    }
    foreach my $box (values %{$opens}) {
        $box->close;
    }
}

#####################
#### process_cmd ####
#####################
sub process_cmd {
    my ($subj, $to, $parse) = @_;
    my @args;
    if (ref $subj) {
        @args = @{$subj};
        $subj = join(" ", @args);
    } else {
        @args = quotewords('\s+', 0, $subj);
    }
    my $cmd = shift @args;
    my $err;
    my %opts;
    my $body;
    my $toc = [];
    my $file = "$conf{base_dir}/subs/" . $tos{$to};
    my @save = @ARGV;
    @ARGV = @args;
    my $rc = GetOptions(\%opts,
        "body|b=s", "head-cc|cc|c=s", "date|d=s", "head-from|from|f=s",
        "lines=i", "period|p=s", "size=s", "head-subject|subject|s=s",
        "head-to|to|t=s", "type|T=s", "head|h=s" => sub {
            my ($key, $val) = split(/=|\s+/, $_[1]);
            $val = shift @ARGV if (!defined $val);
            $opts{"$_[0]-" . lc($key)} = $val;
            $opts{lc($key)} = $val;
        }
    );
    @ARGV = @save;
    if (!$rc) {
        $body = "ERROR: Invalid options\n\n" . usage();
        $err = 1;
    } elsif ($cmd eq 'help') {
        $body = usage();
    } elsif (defined $opts{date} && !($opts{time} = Date::Parse::str2time($opts{date}))) {
        $body = "ERROR: Invalid date specification\n";
        $err = 1;
    } elsif (defined $opts{period} && $opts{period} !~ /^([1-9]\d*)([smhdw])?$/i) {
        $body = "ERROR: Invalid period specification\n";
        $err = 1;
    } elsif (defined $opts{type} && $opts{type} !~ /^(?:digest|headers)/) {
        $body = "ERROR: Invalid type specification\n";
        $err = 1;
    } elsif ($cmd =~ /^(?:send|show)$/ && !defined $opts{date}) {
        $body = "ERROR: Missing date specification\n";
        $err = 1;
    } elsif (($cmd =~ /^(?:send|show)$/ || $cmd eq 'subscribe' &&
            defined $opts{type}) && !defined $opts{period}) {
        $body = "ERROR: Missing period specification\n";
        $err = 1;
    } elsif ($cmd !~ /^(?:send|show|subscribe)$/ &&
            (defined $opts{date} || defined $opts{period})) {
        $body = "ERROR: Date and period are not valid for $cmd\n";
        $err = 1;
    } elsif ($cmd eq 'ignore') {
        if ($parse) {
            $opts{cmd} = $cmd;
            push(@{$subs{$to}}, \%opts);
        } else {
            if (open(FILE, '>>', $file)) {
                print FILE $subj, "\n";
                close FILE;
                $body = "Ignore successful\n";
            } else {
                $body = "ERROR: Cannot write subscription file $file\n";
                $err = 1;
            }
        }
    } elsif ($cmd eq 'list') {
        my $count = 1;
        if (open(FILE, '<', $file)) {
            while (<FILE>) {
                chomp;
                $body .= "\n" . "-" x 60 . "\n";
                $body .= "\nFilter #$count:\n    $_\n";
                $count++;
            }
        } elsif (-e $file) {
            $body = "ERROR: Cannot read subscription file $file\n";
            $err = 1;
            $count = -1;
        }
        $body = "No filters\n" if (!$count);
    } elsif ($cmd eq 'send' || $cmd eq 'show') {
        $opts{type} = 'digest' if (!$opts{type});
        my $period = $seconds{d};
        if ($opts{period} =~ /^([1-9]\d*)([smhdw])?$/i) {
            my $unit = defined $2 ? $2 : 'h';
            $period = $1 * $seconds{lc $unit};
        }
     
        for (my $t = $opts{time}; $t < $opts{time} + $period;
                $t += $seconds{d}) {
            my $name = strftime("$conf{base_dir}/mail/%Y/%m/%d",
                localtime $t);
            # disable warnings about missing files
            local $SIG{__WARN__} = sub {};
            my $box = $mgr->open(
                access => 'r',
                folder => $name,
            );
            next if (!$box);
            foreach my $amsg ($box->messages) {
                next if ($amsg->timestamp > $opts{time} + $period ||
                        !match_msg($amsg, \%opts));
                $body .= build_body($amsg, $opts{type}, $toc);
            }
            $box->close;
        }
    } elsif ($cmd eq 'subscribe') {
        if ($parse) {
            # subscribe to everything if no opts specified
            $opts{"head-from"} = ".*" if (scalar(keys %opts) == 0);
            $opts{cmd} = $cmd;
            $opts{type} = "digest" if (!defined $opts{type} && $opts{period});
            push(@{$subs{$to}}, \%opts);
        } else {
            if (open(FILE, '>>', $file)) {
                print FILE $subj, "\n";
                close FILE;
                $body = "Subscribe successful\n";
            } else {
                $body = "ERROR: Cannot write subscription file $file\n";
                $err = 1;
            }
        }
    } elsif ($cmd eq 'unsubscribe') {
        if (scalar(@args) == 0) {
            $body = "ERROR: At least one index required\n";
            $err = 1;
        } elsif (grep(/\D/, @args)) {
            $body = "ERROR: Arguments must be numeric\n";
            $err = 1;
        } elsif (open(FILE, '<', $file)) {
            my @lines;
            push(@lines, $_) while (<FILE>);
            # add dummy line 0 since args numbered from 1
            unshift(@lines, undef);
            close FILE;
            delete @lines[@args];
            shift @lines;
            # truncate and append so file permissions/ownership kept
            truncate($file, 0);
            if (open(FILE, '>>', $file)) {
                print FILE join("", @lines);
                close FILE;
                $body = "Unsubscribe successful\n";
            } else {
                $body = "ERROR: Cannot write subscription file $file\n";
                $err = 1;
            }
        } else {
            $body = "ERROR: Cannot read subscription file $file\n";
            $err = 1;
        }
    } else {
        $body = "ERROR: Invalid command\n\n" . usage();
        $err = 1;
    }
    return undef if ($parse);
    return $body if ($cmd0 ne 'process' && ($cmd ne 'send' || $err));
    if ($cmd eq 'send' && $opts{type} ne 'headers') {
        my $html = "<html><head><title>$subj</title></head><body>\n";
        my $i = 1;
        foreach my $head (@{$toc}) {
            $html .= "$i: <a href=\"#digest_msg$i\">$head</a><br/>\n";
            $i++;
        }
        $html .= "$body\n</body></html>\n";
        $body = $html;
    }
    my $reply = Mail::Message->build(
        'Content-Type' => "text/" . ($opts{type} eq 'headers' ? "plain" : "html"),
        data => $body,
        Subject => "Re: " . $subj,
        To => $to =~ /@/ ? $to : 'freeme@localhost',
    );
    send_msg($reply, $to);
    return undef;
}

#####################
#### process_msg ####
#####################
sub process_msg {
    my $msg = shift;
    my $opens = shift;

    my $from = ($msg->sender)[0]->address;
    my $stamp = localtime($msg->timestamp);
    my $subj = $msg->subject;

    # check if message is a command
    my $to = $accts{$from};
    if (defined $to && $subj =~ /^(?:help|ignore|send|(un)?subscribe)(\s|$)/) {
        log_("$stamp processing cmd $from $subj");
        process_cmd($subj, $to);
        log_("$stamp   done processing cmd $from $subj");
        return;
    }

    log_("$stamp processing msg $from $subj");
    # send matching non-ignored full messages to any subscribed users
    my %bccs;
    foreach my $user (keys %subs) {
        my ($yes, $no);
        foreach my $sub (@{$subs{$user}}) {
            next if ($sub->{type});
            if (!$yes && $sub->{cmd} eq 'subscribe' && match_msg($msg, $sub)) {
                $yes = 1;
            } elsif (!$no && $sub->{cmd} eq 'ignore' && match_msg($msg, $sub)) {
                $no = 1;
            }
        }
        $bccs{$user} = 1 if ($yes && !$no);
    }

    if (scalar(keys %bccs) > 0) {
        my $bcc = join(",", grep(/@/, keys %bccs));
        if ($bcc) {
            my $bounce = $msg->bounce(
                Bcc => $bcc,
            );
            $bounce->head->set('Message-ID', $bounce->takeMessageId(undef));
            send_msg($bounce);
        }
        send_msg($msg, $_) foreach (grep(!/@/, keys %bccs));
        log_("$stamp   bounced ", join(",", keys %bccs), " $subj");
    }

    store_msg($msg, $opens);
    log_("$stamp   done processing msg $from $subj");
}

##################
#### send_msg ####
##################
sub send_msg {
    my $msg = shift;
    my $to = shift;
    if ($to =~ /\//) {
        my $inbox = $mgr->open(
            access => 'a',
            create => 1,
            # always use maildir so locking not needed
            default_folder_type => 'maildir',
            folder => $to,
        );
        if (ref $msg eq 'Mail::Message') {
            $inbox->addMessage($msg);
        } else {
            $msg->copyTo($inbox);
        }
        $inbox->close;
    } else {
        $msg->send || log_("send error $!");
    }
}

###################
#### store_msg ####
###################
sub store_msg {
    my ($msg, $opens) = @_;
    my $from = ($msg->sender)[0]->address;
    my $stamp = localtime($msg->timestamp);
    my $subj = $msg->subject;
    log_("$stamp   storing $from $subj");
    my $name = strftime("$conf{base_dir}/mail/%Y/%m/%d",
        localtime($msg->timestamp));
    my $box = $opens->{$name};
    if (!defined $box) {
        mkpath(dirname($name), 0, 0711);
        umask 0022;
        $box = $mgr->open(
            access => 'a',
            create => 1,
            folder => $name,
            # always use maildir so locking not needed
            type => 'maildir',
        );
        $opens->{$name} = $box;
    }
    if (ref $msg eq 'Mail::Message') {
        $box->addMessage($msg);
    } else {
        $msg->copyTo($box);
    }
    log_("$stamp     done storing msg $from $subj");
}

###############
#### usage ####
###############
sub usage {
    my $body;
    if ($cmd0 eq 'process') {
        $body .= "Usage: COMMAND [OPTION]... [ARGUMENT]...\n\n";
        $body .= "Send commands in the subject line to filter, reorganize, and/or resend email.\n";
    } else {
        $body .= "Usage: freeme COMMAND [OPTION]... [ARGUMENT]...\n\n";
        $body .= "Filter, reorganize, and/or resend email.\n\n";
    }
    $body .= "Note that regular expressions are case-insensitive and must use Perl syntax.\n";
    $body .= "\n";
    $body .= "Commands:\n";
    if ($cmd0 ne 'process') {
        $body .= "  deliver               deliver summaries matching periodic subscriptions\n";
    }
    $body .= "  help                  show help\n";
    $body .= "  ignore [OPTION]...    disregard messages matching OPTION(s) in subscriptions\n";
    $body .= "  list                  list subscriptions with indices\n";
    if ($cmd0 ne 'process') {
        $body .= "  process               process messages on STDIN or mailbox file ARGUMENT(s)\n";
    }
    $body .= "  send [OPTION]...      send summary [-T] of messages matching OPTION(s)\n";
    if ($cmd0 ne 'process') {
        $body .= "  show [OPTION]...      show summary [-T] of messages matching OPTION(s)\n";
    }
    $body .= "  subscribe [OPTION]... send periodic [-p] summaries [-T] matching OPTION(s)\n";
    $body .= "  unsubscribe [NUM]...  remove subscription(s) with index NUM\n";
    $body .= "\n";
    $body .= "Options:\n";
    $body .= "  -b, --body=REGEX      message body matches REGEX\n";
    $body .= "  -c, --cc=REGEX        message cc matches REGEX\n";
    $body .= "  -d, --date=DATE       message date is after DATE [send/show]\n";
    $body .= "                          (DATE may be any format recognized by Date::Parse)\n";
    $body .= "  -f, --from=REGEX      message from matches REGEX\n";
    $body .= "  -h, --head NAME=REGEX message header field NAME matches regex REGEX\n";
#    $body .= "      --lines=COUNT     truncate body of message at COUNT lines\n";
    $body .= "  -p, --period=TIME     summarize at intervals of TIME [send/show/subscribe]\n";
    $body .= "                          (use suffix {s,m,h,d,w} for {sec,min,hour,day,week}}\n";
#    $body .= "      --size=SIZE       truncate body of messages at SIZE bytes\n";
    $body .= "  -s, --subject=REGEX   message subject matches REGEX\n";
    $body .= "  -t, --to=REGEX        message to matching REGEX\n";
    $body .= "  -T, --type=TYPE       summarize in type TYPE [ignore/send/show/subscribe]\n";
    $body .= "                          (TYPE one of {digest,headers})\n";
    return $body;
}

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Date/Parse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATE_PARSE';
  package Date::Parse;require 5.000;use strict;use vars qw($VERSION @ISA @EXPORT);use Time::Local;use Carp;use Time::Zone;use Exporter;@ISA=qw(Exporter);@EXPORT=qw(&strtotime &str2time &strptime);$VERSION="2.30";my%month=(january=>0,february=>1,march=>2,april=>3,may=>4,june=>5,july=>6,august=>7,september=>8,sept=>8,october=>9,november=>10,december=>11,);my%day=(sunday=>0,monday=>1,tuesday=>2,tues=>2,wednesday=>3,wednes=>3,thursday=>4,thur=>4,thurs=>4,friday=>5,saturday=>6,);my@suf=(qw(th st nd rd th th th th th th))x 3;@suf[11,12,13]=qw(th th th);map {$month{substr($_,0,3)}=$month{$_}}keys%month;map {$day{substr($_,0,3)}=$day{$_}}keys%day;my$strptime=<<'ESQ';use vars qw($day_ref $mon_ref $suf_ref $obj);sub gen_parser {local($day_ref,$mon_ref,$suf_ref,$obj)=@_;if($obj){my$obj_strptime=$strptime;substr($obj_strptime,index($strptime,"sub")+6,0)=<<'ESQ';my$sub=eval "$obj_strptime" or die $@;return$sub}eval "$strptime" or die $@}*strptime=gen_parser(\%day,\%month,\@suf);sub str2time {my@t=strptime(@_);return undef unless@t;my($ss,$mm,$hh,$day,$month,$year,$zone)=@t;my@lt=localtime(time);$hh ||=0;$mm ||=0;$ss ||=0;my$frac=$ss - int($ss);$ss=int$ss;$month=$lt[4]unless(defined$month);$day=$lt[3]unless(defined$day);$year=($month > $lt[4])? ($lt[5]- 1): $lt[5]unless(defined$year);return undef unless($month <= 11 && $day >= 1 && $day <= 31 && $hh <= 23 && $mm <= 59 && $ss <= 59);my$result;if (defined$zone){$result=eval {local$SIG{__DIE__}=sub {};timegm($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne "595923311169";$result -= $zone}else {$result=eval {local$SIG{__DIE__}=sub {};timelocal($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne join("",(localtime(-1))[0..5])}return$result + $frac}1;
   my %month = map { lc $_ } %$mon_ref;
   my $daypat = join("|", map { lc $_ } reverse sort keys %$day_ref);
   my $monpat = join("|", reverse sort keys %month);
   my $sufpat = join("|", reverse sort map { lc $_ } @$suf_ref);
  
   my %ampm = (
  	'a' => 0,  # AM
  	'p' => 12, # PM
  	);
  
   my($AM, $PM) = (0,12);
  
  sub {
  
    my $dtstr = lc shift;
    my $merid = 24;
  
    my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);
  
    $zone = tz_offset(shift) if @_;
  
    1 while $dtstr =~ s#\([^\(\)]*\)# #o;
  
    $dtstr =~ s#(\A|\n|\Z)# #sog;
  
    # ignore day names
    $dtstr =~ s#([\d\w\s])[\.\,]\s#$1 #sog;
    $dtstr =~ s/,/ /g;
    $dtstr =~ s#($daypat)\s*(den\s)?\b# #o;
    # Time: 12:00 or 12:00:00 with optional am/pm
  
    return unless $dtstr =~ /\S/;
    
    if ($dtstr =~ s/\s(\d{4})([-:]?)(\d\d?)\2(\d\d?)(?:[-Tt ](\d\d?)(?:([-:]?)(\d\d?)(?:\6(\d\d?)(?:[.,](\d+))?)?)?)?(?=\D)/ /) {
      ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);
    }
  
    unless (defined $hh) {
      if ($dtstr =~ s#[:\s](\d\d?):(\d\d?)(:(\d\d?)(?:\.\d+)?)?(z)?\s*(?:([ap])\.?m?\.?)?\s# #o) {
        ($hh,$mm,$ss) = ($1,$2,$4);
        $zone = 0 if $5;
        $merid = $ampm{$6} if $6;
      }
  
      # Time: 12 am
      
      elsif ($dtstr =~ s#\s(\d\d?)\s*([ap])\.?m?\.?\s# #o) {
        ($hh,$mm,$ss) = ($1,0,0);
        $merid = $ampm{$2};
      }
    }
      
    if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\.?m?\.?\s# #o) {
      $merid = $ampm{$1};
    }
  
  
    unless (defined $year) {
      # Date: 12-June-96 (using - . or /)
      
      if ($dtstr =~ s#\s(\d\d?)([\-\./])($monpat)(\2(\d\d+))?\s# #o) {
        ($month,$day) = ($month{$3},$1);
        $year = $5 if $5;
      }
      
      # Date: 12-12-96 (using '-', '.' or '/' )
      
      elsif ($dtstr =~ s#\s(\d+)([\-\./])(\d\d?)(\2(\d+))?\s# #o) {
        ($month,$day) = ($1 - 1,$3);
  
        if ($5) {
  	$year = $5;
  	# Possible match for 1995-01-24 (short mainframe date format);
  	($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;
  	return if length($year) > 2 and $year < 1901;
        }
      }
      elsif ($dtstr =~ s#\s(\d+)\s*($sufpat)?\s*($monpat)# #o) {
        ($month,$day) = ($month{$3},$1);
      }
      elsif ($dtstr =~ s#($monpat)\s*(\d+)\s*($sufpat)?\s# #o) {
        ($month,$day) = ($month{$1},$2);
      }
      elsif ($dtstr =~ s#($monpat)([\/-])(\d+)[\/-]# #o) {
        ($month,$day) = ($month{$1},$3);
      }
  
      # Date: 961212
  
      elsif ($dtstr =~ s#\s(\d\d)(\d\d)(\d\d)\s# #o) {
        ($year,$month,$day) = ($1,$2-1,$3);
      }
  
      $year = $1 if !defined($year) and $dtstr =~ s#\s(\d{2}(\d{2})?)[\s\.,]# #o;
  
    }
  
    # Zone
  
    $dst = 1 if $dtstr =~ s#\bdst\b##o;
  
    if ($dtstr =~ s#\s"?([a-z]{3,4})(dst|\d+[a-z]*|_[a-z]+)?"?\s# #o) {
      $dst = 1 if $2 and $2 eq 'dst';
      $zone = tz_offset($1);
      return unless defined $zone;
    }
    elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?):?(\d\d)?(00)?\s# #o) {
      my $m = defined($4) ? "$2$4" : 0;
      my $h = "$2$3";
      $zone = defined($1) ? tz_offset($1) : 0;
      return unless defined $zone;
      $zone += 60 * ($m + (60 * $h));
    }
  
    if ($dtstr =~ /\S/) {
      # now for some dumb dates
      if ($dtstr =~ s/^\s*(ut?|z)\s*$//) {
        $zone = 0;
      }
      elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?)(\d\d)?(00)?\s# #o) {
        my $m = defined($4) ? "$2$4" : 0;
        my $h = "$2$3";
        $zone = defined($1) ? tz_offset($1) : 0;
        return unless defined $zone;
        $zone += 60 * ($m + (60 * $h));
      }
  
      return if $dtstr =~ /\S/o;
    }
  
    if (defined $hh) {
      if ($hh == 12) {
        $hh = 0 if $merid == $AM;
      }
      elsif ($merid == $PM) {
        $hh += 12;
      }
    }
  
    $year -= 1900 if defined $year && $year > 1900;
  
    $zone += 3600 if defined $zone && $dst;
    $ss += "0.$frac" if $frac;
  
    return ($ss,$mm,$hh,$day,$month,$year,$zone);
  }
  ESQ
   shift; # package
  ESQ
DATE_PARSE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.14';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"File/Remove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_REMOVE';
  package File::Remove;use 5.00503;use strict;use warnings;use vars qw{@ISA @EXPORT_OK};use vars qw{$DEBUG $unlink $rmdir};our$VERSION='1.58';BEGIN {@ISA=qw{Exporter};@EXPORT_OK=qw{remove rm clear trash}}use File::Path ();use File::Glob ();use File::Spec 3.29 ();use Cwd 3.29 ();use constant DEBUG=>!!$DEBUG;use constant IS_VMS=>!!($^O eq 'VMS');use constant IS_MAC=>!!($^O eq 'darwin');use constant IS_WIN32=>!!($^O =~ /^MSWin/ or $^O eq 'cygwin');my$glue;my@CLEANUP=();sub clear (@) {my@files=expand(@_);for my$file (@files){next unless -e $file;remove(\1,$file)}push@CLEANUP,map {[$$,$_ ]}@files}END {for my$file (@CLEANUP){next unless$file->[0]==$$;next unless -e $file->[1];remove(\1,$file->[1])}}sub remove (@) {my$recursive=(ref $_[0]eq 'SCALAR')? shift : \0;my$opts=(ref $_[0]eq 'HASH')? shift : {glob=>1};my@files=_expand_with_opts ($opts,@_);my@removes;for my$path (@files){if (-l $path){print "link: $path\n" if DEBUG;if ($unlink ? $unlink->($path): unlink($path)){push@removes,$path}next}unless (-e $path){print "missing: $path\n" if DEBUG;push@removes,$path;next}my$can_delete;if (IS_VMS){$can_delete=VMS::Filespec::candelete($path)}elsif (IS_WIN32){$can_delete=1}elsif (-w $path){$can_delete=1}elsif ($<==0){$can_delete=1}elsif ((lstat($path))[4]==$<){$can_delete=1}else {$can_delete=0}unless ($can_delete){print "nowrite: $path\n" if DEBUG;next}if (-f $path){print "file: $path\n" if DEBUG;unless (-w $path){(undef,undef,my$rp)=lstat$path or next;$rp &=07777;$rp |=0600;chmod$rp,$path}if ($unlink ? $unlink->($path): unlink($path)){next if -e $path;push@removes,$path}}elsif (-d $path){print "dir: $path\n" if DEBUG;my$dir=File::Spec->canonpath($path);my$chdir=_moveto($dir);if (length$chdir){chdir($chdir)or next}if ($$recursive){if (File::Path::rmtree([$dir ],DEBUG,0)){next if -e $path;push@removes,$path}}else {my ($save_mode)=(stat$dir)[2];chmod$save_mode & 0777,$dir;if ($rmdir ? $rmdir->($dir): rmdir($dir)){next if -e $path;push@removes,$path}}}else {print "???: $path\n" if DEBUG}}return@removes}sub rm (@) {goto&remove}sub trash (@) {local$unlink=$unlink;local$rmdir=$rmdir;if (ref $_[0]eq 'HASH'){my%options=%{+shift @_};$unlink=$options{unlink};$rmdir=$options{rmdir}}elsif (IS_WIN32){local $@;eval 'use Win32::FileOp ();';die "Can't load Win32::FileOp to support the Recycle Bin: \$@ = $@" if length $@;$unlink=\&Win32::FileOp::Recycle;$rmdir=\&Win32::FileOp::Recycle}elsif (IS_MAC){unless ($glue){local $@;eval 'use Mac::Glue ();';die "Can't load Mac::Glue::Finder to support the Trash Can: \$@ = $@" if length $@;$glue=Mac::Glue->new('Finder')}my$code=sub {my@files=map {Mac::Glue::param_type(Mac::Glue::typeAlias()=>$_)}@_;$glue->delete(\@files)};$unlink=$code;$rmdir=$code}else {die "Support for trash() on platform '$^O' not available at this time.\n"}remove(@_)}sub undelete (@) {goto&trash}sub _expand_with_opts {my$opts=shift;return ($opts->{glob}? expand(@_): @_)}sub expand (@) {map {-e $_ ? $_ : File::Glob::bsd_glob($_)}@_}sub _moveto {my$remove=File::Spec->rel2abs(shift);my$cwd=@_ ? shift : Cwd::cwd();$remove=Cwd::abs_path($remove);$cwd=Cwd::abs_path($cwd);my ($cv,$cd)=File::Spec->splitpath($cwd,1);my ($rv,$rd)=File::Spec->splitpath($remove,1);return '' unless$cv eq $rv;my@cd=File::Spec->splitdir($cd);my@rd=File::Spec->splitdir($rd);unless (@cd >= @rd){return ''}for (0 .. $#rd){$cd[$_]eq $rd[$_]or return ''}pop@rd;return File::Spec->catpath($rv,File::Spec->catdir(@rd),'')}1;
FILE_REMOVE

$fatpacked{"IO/AtomicFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ATOMICFILE';
  package IO::AtomicFile;use strict;use IO::File;use vars qw($VERSION @ISA);$VERSION="2.111";@ISA=qw(IO::File);sub new {my$class=shift;my$self=$class->SUPER::new();${*$self}{'io_atomicfile_suffix'}='';$self->open(@_)if @_;$self}sub DESTROY {shift->close(1)}sub open {my ($self,$path,$mode)=@_;ref($self)or $self=$self->new;my$temp="${path}..TMP" .${*$self}{'io_atomicfile_suffix'};${*$self}{'io_atomicfile_temp'}=$temp;${*$self}{'io_atomicfile_path'}=$path;$self->SUPER::open($temp,$mode)? $self : undef}sub _closed {my$self=shift;my$oldval=${*$self}{'io_atomicfile_closed'};${*$self}{'io_atomicfile_closed'}=shift if @_;$oldval}sub close {my ($self,$die)=@_;unless ($self->_closed(1)){if ($self->SUPER::close()){rename(${*$self}{'io_atomicfile_temp'},${*$self}{'io_atomicfile_path'})or ($die ? die "close (rename) atomic file: $!\n" : return undef)}else {($die ? die "close atomic file: $!\n" : return undef)}}1}sub delete {my$self=shift;unless ($self->_closed(1)){$self->SUPER::close();return unlink(${*$self}{'io_atomicfile_temp'})}1}sub detach {my$self=shift;$self->SUPER::close()unless ($self->_closed(1));1}1;
IO_ATOMICFILE

$fatpacked{"IO/InnerFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_INNERFILE';
  package IO::InnerFile;use Symbol;$VERSION="2.111";sub new {my ($class,$fh,$start,$lg)=@_;$start=0 if (!$start or ($start < 0));$lg=0 if (!$lg or ($lg < 0));my$a={FH=>$fh,CRPOS=>0,START=>$start,LG=>$lg,};$fh=gensym;tie(*$fh,$class,$a);return bless($fh,$class)}sub TIEHANDLE {my ($class,$data)=@_;return bless($data,$class)}sub DESTROY {my ($self)=@_;$self->close()if (ref($self)eq 'SCALAR')}sub set_length {tied(${$_[0]})->{LG}=$_[1]}sub get_length {tied(${$_[0]})->{LG}}sub add_length {tied(${$_[0]})->{LG}+= $_[1]}sub set_start {tied(${$_[0]})->{START}=$_[1]}sub get_start {tied(${$_[0]})->{START}}sub set_end {tied(${$_[0]})->{LG}=$_[1]- tied(${$_[0]})->{START}}sub get_end {tied(${$_[0]})->{LG}+ tied(${$_[0]})->{START}}sub write {shift->WRITE(@_)}sub print {shift->PRINT(@_)}sub printf {shift->PRINTF(@_)}sub flush {"0 but true"}sub fileno {}sub binmode {1}sub getc {return GETC(tied(${$_[0]}))}sub read {return READ(tied(${$_[0]}),@_[1,2,3])}sub readline {return READLINE(tied(${$_[0]}))}sub getline {return READLINE(tied(${$_[0]}))}sub close {return CLOSE(tied(${$_[0]}))}sub seek {my ($self,$ofs,$whence)=@_;$self=tied($$self);$self->{CRPOS}=$ofs if ($whence==0);$self->{CRPOS}+= $ofs if ($whence==1);$self->{CRPOS}=$self->{LG}+ $ofs if ($whence==2);$self->{CRPOS}=0 if ($self->{CRPOS}< 0);$self->{CRPOS}=$self->{LG}if ($self->{CRPOS}> $self->{LG});return 1}sub tell {return tied(${$_[0]})->{CRPOS}}sub WRITE {die "inner files can only open for reading\n"}sub PRINT {die "inner files can only open for reading\n"}sub PRINTF {die "inner files can only open for reading\n"}sub GETC {my ($self)=@_;return 0 if ($self->{CRPOS}>= $self->{LG});my$data;my$old_pos=$self->{FH}->tell;$self->{FH}->seek($self->{CRPOS}+$self->{START},0);my$lg=$self->{FH}->read($data,1);$self->{CRPOS}+= $lg;$self->{FH}->seek($old_pos,0);$self->{LG}=$self->{CRPOS}unless ($lg);return ($lg ? $data : undef)}sub READ {my ($self,$undefined,$lg,$ofs)=@_;$undefined=undef;return 0 if ($self->{CRPOS}>= $self->{LG});$lg=$self->{LG}- $self->{CRPOS}if ($self->{CRPOS}+ $lg > $self->{LG});return 0 unless ($lg);my$old_pos=$self->{FH}->tell;$self->{FH}->seek($self->{CRPOS}+$self->{START},0);$lg=$self->{FH}->read($_[1],$lg,$_[3]);$self->{CRPOS}+= $lg;$self->{FH}->seek($old_pos,0);$self->{LG}=$self->{CRPOS}unless ($lg);return$lg}sub READLINE {my ($self)=@_;return$self->_readline_helper()unless wantarray;my@arr;while(defined(my$line=$self->_readline_helper())){push(@arr,$line)}return@arr}sub _readline_helper {my ($self)=@_;return undef if ($self->{CRPOS}>= $self->{LG});if (!defined($/)){my$text;$self->READ($text,$self->{LG}- $self->{CRPOS});return$text}my$old_pos=$self->{FH}->tell;$self->{FH}->seek($self->{CRPOS}+$self->{START},0);my$text=$self->{FH}->getline;$self->{FH}->seek($old_pos,0);unless (defined$text){$self->{LG}=$self->{CRPOS};return undef}my$lg=length($text);$lg=$self->{LG}- $self->{CRPOS}if ($self->{CRPOS}+ $lg > $self->{LG});$self->{CRPOS}+= $lg;return substr($text,0,$lg)}sub CLOSE {%{$_[0]}=()}1;
IO_INNERFILE

$fatpacked{"IO/Lines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_LINES';
  package IO::Lines;use Carp;use strict;use IO::ScalarArray;use vars qw($VERSION @ISA);$VERSION="2.111";@ISA=qw(IO::ScalarArray);sub getline {my$self=shift;if (!defined $/){return join('',$self->_getlines_for_newlines)}elsif ($/ eq "\n"){if (!*$self->{Pos}){return *$self->{AR}[*$self->{Str}++]}else {my$partial=substr(*$self->{AR}[*$self->{Str}++],*$self->{Pos});*$self->{Pos}=0;return$partial}}else {croak 'unsupported $/: must be "\n" or undef'}}sub getlines {my$self=shift;wantarray or croak("can't call getlines in scalar context!");if ((defined $/)and ($/ eq "\n")){return$self->_getlines_for_newlines(@_)}else {return$self->SUPER::getlines(@_)}}sub _getlines_for_newlines {my$self=shift;my ($rArray,$Str,$Pos)=@{*$self}{qw(AR Str Pos) };my@partial=();if ($Pos){@partial=(substr($rArray->[$Str++ ],$Pos));*$self->{Pos}=0}*$self->{Str}=scalar @$rArray;return (@partial,@$rArray[$Str .. $#$rArray ])}sub print {if (defined $\ && $\ ne "\n"){croak 'unsupported $\: must be "\n" or undef'}my$self=shift;my@lines=split /^/,join('',@_);@lines or return 1;if (@{*$self->{AR}}and (*$self->{AR}[-1]!~ /\n\Z/)){*$self->{AR}[-1].= shift@lines}push @{*$self->{AR}},@lines;1}1;
IO_LINES

$fatpacked{"IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SCALAR';
  package IO::Scalar;use Carp;use strict;use vars qw($VERSION @ISA);use IO::Handle;use 5.005;use overload '""'=>sub {${*{$_[0]}->{SR}}};use overload 'bool'=>sub {1};$VERSION="2.111";@ISA=qw(IO::Handle);require IO::WrapTie and push@ISA,'IO::WrapTie::Slave' if ($] >= 5.004);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self=bless \do {local*FH},$class;tie *$self,$class,$self;$self->open(@_);$self}sub DESTROY {shift->close}sub open {my ($self,$sref)=@_;defined($sref)or do {my$s='';$sref=\$s};(ref($sref)eq "SCALAR")or croak "open() needs a ref to a scalar";*$self->{Pos}=0;*$self->{SR}=$sref;$self}sub opened {*{shift()}->{SR}}sub close {my$self=shift;%{*$self}=();1}sub flush {"0 but true"}sub fileno {}sub getc {my$self=shift;return undef if$self->eof;substr(${*$self->{SR}},*$self->{Pos}++,1)}sub getline {my$self=shift;return undef if$self->eof;my$sr=*$self->{SR};my$i=*$self->{Pos};if (!defined($/)){*$self->{Pos}=length $$sr;return substr($$sr,$i)}elsif ($/ eq "\012"){my$len=length($$sr);for (;$i < $len;++$i){last if ord (substr ($$sr,$i,1))==10}my$line;if ($i < $len){$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos}+ 1);*$self->{Pos}=$i+1}else {$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos});*$self->{Pos}=$len}return$line}elsif (ref($/)){my$len=length($$sr);my$i=${$/}+ 0;my$line=substr ($$sr,*$self->{Pos},$i);*$self->{Pos}+= $i;*$self->{Pos}=$len if (*$self->{Pos}> $len);return$line}else {pos($$sr)=$i;length($/)or (($$sr =~ m/\G\n*/g)and ($i=pos($$sr)));if (length($/)? $$sr =~ m,\Q$/\E,g : $$sr =~ m,\n\n,g){*$self->{Pos}=pos $$sr;return substr($$sr,$i,*$self->{Pos}-$i)}else {*$self->{Pos}=length $$sr;return substr($$sr,$i)}}}sub getlines {my$self=shift;wantarray or croak("can't call getlines in scalar context!");my ($line,@lines);push@lines,$line while (defined($line=$self->getline));@lines}sub print {my$self=shift;*$self->{Pos}=length(${*$self->{SR}}.= join('',@_).(defined($\)? $\ : ""));1}sub _unsafe_print {my$self=shift;my$append=join('',@_).$\;${*$self->{SR}}.= $append;*$self->{Pos}+= length($append);1}sub _old_print {my$self=shift;${*$self->{SR}}.= join('',@_).$\;*$self->{Pos}=length(${*$self->{SR}});1}sub read {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$read=substr(${*$self->{SR}},*$self->{Pos},$n);$n=length($read);*$self->{Pos}+= $n;($off ? substr($_[1],$off): $_[1])=$read;return$n}sub write {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$data=substr($_[1],$off,$n);$n=length($data);$self->print($data);return$n}sub sysread {my$self=shift;$self->read(@_)}sub syswrite {my$self=shift;$self->write(@_)}sub autoflush {}sub binmode {}sub clearerr {1}sub eof {my$self=shift;(*$self->{Pos}>= length(${*$self->{SR}}))}sub seek {my ($self,$pos,$whence)=@_;my$eofpos=length(${*$self->{SR}});if ($whence==0){*$self->{Pos}=$pos}elsif ($whence==1){*$self->{Pos}+= $pos}elsif ($whence==2){*$self->{Pos}=$eofpos + $pos}else {croak "bad seek whence ($whence)"}if (*$self->{Pos}< 0){*$self->{Pos}=0}if (*$self->{Pos}> $eofpos){*$self->{Pos}=$eofpos}return 1}sub sysseek {my$self=shift;$self->seek (@_)}sub tell {*{shift()}->{Pos}}sub use_RS {my ($self,$yesno)=@_;carp "use_RS is deprecated and ignored; \$/ is always consulted\n"}sub setpos {shift->seek($_[0],0)}*getpos=\&tell;sub sref {*{shift()}->{SR}}sub TIEHANDLE {((defined($_[1])&& UNIVERSAL::isa($_[1],"IO::Scalar"))? $_[1]: shift->new(@_))}sub GETC {shift->getc(@_)}sub PRINT {shift->print(@_)}sub PRINTF {shift->print(sprintf(shift,@_))}sub READ {shift->read(@_)}sub READLINE {wantarray ? shift->getlines(@_): shift->getline(@_)}sub WRITE {shift->write(@_)}sub CLOSE {shift->close(@_)}sub SEEK {shift->seek(@_)}sub TELL {shift->tell(@_)}sub EOF {shift->eof(@_)}sub BINMODE {1}1;
IO_SCALAR

$fatpacked{"IO/ScalarArray.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SCALARARRAY';
  package IO::ScalarArray;use Carp;use strict;use vars qw($VERSION @ISA);use IO::Handle;$VERSION="2.111";@ISA=qw(IO::Handle);require IO::WrapTie and push@ISA,'IO::WrapTie::Slave' if ($] >= 5.004);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self=bless \do {local*FH},$class;tie *$self,$class,$self;$self->open(@_);$self}sub DESTROY {shift->close}sub open {my ($self,$aref)=@_;defined($aref)or do {my@a;$aref=\@a};(ref($aref)eq "ARRAY")or croak "open needs a ref to a array";$self->setpos([0,0]);*$self->{AR}=$aref;$self}sub opened {*{shift()}->{AR}}sub close {my$self=shift;%{*$self}=();1}sub flush {"0 but true"}sub fileno {}sub getc {my$buf='';($_[0]->read($buf,1)? $buf : undef)}sub getline {my$self=shift;my ($str,$line)=(undef,'');if (!defined($/)){return undef if ($self->eof);my$ar=*$self->{AR};my@slurp=(substr($ar->[*$self->{Str}],*$self->{Pos}),@$ar[(1 + *$self->{Str}).. $#$ar ]);$self->_setpos_to_eof;return join('',@slurp)}elsif ($/ eq "\012"){until ($self->eof){if ($self->_eos){++*$self->{Str},*$self->{Pos}=0};$str=\(*$self->{AR}[*$self->{Str}]);pos($$str)=*$self->{Pos};$$str =~ m/\G(.*?)((\n)|\Z)/g;$line .= $1.$2;*$self->{Pos}+= length($1.$2);return$line if $3}return ($line eq '')? undef : $line}elsif (ref($/)){croak '$/ given as a ref to int; currently unsupported'}else {croak '$/ as given is currently unsupported'}}sub getlines {my$self=shift;wantarray or croak("can't call getlines in scalar context!");my ($line,@lines);push@lines,$line while (defined($line=$self->getline));@lines}sub print {my$self=shift;push @{*$self->{AR}},join('',@_).(defined($\)? $\ : "");$self->_setpos_to_eof;1}sub read {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$justread;my$len;($off ? substr($_[1],$off): $_[1])='';my@got;until (!$n or $self->eof){if ($self->_eos){++*$self->{Str};*$self->{Pos}=0}$justread=substr(*$self->{AR}[*$self->{Str}],*$self->{Pos},$n);$len=length($justread);push@got,$justread;$n -= $len;*$self->{Pos}+= $len}$_[1].= join('',@got);return length($_[1])-$off}sub write {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$data=substr($_[1],$n,$off);$n=length($data);$self->print($data);return$n}sub autoflush {}sub binmode {}sub clearerr {1}sub eof {return 0 if (*{$_[0]}->{Str}< $#{*{$_[0]}->{AR}});return 1 if (*{$_[0]}->{Str}> $#{*{$_[0]}->{AR}});((*{$_[0]}->{Str}==$#{*{$_[0]}->{AR}})&& ($_[0]->_eos))}sub _eos {(*{$_[0]}->{Pos}>= length(*{$_[0]}->{AR}[*{$_[0]}->{Str}]))}sub seek {my ($self,$pos,$whence)=@_;if ($whence==0){$self->_seek_set($pos)}elsif ($whence==1){$self->_seek_cur($pos)}elsif ($whence==2){$self->_seek_end($pos)}else {croak "bad seek whence ($whence)"}return 1}sub _seek_set {my ($self,$pos)=@_;my$istr=0;while (($pos >= 0)&& ($istr < scalar(@{*$self->{AR}}))){if (length(*$self->{AR}[$istr])> $pos){return$self->setpos([$istr,$pos])}else {$pos -= length(*$self->{AR}[$istr++])}}return$self->_setpos_to_eof}sub _seek_cur {my ($self,$pos)=@_;$self->_seek_set($self->tell + $pos)}sub _seek_end {my ($self,$pos)=@_;$self->_seek_set($self->_tell_eof + $pos)}sub tell {my$self=shift;my$off=0;my ($s,$str_s);for ($s=0;$s < *$self->{Str};$s++){defined($str_s=*$self->{AR}[$s])or $str_s='';$off += length($str_s)}return ($off += *$self->{Pos})}sub _tell_eof {my$self=shift;my$len=0;for (@{*$self->{AR}}){$len += length($_)}$len}sub setpos {my ($self,$pos)=@_;(ref($pos)eq 'ARRAY')or die "setpos: only use a value returned by getpos!\n";(*$self->{Str},*$self->{Pos})=@$pos}sub _setpos_to_eof {my$self=shift;$self->setpos([scalar(@{*$self->{AR}}),0])}sub getpos {[*{$_[0]}->{Str},*{$_[0]}->{Pos}]}sub aref {*{shift()}->{AR}}sub TIEHANDLE {(defined($_[1])&& UNIVERSAL::isa($_[1],"IO::ScalarArray"))? $_[1]: shift->new(@_)}sub GETC {shift->getc(@_)}sub PRINT {shift->print(@_)}sub PRINTF {shift->print(sprintf(shift,@_))}sub READ {shift->read(@_)}sub READLINE {wantarray ? shift->getlines(@_): shift->getline(@_)}sub WRITE {shift->write(@_)}sub CLOSE {shift->close(@_)}sub SEEK {shift->seek(@_)}sub TELL {shift->tell(@_)}sub EOF {shift->eof(@_)}sub BINMODE {1}1;
IO_SCALARARRAY

$fatpacked{"IO/Stringy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRINGY';
  package IO::Stringy;use vars qw($VERSION);$VERSION="2.111";1;
IO_STRINGY

$fatpacked{"IO/Wrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_WRAP';
  package IO::Wrap;require 5.002;use strict;use vars qw(@ISA @EXPORT $VERSION);@ISA=qw(Exporter);@EXPORT=qw(wraphandle);use FileHandle;use Carp;$VERSION="2.111";sub wraphandle {my$raw=shift;new IO::Wrap$raw}sub new {my ($class,$stream)=@_;no strict 'refs';ref($stream)or $stream=\*$stream;if ((ref($stream)eq 'GLOB')or (ref($stream)eq 'FileHandle')&&!defined(&FileHandle::read)){return bless \$stream,$class}$stream}sub close {my$self=shift;return close($$self)}sub fileno {my$self=shift;my$fh=$$self;return fileno($fh)}sub getline {my$self=shift;my$fh=$$self;return scalar(<$fh>)}sub getlines {my$self=shift;wantarray or croak("Can't call getlines in scalar context!");my$fh=$$self;<$fh>}sub print {my$self=shift;print {$$self}@_}sub read {my$self=shift;return read($$self,$_[0],$_[1])}sub seek {my$self=shift;return seek($$self,$_[0],$_[1])}sub tell {my$self=shift;return tell($$self)}1;
IO_WRAP

$fatpacked{"IO/WrapTie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_WRAPTIE';
  package IO::WrapTie;require 5.004;use strict;use vars qw(@ISA @EXPORT $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(wraptie);$VERSION="2.111";sub wraptie {IO::WrapTie::Master->new(@_)}sub new {shift;IO::WrapTie::Master->new(@_)}package IO::WrapTie::Master;use strict;use vars qw(@ISA $AUTOLOAD);use IO::Handle;@ISA=qw(IO::Handle);sub new {my$master=shift;my$io=IO::Handle->new;my$slave=shift;tie *$io,$slave,@_;bless$io,$master}sub AUTOLOAD {my$method=$AUTOLOAD;$method =~ s/.*:://;my$self=shift;tied(*$self)->$method(\@_)}sub PRELOAD {my$class=shift;for (@_){eval "sub ${class}::$_ { my \$s = shift; tied(*\$s)->$_(\@_) }"}}PRELOAD IO::WrapTie::Master qw(open opened close read clearerr eof seek tell setpos getpos);package IO::WrapTie::Slave;sub new_tie {my$self=shift;$self->TIE_MASTER->new($self,@_)}sub TIE_MASTER {'IO::WrapTie::Master'}1;
IO_WRAPTIE

$fatpacked{"MIME/Type.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MIME_TYPE';
  package MIME::Type;use vars '$VERSION';$VERSION='2.17';use strict;use Carp 'croak';use overload '""'=>'type' ,cmp=>'cmp';sub new(@) {(bless {},shift)->init({@_})}sub init($) {my ($self,$args)=@_;my$type=$self->{MT_type}=$args->{type}or croak "ERROR: Type parameter is obligatory.";$self->{MT_simplified}=$args->{simplified}|| $self->simplified($type);$self->{MT_extensions}=$args->{extensions}|| [];$self->{MT_encoding}=$args->{encoding}? $args->{encoding}: $self->mediaType eq 'text' ? 'quoted-printable' : 'base64';$self->{MT_system}=$args->{system}if defined$args->{system};$self}sub type() {shift->{MT_type}}sub simplified(;$) {my$thing=shift;return$thing->{MT_simplified}unless @_;my$mime=shift;$mime =~ m!^\s*(?:x\-)?([\w.+-]+)/(?:x\-)?([\w.+-]+)\s*$!i ? lc "$1/$2" : $mime eq 'text' ? 'text/plain' : undef}sub extensions() {@{shift->{MT_extensions}}}sub encoding() {shift->{MT_encoding}}sub system() {shift->{MT_system}}sub mediaType() {shift->{MT_simplified}=~ m!^([\w.-]+)/! ? $1 : undef}sub mainType() {shift->mediaType}sub subType() {shift->{MT_simplified}=~ m!/([\w+.-]+)$! ? $1 : undef}sub isRegistered() {lc shift->{MT_type}!~ m{^x\-|/x\-}}sub isVendor() {shift->{MT_simplified}=~ m!/vnd\.!}sub isPersonal() {shift->{MT_simplified}=~ m!/prs\.!}sub isExperimental() {shift->{MT_simplified}=~ m!/x\.!}sub isBinary() {shift->{MT_encoding}eq 'base64'}sub isText() {shift->{MT_encoding}ne 'base64'}*isAscii=\&isText;my%sigs=map +($_=>1),qw(application/pgp-keys application/pgp application/pgp-signature application/pkcs10 application/pkcs7-mime application/pkcs7-signature text/vCard);sub isSignature() {$sigs{shift->{MT_simplified}}}sub cmp($) {my ($self,$other)=@_;my$type=ref$other ? $other->simplified : (ref$self)->simplified($other);$self->simplified cmp $type}sub equals($) {$_[0]->cmp($_[1])==0}1;
MIME_TYPE

$fatpacked{"MIME/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MIME_TYPES';
  package MIME::Types;use vars '$VERSION';$VERSION='2.17';use strict;use MIME::Type ();use File::Spec ();use File::Basename qw(dirname);use List::Util qw(first);my%typedb;sub new(@) {(bless {},shift)->init({@_})}sub init($) {my ($self,$args)=@_;keys%typedb or $self->_read_db($args);$self}sub _read_db($) {my ($self,$args)=@_;my$skip_extensions=$args->{skip_extensions};my$only_complete=$args->{only_complete};my$only_iana=$args->{only_iana};while(1){my$header=<DATA>;defined$header or last;chomp$header;my ($count,$major,$is_iana,$has_ext)=split /\:/,$header;my$skip_section=$major eq 'EXTENSIONS' ? $skip_extensions : (($only_iana &&!$is_iana)|| ($only_complete &&!$has_ext));(my$section=$major)=~ s/^x-//;if($major eq 'EXTENSIONS'){local $_;while(<DATA>){last if m/^$/;next if$skip_section;chomp;$typedb{$section}{$1}=$2 if m/(.*);(.*)/}}else {local $_;while(<DATA>){last if m/^$/;next if$skip_section;chomp;$typedb{$section}{$1}="$major/$_" if m/^(?:x-)?([^;]+)/}}}}sub create_type_index {}sub type($) {my$spec=lc $_[1];$spec='text/plain' if$spec eq 'text';$spec =~ m!^(?:x\-)?([^/]+)/(?:x-)?(.*)! or return;my$section=$typedb{$1}or return;my$record=$section->{$2}or return;return$record if ref$record;my$simple=$2;my ($type,$ext,$enc)=split m/\;/,$record;my$os=undef;$section->{$simple}=MIME::Type->new (type=>$type ,extensions=>[split /\,/,$ext],encoding=>$enc ,system=>$os)}sub mimeTypeOf($) {my ($self,$name)=@_;(my$ext=lc$name)=~ s/.*\.//;my$type=$typedb{EXTENSIONS}{$ext}or return;$self->type($type)}sub addType(@) {my$self=shift;for my$type (@_){my ($major,$minor)=split m!/!,$type->simplified;$typedb{$major}{$minor}=$type;$typedb{EXTENSIONS}{$_}=$type for$type->extensions}$self}sub types() {my$self=shift;my@types;for my$section (keys%typedb){next if$section eq 'EXTENSIONS';push@types,map $_->type("$section/$_"),sort keys %{$typedb{$section}}}@types}sub listTypes() {my$self=shift;my@types;for my$section (keys%typedb){next if$section eq 'EXTENSIONS';for my$sub (sort keys %{$typedb{$section}}){my$record=$typedb{$section}{$sub};push@types,ref$record ? $record->type : $record =~ m/^([^;]+)/ ? $1 : die}}@types}sub extensions {keys %{$typedb{EXTENSIONS}}}sub _MojoExtTable() {$typedb{EXTENSIONS}}sub httpAccept($) {my$self=shift;my@listed;for (split /\,\s*/,shift){m!^   ([a-zA-Z0-9-]+ | \*) / ( [a-zA-Z0-9+-]+ | \* )
            \s* (?: \;\s*q\=\s* ([0-9]+(?:\.[0-9]*)?) \s* )?
                (\;.* | )
            $ !x or next;my$mime="$1/$2$4";my$q=defined $3 ? $3 : 1;$q += $4 ? +0.01 : $1 eq '*' ? -0.02 : $2 eq '*' ? -0.01 : 0;$q -= @listed*0.0001;push@listed,[$mime=>$q ]}map $_->[0],sort {$b->[1]<=> $a->[1]}@listed}sub httpAcceptBest($@) {my$self=shift;my@accept=ref $_[0]eq 'ARRAY' ? @{(shift)}: $self->httpAccept(shift);my$match;for my$acc (@accept){$acc =~ s/\s*\;.*//;my$m=$acc !~ s#/\*$## ? first {$_->equals($acc)}@_ : $acc eq '*' ? $_[0]: first {$_->mediaType eq $acc}@_;return$m if defined$m}()}sub httpAcceptSelect($@) {my ($self,$accept)=(shift,shift);my$fns=!@_ ? return (): ref $_[0]eq 'ARRAY' ? shift : [@_];unless(defined$accept){my$fn=$fns->[0];return ($fn,$self->mimeTypeOf($fn))}my (%have,@have);for my$fn (@$fns){my$type=$self->mimeTypeOf($fn)or next;$have{$type->simplified}=$fn;push@have,$type}my$type=$self->httpAcceptBest($accept,@have);defined$type ? ($have{$type},$type): ()}use base 'Exporter';our@EXPORT_OK=qw(by_suffix by_mediatype import_mime_types);my$mime_types;sub by_suffix($) {my$filename=shift;$mime_types ||=MIME::Types->new;my$mime=$mime_types->mimeTypeOf($filename);my@data=defined$mime ? ($mime->type,$mime->encoding): ('','');wantarray ? @data : \@data}sub by_mediatype($) {my$type=shift;$mime_types ||=MIME::Types->new;my@found;if(!ref$type && index($type,'/')>= 0){my$mime=$mime_types->type($type);@found=$mime if$mime}else {my$search=ref$type eq 'Regexp' ? $type : qr/$type/i;@found=map$mime_types->type($_),grep $_ =~ $search,$mime_types->listTypes}my@data;for my$mime (@found){push@data,map [$_,$mime->type,$mime->encoding],$mime->extensions}wantarray ? @data : \@data}sub import_mime_types($) {my$filename=shift;use Carp;croak <<'CROAK'}1;__DATA__ 2118:EXTENSIONS
  import_mime_types is not supported anymore: if you have types to add
  please send them to the author.
  CROAK
  #;application/x-mathcad
  %;application/x-trash
  123;application/vnd.lotus-1-2-3
  1;application/vnd.ieee.1905
  1km;application/vnd.1000minds.decision-model+xml
  323;text/x-h323
  32x;application/x-genesis-rom
  3MF;application/vnd.ms-3mfdocument
  3dm;model/vnd.flatland.3dml
  3dmf;x-world/x-3dmf
  3dml;model/vnd.flatland.3dml
  3ds;image/x-3ds
  3g2;video/3gpp2
  3ga;video/3gpp
  3gp2;video/3gpp2
  3gp;audio/3gpp
  3gpp2;video/3gpp2
  3gpp;audio/3gpp
  3mf;model/3mf
  602;application/x-t602
  669;audio/x-mod
  726;audio/32kadpcm
  7z;application/x-7z-compressed
  AIT;application/vnd.dvb.ait
  AMR;audio/amr
  AWB;audio/amr-wb
  BDM;application/vnd.syncml.dm+wbxml
  BED;application/vnd.realvnc.bed
  BLEND;application/x-blender
  BMI;application/vnd.bmi
  BOX;application/vnd.previewsystems.box
  C;text/x-c++src
  CAB;application/vnd.ubisoft.webplayer
  CER;application/pkix-cert
  CHRT;application/vnd.kde.kchart
  CRL;application/pkix-crl
  CSV;text/csv
  DAF;application/vnd.mobius.daf
  DIS;application/vnd.mobius.dis
  EDM;application/vnd.novadigm.edm
  EDX;application/vnd.novadigm.edx
  ENW;audio/evrcnw
  EP;application/vnd.bluetooth.ep.oob
  EVB;audio/evrcb
  EVC;audio/evrc
  EVW;audio/evrcwb
  EXT;application/vnd.novadigm.ext
  FLW;application/vnd.kde.kivio
  FNC;application/vnd.frogans.fnc
  FO;application/vnd.software602.filler.form+xml
  FTC;application/vnd.fluxtime.clip
  HPUB;application/prs.hpub+zip
  KARBON;application/vnd.kde.karbon
  KFO;application/vnd.kde.kformula
  KON;application/vnd.kde.kontour
  KPR;application/vnd.kde.kpresenter
  KPT;application/vnd.kde.kpresenter
  KSP;application/vnd.kde.kspread
  KWD;application/vnd.kde.kword
  KWT;application/vnd.kde.kword
  L16;audio/l16
  LBC;audio/ilbc
  LE;application/vnd.bluetooth.le.oob
  LTF;application/vnd.frogans.ltf
  MBK;application/vnd.mobius.mbk
  MC1;application/vnd.medcalcdata
  MCD;application/vnd.mcd
  MQY;application/vnd.mobius.mqy
  MSL;application/vnd.mobius.msl
  NND;application/vnd.noblenet-directory
  NNS;application/vnd.noblenet-sealer
  NNW;application/vnd.noblenet-web
  ORQ;application/ocsp-request
  ORS;application/ocsp-response
  P2P;application/vnd.wfa.p2p
  PAR2;application/x-par2
  PFR;application/font-tdpfr
  PGB;image/vnd.globalgraphics.pgb
  PKI;application/pkixcmp
  PL;application/x-perl
  PLC;application/vnd.mobius.plc
  PPD;application/vnd.cups-ppd
  QBO;application/vnd.intu.qbo
  QCP;audio/evrc-qcp
  QFX;application/vnd.intu.qfx
  SCQ;application/scvp-cv-request
  SCS;application/scvp-cv-response
  SMV;audio/smv
  SPP;application/scvp-vp-response
  SPQ;application/scvp-vp-request
  SSE;application/vnd.kodak-descriptor
  T38;image/t38
  TFX;image/tiff-fx
  TIF;image/tiff
  TXF;application/vnd.mobius.txf
  UTZ;application/vnd.uiq.theme
  VBOX;application/vnd.previewsystems.box
  VPM;multipart/voice-message
  VWX;application/vnd.vectorworks
  WAV;audio/l16
  WSC;application/vnd.wfa.wsc
  XAR;application/vnd.xara
  XDM;application/vnd.syncml.dm+xml
  XML;application/vnd.infotech.project+xml
  XOP;application/xop+xml
  XPR;application/vnd.is-xpr
  XPW;application/vnd.intercon.formnet
  XPX;application/vnd.intercon.formnet
  XSM;application/vnd.syncml+xml
  X_B;model/vnd.parasolid.transmit-binary
  X_T;model/vnd.parasolid.transmit-text
  Z;application/x-compress
  ZFO;application/vnd.software602.filler.form-xml-zip
  ZMM;application/vnd.handheld-entertainment+xml
  a2l;application/a2l
  a;text/vnd-a
  aa3;audio/atrac-advanced-lossless
  aab;application/x-authorware-bin
  aac;audio/x-aac
  aal;audio/atrac-advanced-lossless
  aam;application/x-authorware-map
  aas;application/x-authorware-seg
  abc;text/vnd.abc
  abw;application/x-abiword
  ac3;audio/ac3
  ac;application/pkix-attr-cert
  acc;application/vnd.americandynamics.acc
  ace;application/x-ace-compressed
  acgi;text/html
  acu;application/vnd-acucobol
  acutc;application/vnd.acucorp
  adb;text/x-adasrc
  adp;audio/x-adpcm
  ads;text/x-adasrc
  aep;application/vnd.audiograph
  afl;video/x-animaflex
  afm;application/x-font-type1
  afp;application/vnd.ibm.modcap
  ag;image/x-applix-graphics
  agb;application/x-gba-rom
  ahead;application/vnd.ahead.space
  ai;application/postscript
  aif;audio/x-aiff
  aifc;audio/x-aiff
  aiff;audio/x-aiff
  aiffc;audio/x-aifc
  aim;application/x-aim
  aip;text/x-audiosoft-intra
  air;application/vnd.adobe.air-application-installer-package+zip
  ait;application/vnd.dvb.ait
  al;application/x-perl
  alc;x-chemical/x-alchemy
  alz;application/x-alz
  ami;application/vnd.amiga.ami
  aml;application/aml
  amr;audio/amr
  amz;audio/x-amzxml
  and;audio/atrac-advanced-lossless
  ani;application/x-navi-animation
  anx;application/x-annodex
  any;application/vnd.mitsubishi.misty-guard.trustweb
  aos;application/x-nokia-9000-communicator-add-on-software
  ape;audio/x-ape
  apk;application/vnd.android.package-archive
  apkg;application/vnd.anki
  apng;image/vnd.mozilla.apng
  appcache;text/cache-manifest
  application;application/x-ms-application
  apr;application/vnd.lotus-approach
  aps;application/x-mime
  apxml;application/auth-policy+xml
  ar;application/x-archive
  arc;application/x-freearc
  arj;application/x-arj
  art;image/x-jg
  arw;image/x-sony-arw
  as;application/x-applix-spreadsheet
  asc;application/pgp-signature
  ascii;text/vnd.ascii-art
  asf;application/vnd.ms-asf
  asice;application/vnd.etsi.asic-e+zip
  asics;application/vnd.etsi.asic-s+zip
  asm;text/x-asm
  asn;x-chemical/x-ncbi-asn1
  aso;application/vnd.accpac.simply.aso
  asp;text/x-asp
  ass;text/x-ssa
  asx;video/x-ms-asf
  at3;audio/atrac3
  atc;application/vnd.acucorp
  atf;application/atf
  atfx;application/atfx
  atom;application/atom+xml
  atomcat;application/atomcat+xml
  atomdeleted;application/atomdeleted+xml
  atomsrv;application/x-atomserv+xml
  atomsvc;application/atomsvc+xml
  atx;application/vnd.antix.game-component
  atxml;application/atxml
  au;audio/basic
  auc;application/tamp-apex-update-confirm
  avf;video/x-msvideo
  avi;video/x-msvideo
  avs;video/x-avs-video
  aw;application/x-applixware
  awb;audio/amr-wb
  awk;application/x-awk
  axa;audio/x-annodex
  axv;video/x-annodex
  azf;application/vnd.airzip.filesecure.azf
  azs;application/vnd.airzip.filesecure.azs
  azv;image/vnd.airzip.accelerator.azv
  azw3;application/vnd.amazon.mobi8-ebook
  azw;application/vnd.amazon.ebook
  b;x-chemical/x-molconn-z
  bak;application/x-trash
  bar;application/vnd.qualcomm.brew-app-res
  bat;application/x-msdos-program
  bck;application/x-vmsbackup
  bcpio;application/x-bcpio
  bdf;application/x-font-bdf
  bdm;application/vnd.syncml.dm+wbxml
  bdmv;video/mp2t
  bed;application/vnd.realvnc.bed
  bh2;application/vnd.fujitsu.oasysprs
  bib;text/x-bibtex
  bik;video/vnd.radgamettools.bink
  bin;application/x-mac-binary
  bk2;video/vnd.radgamettools.bink
  bkm;application/vnd.nervana
  blb;application/x-blorb
  bleep;application/x-bleeper
  blend;application/x-blender
  blender;application/x-blender
  blorb;application/x-blorb
  bm;image/bmp
  bmed;multipart/vnd.bint.med-plus
  bmi;application/vnd.bmi
  bmml;application/vnd.balsamiq.bmml+xml
  bmp;image/bmp
  bmpr;application/vnd.balsamiq.bmpr
  boo;text/x-boo
  book;application/x-maker
  box;application/vnd.previewsystems.box
  boz;application/x-bzip2
  bpd;application/vnd.fints
  bpk;application/octet-stream
  brf;text/plain
  bsd;x-chemical/x-crossfire
  bsh;application/x-bsh
  bsp;model/vnd.valve.source.compiled-map
  btf;image/prs.btif
  btif;image/prs.btif
  buffer;application/octet-stream
  bz2;application/x-bzip2
  bz;application/x-bzip
  c++;text/x-c++src
  c11amc;application/vnd.cluetrust.cartomobile-config
  c11amz;application/vnd.cluetrust.cartomobile-config-pkg
  c3d;x-chemical/x-chem3d
  c3ex;application/cccex
  c4d;application/vnd.clonk.c4group
  c4f;application/vnd.clonk.c4group
  c4g;application/vnd.clonk.c4group
  c4p;application/vnd.clonk.c4group
  c4u;application/vnd.clonk.c4group
  c;text/x-csrc
  cab;application/vnd.ms-cab-compressed
  cac;x-chemical/x-cache
  cache;x-chemical/x-cache
  caf;audio/x-caf
  cap;application/vnd.tcpdump.pcap
  car;application/vnd.curl.car
  cascii;x-chemical/x-cactvs-binary
  cat;application/vnd.ms-pki.seccat
  cb7;application/x-cbr
  cba;application/x-cbr
  cbin;x-chemical/x-cactvs-binary
  cbl;text/x-cobol
  cbor;application/cbor
  cbr;application/vnd.comicbook-rar
  cbt;application/x-cbr
  cbz;application/vnd.comicbook+zip
  cc;text/x-c++src
  ccad;application/x-clariscad
  ccc;text/vnd.net2phone.commcenter.command
  ccmp;application/ccmp+xml
  ccmx;application/x-ccmx
  cco;application/x-cocoa
  cct;application/x-director
  ccxml;application/ccxml+xml
  cda;application/x-cdf
  cdbcmsg;application/vnd.contact.cmsg
  cdf;application/x-cdf
  cdfx;application/cdfx+xml
  cdkey;application/vnd.mediastation.cdkey
  cdmia;application/cdmi-capability
  cdmic;application/cdmi-container
  cdmid;application/cdmi-domain
  cdmio;application/cdmi-object
  cdmiq;application/cdmi-queue
  cdr;image/x-coreldraw
  cdt;image/x-coreldrawtemplate
  cdx;x-chemical/x-cdx
  cdxml;application/vnd.chemdraw+xml
  cdy;application/vnd.cinderella
  cea;application/cea
  cef;x-chemical/x-cxf
  cellml;application/cellml+xml
  cer;application/pkix-cert
  cert;application/x-x509-ca-cert
  cfs;application/x-cfs-compressed
  cgb;application/x-gameboy-rom
  cgm;image/cgm
  cha;application/x-chat
  chat;application/x-chat
  chm;application/vnd.ms-htmlhelp
  chrt;application/vnd.kde.kchart
  cif;application/vnd.multiad.creator.cif
  cii;application/vnd.anser-web-certificate-issue-initiation
  cil;application/vnd.ms-artgalry
  cl;application/simple-filter+xml
  cla;application/vnd.claymore
  class;application/vnd.dvb.dvbj
  clkk;application/vnd.crick.clicker.keyboard
  clkp;application/vnd.crick.clicker.palette
  clkt;application/vnd.crick.clicker.template
  clkw;application/vnd.crick.clicker.wordbank
  clkx;application/vnd.crick.clicker
  clp;application/x-msclip
  clpi;video/mp2t
  cls;text/x-tex
  clue;application/clue_info+xml
  cmake;text/x-cmake
  cmc;application/vnd.cosmocaller
  cmdf;x-chemical/x-cmdf
  cml;x-chemical/x-cml
  cmp;application/vnd.yellowriver-custom-menu
  cmsc;application/cms
  cmx;image/x-cmx
  cnd;text/jcr-cnd
  cob;text/x-cobol
  cod;application/vnd.rim.cod
  coffee;application/vnd.coffeescript
  com;application/x-msdos-program
  conf;text/plain
  cpa;x-chemical/x-compass
  cpi;video/mp2t
  cpio;application/x-cpio
  cpkg;application/vnd.xmpie.cpkg
  cpl;application/cpl+xml
  cpp;text/x-c++src
  cpt;audio/vnd.dts
  cr2;image/x-canon-cr2
  crd;application/x-mscardfile
  crdownload;application/x-partial-download
  crl;application/pkix-crl
  crt;application/x-x509-ca-cert
  crtr;application/vnd.multiad.creator
  crw;image/x-canon-crw
  crx;application/x-chrome-extension
  cryptonote;application/vnd.rig.cryptonote
  cs;text/x-csharp
  csf;x-chemical/x-cache-csf
  csh;application/x-csh
  csl;application/vnd.citationstyles.style+xml
  csm;application/x-cu-seeme
  csml;x-chemical/x-csml
  csp;application/vnd.commonspace
  csrattrs;application/csrattrs
  css;text/css
  cst;application/vnd.commonspace
  csv;text/csv
  csvs;text/csv-schema
  ctab;x-chemical/x-cactvs-binary
  ctx;x-chemical/x-ctx
  cu;application/x-cu-seeme
  cub;x-chemical/x-gaussian-cube
  cuc;application/tamp-community-update-confirm
  cue;application/x-cue
  cur;image/x-win-bitmap
  curl;application/vnd-curl
  cw;application/prs.cww
  cww;application/prs.cww
  cxf;x-chemical/x-cxf
  cxt;application/x-director
  cxx;text/x-c++src
  d;text/x-dsrc
  dae;model/vnd.collada+xml
  daf;application/vnd.mobius.daf
  dar;application/x-dar
  dart;application/vnd-dart
  dat;application/x-ns-proxy-autoconfig
  dataless;application/vnd.fdsn.mseed
  davmount;application/davmount+xml
  dbf;application/x-dbf
  dbk;application/x-docbook+xml
  dc;application/x-dc-rom
  dcd;application/dcd
  dcl;text/x-dcl
  dcm;application/dicom
  dcr;application/x-director
  dcurl;text/vnd.curl.dcurl
  dd2;application/vnd.oma.dd2+xml
  ddd;application/vnd.fujixerox.ddd
  ddf;application/vnd.syncml.dmddf+wbxml
  dds;image/x-dds
  deb;application/vnd.debian.binary-package
  deepv;application/x-deepv
  def;text/plain
  deploy;application/octet-stream
  der;application/x-x509-ca-cert
  desktop;application/x-desktop
  dfac;application/vnd.dreamfactory
  dgc;application/x-dgc-compressed
  dgn;image/vnd.dgn
  di;text/x-dsrc
  dia;application/x-dia-diagram
  dib;image/bmp
  dic;text/x-c
  dif;video/dv
  diff;text/x-diff
  dii;application/dii
  dim;application/vnd.fastcopy-disk-image
  dir;application/x-director
  dis;application/vnd.mobius.dis
  disclosed;application/vnd.sss-ntf
  disposition-notification;message/disposition-notification
  dist;application/vnd.apple.installer+xml
  distz;application/vnd.apple.installer+xml
  dit;application/dit
  dive;application/vnd.patentdive
  divx;video/x-msvideo
  djv;image/vnd-djvu
  djvu;image/vnd-djvu
  dl;video/x-dl
  dll;application/vnd.microsoft.portable-executable
  dls;audio/dls
  dmg;application/x-apple-diskimage
  dmp;application/vnd.tcpdump.pcap
  dms;text/vnd.dmclientscript
  dna;application/vnd.dna
  dng;image/x-adobe-dng
  doc;application/msword
  docbook;application/x-docbook+xml
  docjson;application/vnd.document+json
  docm;application/vnd.ms-word.document.macroenabled.12
  docx;application/vnd.openxmlformats-officedocument.wordprocessingml.document
  dor;model/vnd.gs-gdl
  dot;text/vnd.graphviz
  dotm;application/vnd.ms-word.template.macroenabled.12
  dotx;application/vnd.openxmlformats-officedocument.wordprocessingml-template
  dp;application/vnd.osgi.dp
  dpg;application/vnd.dpgraph
  dpgraph;application/vnd.dpgraph
  dpkg;application/vnd.xmpie.dpkg
  dra;audio/vnd.dra
  drle;image/dicom-rle
  drw;application/x-drafting
  dsc;text/prs.lines.tag
  dsl;text/x-dsl
  dsm;application/vnd.desmume-movie
  dssc;application/dssc+der
  dtb;application/x-dtbook+xml
  dtd;application/xml-dtd
  dts;audio/vnd.dts
  dtshd;audio/vnd.dts.hd
  dtx;text/x-tex
  dump;application/octet-stream
  dv;video/dv
  dvb;audio/vnd.dvb.file
  dvc;application/dvcs
  dvi;application/x-dvi
  dwf;model/vnd-dwf
  dwg;image/vnd.dwg
  dx;x-chemical/x-jcamp-dx
  dxf;image/vnd.dxf
  dxp;application/vnd.spotfire.dxp
  dxr;application/vnd-dxr
  dzr;application/vnd.dzr
  e;text/x-eiffel
  eFIF;application/vnd.picsel
  ecelp4800;audio/vnd.nuera.ecelp4800
  ecelp7470;audio/vnd.nuera.ecelp7470
  ecelp9600;audio/vnd.nuera.ecelp9600
  ecig;application/vnd.evolv.ecig.settings
  ecigprofile;application/vnd.evolv.ecig.profile
  ecigtheme;application/vnd.evolv.ecig.theme
  ecma;application/ecmascript
  edm;application/vnd.novadigm.edm
  edx;application/vnd.novadigm.edx
  efi;application/efi
  efif;application/vnd.picsel
  egon;application/x-egon
  ei6;application/vnd.pg.osasli
  eif;text/x-eiffel
  el;text/x-script.elisp
  elc;application/x-bytecode.elisp
  emb;x-chemical/x-embl-dl-nucleotide
  embl;x-chemical/x-embl-dl-nucleotide
  emf;image/emf
  eml;message/rfc822
  emm;application/vnd.ibm.electronic-media
  emma;application/emma+xml
  emotionml;application/emotionml+xml
  emp;application/vnd.emusic-emusic_package
  emz;application/x-msmetafile
  ent;application/vnd.nervana
  entity;application/vnd.nervana
  env;application/x-envoy
  enw;audio/evrcnw
  eol;audio/vnd.digital-winds
  eot;application/vnd.ms-fontobject
  eps2;application/postscript
  eps3;application/postscript
  eps;application/postscript
  epsf;application/postscript
  epsi;application/postscript
  epub;application/epub+zip
  erf;image/x-epson-erf
  erl;text/x-erlang
  es3;application/vnd.eszigno3+xml
  es;application/ecmascript
  esa;application/vnd.osgi.subsystem
  esf;application/vnd.epson.esf
  espass;application/vnd.espass-espass+zip
  et3;application/vnd.eszigno3+xml
  etheme;application/x-e-theme
  etx;text/x-setext
  eva;application/x-eva
  evb;audio/evrcb
  evc;audio/evrc
  event-stream;text/x-event-stream
  evw;audio/evrcwb
  evy;application/x-envoy
  exe;application/vnd.microsoft.portable-executable
  exi;application/exi
  exr;image/aces
  ext;application/vnd.novadigm.ext
  ez2;application/vnd.ezpix-album
  ez3;application/vnd.ezpix-package
  ez;application/andrew-inset
  f4a;audio/mp4
  f4b;audio/mp4
  f4p;video/mp4
  f4v;video/mp4
  f77;text/x-fortran
  f90;text/x-fortran
  f95;text/x-fortran
  f;text/x-fortran
  fb2;application/x-fictionbook+xml
  fb;application/x-maker
  fbdoc;application/x-maker
  fbs;image/vnd.fastbidsheet
  fcdt;application/vnd.adobe.formscentral.fcdt
  fch;x-chemical/x-gaussian-checkpoint
  fchk;x-chemical/x-gaussian-checkpoint
  fcs;application/vnd.isac.fcs
  fdf;application/vnd.fdf
  fdt;application/fdt+xml
  fe_launch;application/vnd.denovo.fcselayout-link
  fg5;application/vnd.fujitsu.oasysgp
  fgd;application/x-director
  fh4;image/x-freehand
  fh5;image/x-freehand
  fh7;image/x-freehand
  fh;image/x-freehand
  fhc;image/x-freehand
  fif;application/x-fractals
  fig;application/x-xfig
  fits;application/fits
  fl;application/x-fluid
  fla;application/vnd.dtg.local.flash
  flac;audio/x-flac
  flc;video/x-flic
  fli;video/x-fli
  flo;application/vnd.micrografx.flo
  flv;video/x-flv
  flw;application/vnd.kde.kivio
  flx;text/vnd.fmi.flexstor
  fly;text/vnd.fly
  fm;application/x-maker
  fmf;video/x-atomic3d-feature
  fnc;application/vnd.frogans.fnc
  fo;text/x-xslfo
  fodg;application/vnd.oasis.opendocument.graphics-flat-xml
  fodp;application/vnd.oasis.opendocument.presentation-flat-xml
  fods;application/vnd.oasis.opendocument.spreadsheet-flat-xml
  fodt;application/vnd.oasis.opendocument.text-flat-xml
  for;text/x-fortran
  fpx;application/vnd.netfpx
  frame;application/x-maker
  frl;application/x-freeloader
  frm;application/vnd.ufdl
  fsc;application/vnd.fsc.weblaunch
  fst;image/vnd.fst
  ftc;application/vnd.fluxtime.clip
  fti;application/vnd.anser-web-funds-transfer-initiation
  funk;audio/x-make
  fvt;video/vnd.fvt
  fxm;video/x-javafx
  fxp;application/vnd.adobe.fxp
  fxpl;application/vnd.adobe.fxp
  fzs;application/vnd.fuzzysheet
  g2w;application/vnd.geoplan
  g3;application/vnd.geocube+xml
  g3w;application/vnd.geospace
  g;text/plain
  gac;application/vnd.groove-account
  gal;x-chemical/x-gaussian-log
  gam;x-chemical/x-gamess-input
  gamin;x-chemical/x-gamess-input
  gau;x-chemical/x-gaussian-input
  gb;application/x-gameboy-rom
  gba;application/x-gba-rom
  gbc;application/x-gameboy-rom
  gbr;application/rpki-ghostbusters
  gca;application/x-gca-compressed
  gcd;text/x-pcs-gcd
  gcf;application/x-graphing-calculator
  gcg;x-chemical/x-gcg8-sequence
  gcrd;text/vcard
  gdl;model/vnd.gs-gdl
  ged;application/x-gedcom
  gedcom;application/x-gedcom
  gem;application/x-tar
  gen;x-chemical/x-genbank
  geo;application/vnd.dynageo
  geojson;application/geo+json
  gex;application/vnd.geometry-explorer
  gf;application/x-tex-gf
  gg;application/x-sms-rom
  ggb;application/vnd.geogebra.file
  ggt;application/vnd.geogebra.tool
  ghf;application/vnd.groove-help
  gif;image/gif
  gim;application/vnd.groove-identity-message
  gjc;x-chemical/x-gaussian-input
  gjf;x-chemical/x-gaussian-input
  gl;video/x-gl
  glade;application/x-glade
  glb;model/gltf-binary
  gltf;model/gltf+json
  gml;application/gml+xml
  gmo;application/x-gettext-translation
  gmx;application/vnd.gmx
  gnc;application/x-gnucash
  gnd;application/x-gnunet-directory
  gnucash;application/x-gnucash
  gnumeric;application/x-gnumeric
  gnuplot;application/x-gnuplot
  go;text/x-go
  gp;application/x-gnuplot
  gpg;application/pgp-encrypted
  gph;application/vnd.flographit
  gplt;application/x-gnuplot
  gpt;x-chemical/x-mopac-graph
  gpx;application/x-gpx+xml
  gqf;application/vnd.grafeq
  gqs;application/vnd.grafeq
  gra;application/x-graphite
  gram;application/srgs
  gramps;application/x-gramps-xml
  gre;application/vnd.geometry-explorer
  grv;application/vnd.groove-injector
  grxml;application/srgs+xml
  gs;text/x-genie
  gsd;audio/x-gsm
  gsf;application/x-font
  gsheet;application/urc-grpsheet+xml
  gsm;model/vnd.gs-gdl
  gsp;application/x-gsp
  gss;application/x-gss
  gtar;application/x-gtar
  gtm;application/vnd.groove-tool-message
  gtw;model/vnd.gtw
  gv;text/vnd.graphviz
  gvp;text/x-google-video-pointer
  gxf;application/x-gxf
  gxt;application/vnd.geonext
  gz;application/gzip
  gzip;application/x-gzip
  h++;text/x-c++hdr
  h261;video/h261
  h263;video/h263
  h264;video/h264
  h4;application/x-hdf
  h5;application/x-hdf
  h;text/x-chdr
  hal;application/vnd.hal+xml
  hbc;application/vnd.fints
  hbci;application/vnd.fints
  hdf4;application/x-hdf
  hdf5;application/x-hdf
  hdf;application/x-hdf
  hdr;image/vnd.radiance
  hdt;application/vnd.hdt
  heldxml;application/held+xml
  help;application/x-helpfile
  hep;application/x-hep
  hgl;application/vnd.hp-hpgl
  hh;text/x-c++hdr
  hin;x-chemical/x-hin
  hlb;text/x-script
  hlp;application/x-winhlp
  hp;text/x-c++hdr
  hpg;application/vnd.hp-hpgl
  hpgl;application/vnd.hp-hpgl
  hpi;application/vnd.hp-hpid
  hpid;application/vnd.hp-hpid
  hpp;text/x-c++hdr
  hps;application/vnd.hp-hps
  hqx;application/mac-binhex40
  hs;text/x-haskell
  hta;application/x-hta
  htc;text/x-component
  htke;application/vnd.kenameaapp
  htm;text/html
  html;text/html
  htmls;text/html
  htmlx;text/html
  htt;text/x-webviewhtml
  htx;text/html
  hvd;application/vnd.yamaha.hv-dic
  hvp;application/vnd.yamaha.hv-voice
  hvs;application/vnd.yamaha.hv-script
  hwp;application/x-hwp
  hwt;application/x-hwt
  hxx;text/x-c++hdr
  i2g;application/vnd.intergeo
  ic1;application/vnd.commerce-battelle
  ica;application/vnd.commerce-battelle
  icb;image/x-tga
  icc;application/vnd.commerce-battelle
  icd;application/vnd.commerce-battelle
  ice;x-conference/x-cooltalk
  icf;application/vnd.commerce-battelle
  icm;application/vnd.iccprofile
  icns;image/x-icns
  ico;image/vnd.microsoft.icon
  ics;text/calendar
  icz;text/calendar
  idc;text/plain
  idl;text/x-idl
  ief;image/ief
  iefs;image/ief
  ifb;text/calendar
  iff;image/x-ilbm
  ifm;application/vnd.shana.informed.formdata
  iges;model/iges
  igl;application/vnd.igloader
  igm;application/vnd.insors.igm
  ign;application/vnd.coreos.ignition+json
  ignition;application/vnd.coreos.ignition+json
  igs;model/iges
  igx;application/vnd.micrografx-igx
  iif;application/vnd.shana.informed.interchange
  iii;application/x-iphone
  ilbm;image/x-ilbm
  ima;application/x-ima
  imagemap;application/x-imagemap
  imap;application/x-imagemap
  ime;text/x-imelody
  imf;application/vnd.imagemeter.folder+zip
  img;application/vnd.efi-img
  imgcal;application/vnd.3lightssoftware.imagescal
  imi;application/vnd.imagemeter.image+zip
  imp;application/vnd.accpac.simply.imp
  ims;application/vnd.ms-ims
  imscc;application/vnd.ims.imsccv1p1
  imy;text/x-imelody
  in;text/plain
  inf;application/x-inf
  info;application/x-info
  ini;text/plain
  ink;application/inkml+xml
  inkml+xml;application/inkml+xml
  inkml;application/inkml+xml
  inp;x-chemical/x-gamess-input
  ins;application/x-internet-signup
  install;application/x-install-instructions
  iota;application/vnd.astraea-software.iota
  ip;application/x-ip2
  ipfix;application/ipfix
  ipk;application/vnd.shana.informed.package
  iptables;text/x-iptables
  irm;application/vnd.ibm.rights-management
  irp;application/vnd.irepository.package+xml
  ism;model/vnd.gs-gdl
  iso9660;application/x-cd-image
  iso;application/vnd.efi-iso
  isp;application/x-internet-signup
  ist;x-chemical/x-isostar
  istr;x-chemical/x-isostar
  isu;video/x-isvideo
  it87;application/x-it87
  it;audio/x-it
  itp;application/vnd.shana.informed.formtemplate
  its;application/its+xml
  iv;application/x-inventor
  ivp;application/vnd.immervision-ivp
  ivr;x-i-world/x-i-vrml
  ivu;application/vnd.immervision-ivu
  ivy;application/x-livescreen
  jad;text/vnd.sun.j2me.app-descriptor
  jam;application/vnd.jam
  jar;application/vnd.osgi.bundle
  jav;text/x-java-source
  java;text/x-java
  jceks;application/x-java-jce-keystore
  jcm;application/x-java-commerce
  jdx;x-chemical/x-jcamp-dx
  jfif-tbnl;image/jpeg
  jfif;image/jpeg
  jisp;application/vnd.jisp
  jks;application/x-java-keystore
  jls;image/jls
  jlt;application/vnd.hp-jlyt
  jmz;application/x-jmol
  jng;image/x-jng
  jnlp;application/x-java-jnlp-file
  joda;application/vnd.joost.joda-archive
  jp2;image/jp2
  jpe;image/jpeg
  jpeg;image/jpeg
  jpf;image/jpx
  jpg2;image/jp2
  jpg;image/jpeg
  jpgm;image/jpm
  jpgv;video/jpeg
  jpm;image/jpm
  jpr;application/x-jbuilder-project
  jps;image/x-jps
  jpx;image/jpx
  jrd;application/jrd+json
  js;application/javascript
  jsm;application/javascript
  json-patch;application/json-patch+json
  json;application/json
  jsonld;application/vnd.ims.lis.v2.result+json
  jsonml;application/x-jsonml+json
  jtd;text/vnd.esmertec.theme-descriptor
  jut;image/x-jutvision
  k25;image/x-kodak-k25
  kar;audio/x-midi
  karbon;application/vnd.kde.karbon
  kcm;application/vnd.nervana
  kdc;image/x-kodak-kdc
  kdelnk;application/x-desktop
  kexi;application/x-kexiproject-sqlite2
  kexic;application/x-kexi-connectiondata
  kexis;application/x-kexiproject-shortcut
  key;application/pgp-keys
  kfo;application/vnd.kde.kformula
  kia;application/vnd.kidspiration
  kil;application/x-killustrator
  kin;x-chemical/x-kinemage
  kino;application/smil+xml
  kml;application/vnd.google-earth.kml+xml
  kmz;application/vnd.google-earth.kmz
  kne;application/vnd.kinar
  knp;application/vnd.kinar
  kom;application/vnd.fints
  kon;application/vnd.kde.kontour
  koz;audio/vnd.audiokoz
  kpm;application/x-kpovmodeler
  kpr;application/vnd.kde.kpresenter
  kpt;application/vnd.kde.kpresenter
  kpxx;application/vnd.ds-keypoint
  kra;application/x-krita
  ks;application/x-java-keystore
  ksh;application/x-ksh
  ksp;application/vnd.kde.kspread
  ktr;application/vnd.kahootz
  ktx;image/ktx
  ktz;application/vnd.kahootz
  kud;application/x-kugar
  kwd;application/vnd.kde.kword
  kwt;application/vnd.kde.kword
  l16;audio/l16
  la;audio/x-nspaudio
  lam;audio/x-liveaudio
  lasjson;application/vnd.las.las+json
  lasxml;application/vnd.las.las+xml
  latex;application/x-latex
  lbc;audio/ilbc
  lbd;application/vnd.llamagraphics.life-balance.desktop
  lbe;application/vnd.llamagraphics.life-balance.exchange+xml
  lbm;image/x-ilbm
  ldif;text/x-ldif
  les;application/vnd.hhe.lesson-player
  lgr;application/lgr+xml
  lha;application/x-lha
  lhs;text/x-literate-haskell
  lhx;application/octet-stream
  lhz;application/x-lhz
  lin;application/x-bbolin
  link66;application/vnd.route66.link66+xml
  list3820;application/vnd.ibm.modcap
  list;text/plain
  listafp;application/vnd.ibm.modcap
  lma;audio/x-nspaudio
  lmp;model/vnd.gs-gdl
  lnk;application/x-ms-shortcut
  log;text/x-log
  lostsyncxml;application/lostsync+xml
  lostxml;application/lost+xml
  lrf;application/octet-stream
  lrm;application/vnd.ms-lrm
  lrv;video/mp4
  lrz;application/x-lrzip
  lsf;video/x-la-asf
  lsp;application/x-lisp
  lst;text/plain
  lsx;video/x-la-asf
  ltf;application/vnd.frogans.ltf
  ltx;text/x-tex
  lua;text/x-lua
  luac;application/x-lua-bytecode
  lvp;audio/vnd.lucent.voice
  lwo;image/x-lwo
  lwob;image/x-lwo
  lwp;application/vnd.lotus-wordpro
  lws;image/x-lws
  lxf;application/lxf
  ly;text/x-lilypond
  lyx;application/x-lyx
  lz4;application/x-lz4
  lz;application/x-lzip
  lzh;application/x-lzh
  lzma;application/x-lzma
  lzo;application/x-lzop
  lzx;application/x-lzx
  m13;application/x-msmediaview
  m14;application/x-msmediaview
  m15;audio/x-mod
  m1u;video/vnd.mpegurl
  m1v;video/mpeg
  m21;application/mp21
  m2a;audio/mpeg
  m2t;video/mp2t
  m2ts;video/mp2t
  m2v;video/mpeg
  m3a;audio/mpeg
  m3g;application/x-m3g
  m3u8;application/vnd.apple.mpegurl
  m3u;application/vnd.apple.mpegurl
  m4;application/x-m4
  m4a;audio/mpeg
  m4b;audio/x-m4b
  m4p;application/mp4
  m4s;video/iso.segment
  m4u;video/vnd-mpegurl
  m4v;video/x-m4v
  m;application/vnd.wolfram.mathematica.package
  ma;application/mathematica
  mab;application/x-markaby
  mads;application/mads+xml
  mag;application/vnd.ecowin.chart
  mak;text/x-makefile
  maker;application/x-maker
  man;application/x-troff-man
  manifest;text/cache-manifest
  map;application/x-navimap
  mar;application/octet-stream
  markdown;text/markdown
  mathml;application/mathml+xml
  mb;application/mathematica
  mbd;application/x-mbedlet
  mbk;application/vnd.mobius.mbk
  mbox;application/mbox
  mc$;application/x-magic-cap-package-1.0
  mc1;application/vnd.medcalcdata
  mcd;application/vnd.mcd
  mcf;image/x-vasa
  mcif;x-chemical/x-mmcif
  mcm;x-chemical/x-macmolecule
  mcp;application/x-netmc
  mcurl;text/vnd.curl.mcurl
  md;text/markdown
  mda;application/x-msaccess
  mdb;application/x-msaccess
  mdc;application/vnd.marlin.drm.mdcf
  mde;application/x-msaccess
  mdf;application/x-msaccess
  mdi;image/vnd.ms-modi
  mdp;application/dash+xml
  mdx;application/x-genesis-rom
  me;application/x-troff-me
  med;audio/x-mod
  mesh;model/mesh
  meta4;application/metalink4+xml
  metalink;application/x-metalink+xml
  mets;application/mets+xml
  mf4;application/mf4
  mfm;application/vnd.mfmp
  mft;application/rpki-manifest
  mgp;application/vnd.osgeo.mapguide.package
  mgz;application/vnd.proteus.magazine
  mht;message/rfc822
  mhtml;message/rfc822
  mid;audio/sp-midi
  midi;audio/x-midi
  mie;application/x-mie
  mif;application/vnd.mif
  mime;message/rfc822
  minipsf;audio/x-minipsf
  miz;text/mizar
  mj2;video/mj2
  mjf;audio/x-vnd.audioexplosion.mjuicemediafile
  mjp2;video/mj2
  mjpg;video/x-motion-jpeg
  mk3d;video/x-matroska
  mk;text/x-makefile
  mka;audio/x-matroska
  mkd;text/x-markdown
  mks;video/x-matroska
  mkv;video/x-matroska
  ml;text/x-ocaml
  mli;text/x-ocaml
  mlp;audio/vnd.dolby.mlp
  mm;application/x-freemind
  mmd;application/vnd.chipnuts.karaoke-mmd
  mmdb;application/vnd.maxmind.maxmind-db
  mme;application/x-base64
  mmf;application/vnd.smaf
  mml;text/x-mathml
  mmod;x-chemical/x-macromodel-input
  mmr;image/vnd.fujixerox.edmics-mmr
  mng;video/x-mng
  mny;application/x-msmoney
  mo3;audio/x-mo3
  mo;application/x-gettext-translation
  mobi;application/x-mobipocket-ebook
  moc;text/x-moc
  mod;application/xml-dtd
  model-inter;application/vnd.vd-study
  mods;application/mods+xml
  mof;text/x-mof
  mol2;x-chemical/x-mol2
  mol;x-chemical/x-mdl-molfile
  moml;model/vnd.moml+xml
  moo;x-chemical/x-mopac-out
  moov;video/quicktime
  mop;x-chemical/x-mopac-input
  mopcrt;x-chemical/x-mopac-input
  mov;video/quicktime
  movie;video/x-sgi-movie
  mp+;audio/x-musepack
  mp1;audio/mpeg
  mp21;application/mp21
  mp2;audio/mpeg
  mp2a;audio/mpeg
  mp3;audio/mpeg
  mp4;application/mp4
  mp4a;audio/mp4
  mp4s;application/mp4
  mp4v;video/mp4
  mpa;audio/mpeg
  mpc;application/vnd.mophun.certificate
  mpd;application/dash+xml
  mpdd;application/dashdelta
  mpe;video/mpeg
  mpeg;video/mpeg
  mpega;audio/mpeg
  mpf;application/media-policy-dataset+xml
  mpg4;application/mp4
  mpg;video/mpeg
  mpga;audio/mpeg
  mpkg;application/vnd.apple.installer+xml
  mpl;video/mp2t
  mpls;video/mp2t
  mpm;application/vnd.blueice.multipass
  mpn;application/vnd.mophun.application
  mpp;application/vnd.ms-project
  mpt;application/vnd.ms-project
  mpv;video/x-matroska
  mpx;application/x-project
  mpy;application/vnd.ibm.minipay
  mqy;application/vnd.mobius.mqy
  mrc;application/marc
  mrcx;application/marcxml+xml
  mrl;text/x-mrml
  mrml;text/x-mrml
  mrw;image/x-minolta-mrw
  ms;application/x-troff-ms
  msa;application/vnd.msa-disk-image
  mscml;application/mediaservercontrol+xml
  msd;application/vnd.fdsn.mseed
  mseed;application/vnd.fdsn.mseed
  mseq;application/vnd.mseq
  msf;application/vnd.epson.msf
  msh;model/mesh
  msi;application/x-msi
  msl;application/vnd.mobius.msl
  msm;model/vnd.gs-gdl
  msod;image/x-msod
  msty;application/vnd.muvee.style
  msx;application/x-msx-rom
  mtm;audio/x-mod
  mts;model/vnd.mts
  multitrack;audio/vnd.presonus.multitrack
  mup;text/x-mup
  mus;application/vnd.musician
  musd;application/mmt-usd+xml
  musicxml;application/vnd.recordare.musicxml+xml
  mv;video/x-sgi-movie
  mvb;x-chemical/x-mopac-vib
  mvt;application/vnd.mapbox-vector-tile
  mwc;application/vnd.dpgraph
  mwf;application/vnd.mfer
  mxf;application/mxf
  mxi;application/vnd.vd-study
  mxl;application/vnd.recordare.musicxml
  mxmf;audio/mobile-xmf
  mxml;application/xhtml-voice+xml
  mxs;application/vnd.triscape.mxs
  mxu;video/vnd-mpegurl
  my;audio/x-make
  mzz;application/x-vnd.audioexplosion.mzz
  n-gage;application/vnd.nokia.n-gage.symbian.install
  n3;text/n3
  n64;application/x-n64-rom
  nap;image/naplps
  naplps;image/naplps
  nb;application/mathematica
  nbp;application/vnd.wolfram.player
  nc;application/x-netcdf
  ncm;application/vnd.nokia.configuration-message
  ncx;application/x-dtbncx+xml
  nds;application/vnd.nintendo.nitro.rom
  nef;image/x-nikon-nef
  nes;application/x-nes-rom
  nez;application/x-nes-rom
  nfo;text/x-nfo
  ngdat;application/vnd.nokia.n-gage.data
  nif;image/x-niff
  niff;image/x-niff
  nim;video/vnd.nokia.interleaved-multimedia
  nitf;application/vnd.nitf
  nix;application/x-mix-transfer
  nlu;application/vnd.neurolanguage.nlu
  nml;application/vnd.enliven
  nnd;application/vnd.noblenet-directory
  nns;application/vnd.noblenet-sealer
  nnw;application/vnd.noblenet-web
  not;text/x-mup
  notebook;application/vnd.smart.notebook
  npx;image/vnd.net-fpx
  nq;application/n-quads
  nsc;application/x-conference
  nsf;application/vnd.lotus-notes
  nsv;video/x-nsv
  nt;application/n-triples
  ntf;application/vnd.nitf
  nvd;application/x-navidoc
  nwc;application/x-nwc
  nws;message/rfc822
  nzb;application/x-nzb
  o;application/x-object
  oa2;application/vnd.fujitsu.oasys2
  oa3;application/vnd.fujitsu.oasys3
  oas;application/vnd.fujitsu.oasys
  obd;application/x-msbinder
  obg;application/vnd.openblox.game-binary
  obgx;application/vnd.openblox.game+xml
  obj;application/x-tgif
  ocl;text/x-ocl
  oda;application/oda
  odb;application/vnd.oasis.opendocument.database
  odc;application/vnd.oasis.opendocument.chart
  odf;application/vnd.oasis.opendocument.formula
  odft;application/vnd.oasis.opendocument.formula-template
  odg;application/vnd.oasis.opendocument.graphics
  odi;application/vnd.oasis.opendocument.image
  odm;application/vnd.oasis.opendocument.text-master
  odp;application/vnd.oasis.opendocument.presentation
  ods;application/vnd.oasis.opendocument.spreadsheet
  odt;application/vnd.oasis.opendocument.text
  odx;application/odx
  oeb;application/vnd.openeye.oeb
  oga;audio/ogg
  ogex;model/vnd.opengex
  ogg;audio/ogg
  ogm;video/x-ogm+ogg
  ogv;video/ogg
  ogx;application/ogg
  old;application/x-trash
  oleo;application/x-oleo
  omc;application/x-omc
  omcd;application/x-omcdatamaker
  omcr;application/x-omcregerator
  omdoc;application/x-omdoc+xml
  omg;audio/atrac-advanced-lossless
  onepkg;application/x-onenote
  onetmp;application/x-onenote
  onetoc2;application/x-onenote
  onetoc;application/x-onenote
  ooc;text/x-ooc
  opf;application/oebps-package+xml
  opml;text/x-opml
  oprc;application/vnd.palm
  opus;audio/ogg
  or3;application/vnd.lotus-organizer
  or;application/vnd.etsi.asic-e+zip
  ora;image/x-openraster
  orf;image/x-olympus-orf
  org;application/vnd.lotus-organizer
  orq;application/ocsp-request
  ors;application/ocsp-response
  osf;application/vnd.yamaha.openscoreformat
  osfpvg;application/vnd.yamaha.openscoreformat.osfpvg+xml
  osm;application/vnd.openstreetmap.data+xml
  otc;application/vnd.oasis.opendocument.chart-template
  otf;font/otf
  otg;application/vnd.oasis.opendocument.graphics-template
  oth;application/vnd.oasis.opendocument.text-web
  oti;application/vnd.oasis.opendocument.image-template
  otm;application/vnd.oasis.opendocument.text-master
  otp;application/vnd.oasis.opendocument.presentation-template
  ots;application/vnd.oasis.opendocument.spreadsheet-template
  ott;application/vnd.oasis.opendocument.text-template
  owl;application/vnd.biopax.rdf+xml
  owx;application/x-owl+xml
  oxlicg;application/vnd.oxli.countgraph
  oxps;application/oxps
  oxt;application/vnd.openofficeorg.extension
  oza;application/x-oz-application
  p10;application/pkcs10
  p12;application/pkcs12
  p65;application/x-pagemaker
  p7a;application/x-pkcs7-signature
  p7b;application/x-pkcs7-certificates
  p7c;application/pkcs7-mime
  p7m;application/pkcs7-mime
  p7r;application/x-pkcs7-certreqresp
  p7s;application/pkcs7-signature
  p8;application/pkcs8
  p8e;application/pkcs8-encrypted
  p;text/x-pascal
  pac;application/x-ns-proxy-autoconfig
  pack;application/x-java-pack200
  package;application/vnd.autopackage
  pak;application/x-pak
  par2;application/x-par2
  part;application/x-pro_eng
  pas;text/x-pascal
  pat;image/x-coreldrawpattern
  patch;text/x-diff
  paw;application/vnd.pawaafile
  pbd;application/vnd.powerbuilder6
  pbm;image/x-portable-bitmap
  pcap;application/vnd.tcpdump.pcap
  pcd;image/x-photo-cd
  pce;application/x-pc-engine-rom
  pcf.z;application/x-font
  pcf;application/x-font
  pcl;application/vnd.hp-pcl
  pclxl;application/vnd.hp-pclxl
  pct;image/x-pict
  pcurl;application/vnd.curl.pcurl
  pcx;image/vnd.zbrush.pcx
  pdb;application/vnd.palm
  pdc;application/x-aportisdoc
  pdf;application/pdf
  pdx;application/pdx
  pef;image/x-pentax-pef
  pem;application/x-x509-ca-cert
  perl;application/x-perl
  pfa;application/x-font
  pfb;application/x-font
  pfm;application/x-font-type1
  pfr;application/vnd.dvb.pfr
  pfunk;audio/x-make
  pfx;application/pkcs12
  pgb;image/vnd.globalgraphics.pgb
  pgm;image/x-portable-graymap
  pgn;application/vnd.chess-pgn
  pgp;application/pgp-signature
  php3;application/x-httpd-php3
  php3p;application/x-httpd-php3-preprocessed
  php4;application/x-httpd-php4
  php5;application/x-httpd-php5
  php;application/x-httpd-php
  phps;application/x-httpd-php-source
  pht;application/x-httpd-php
  phtml;application/x-httpd-php
  pic;image/vnd.radiance
  pict1;image/x-pict
  pict2;image/x-pict
  pict;image/x-pict
  pil;application/vnd.piaccess.application-licence
  pk;application/x-tex-pk
  pkd;application/vnd.fints
  pkg;application/vnd.apple.installer+xml
  pki;application/pkixcmp
  pkipath;application/pkix-pkipath
  pko;application/vnd.ms-pki.pko
  pkr;application/pgp-keys
  pl;application/x-perl
  pla;audio/x-iriver-pla
  plb;application/vnd.3gpp.pic-bw-large
  plc;application/vnd.mobius.plc
  plf;application/vnd.pocketlearn
  plj;audio/vnd.everad.plj
  pln;application/x-planperfect
  plp;application/vnd.panoply
  pls;audio/x-scpls
  plt;application/vnd.hp-hpgl
  plx;application/x-pixclscript
  pm4;application/x-pagemaker
  pm5;application/x-pagemaker
  pm6;application/x-pagemaker
  pm;application/x-pagemaker
  pmd;application/x-pagemaker
  pml;application/vnd.ctc-posml
  png;image/png
  pnm;image/x-portable-anymap
  pntg;image/x-macpaint
  po;text/x-gettext-translation
  pod;application/x-perl
  por;application/x-spss-por
  portpkg;application/vnd.macports.portpkg
  pot;application/vnd.ms-powerpoint
  potm;application/vnd.ms-powerpoint.template.macroenabled.12
  potx;application/vnd.openxmlformats-officedocument.presentationml-template
  pov;model/x-pov
  ppa;application/vnd.ms-powerpoint
  ppam;application/vnd.ms-powerpoint.addin.macroenabled.12
  ppd;application/vnd.cups-ppd
  ppkg;application/vnd.xmpie.ppkg
  ppm;image/x-portable-pixmap
  pps;application/vnd.ms-powerpoint
  ppsm;application/vnd.ms-powerpoint.slideshow.macroenabled.12
  ppsx;application/vnd.openxmlformats-officedocument.presentationml.slideshow
  ppt;application/vnd.ms-powerpoint
  pptm;application/vnd.ms-powerpoint.presentation.macroenabled.12
  pptx;application/vnd.openxmlformats-officedocument.presentationml.presentation
  ppz;application/x-mspowerpoint
  pqa;application/vnd.palm
  prc;application/vnd.palm
  pre;application/vnd.lotus-freelance
  preminet;application/vnd.preminet
  prf;application/x-pics-rules
  provx;application/provenance+xml
  prt;x-chemical/x-ncbi-asn1-ascii
  prz;application/vnd.lotus-freelance
  ps-z;application/postscript
  ps;application/postscript
  psb;application/vnd.3gpp.pic-bw-small
  psd;image/vnd.adobe.photoshop
  pseg3820;application/vnd.ibm.modcap
  psf;application/x-font-linux-psf
  psflib;audio/x-psflib
  psid;audio/prs.sid
  pskcxml;application/pskc+xml
  psw;application/x-pocket-word
  pt5;application/x-pagemaker
  pti;application/vnd.pvi.ptid1
  ptid;application/vnd.pvi.ptid1
  pub;application/x-mspublisher
  pvb;application/vnd.3gpp.pic-bw-var
  pvu;x-paleovu/x-pv
  pw;application/x-pw
  pwn;application/vnd.3m.post-it-notes
  pwz;application/vnd.ms-powerpoint
  py;application/x-python
  pya;audio/vnd.ms-playready.media.pya
  pyc;application/x-python-code
  pyo;application/x-python-code
  pyv;video/vnd.ms-playready.media.pyv
  pyx;text/x-python
  qam;application/vnd.epson.quickanime
  qbo;application/vnd.intu.qbo
  qca;application/vnd.ericsson.quickcall
  qcall;application/vnd.ericsson.quickcall
  qcp;audio/evrc-qcp
  qd3;x-world/x-3dmf
  qd3d;x-world/x-3dmf
  qfx;application/vnd.intu.qfx
  qgs;application/x-qgis
  qif;image/x-quicktime
  qml;text/x-qml
  qmlproject;text/x-qml
  qmltypes;text/x-qml
  qp;application/x-qpress
  qps;application/vnd.publishare-delta-tree
  qt;video/quicktime
  qtc;video/x-qtc
  qti;image/x-quicktime
  qtif;image/x-quicktime
  qtl;application/x-quicktimeplayer
  qtvr;video/quicktime
  quiz;application/vnd.quobject-quoxdocument
  quox;application/vnd.quobject-quoxdocument
  qvd;application/vnd.theqvd
  qwd;application/vnd.quark.quarkxpress
  qwt;application/vnd.quark.quarkxpress
  qxb;application/vnd.quark.quarkxpress
  qxd;application/vnd.quark.quarkxpress
  qxl;application/vnd.quark.quarkxpress
  qxt;application/vnd.quark.quarkxpress
  ra;audio/x-pn-realaudio
  raf;image/x-fuji-raf
  ram;audio/x-pn-realaudio
  rapd;application/route-apd+xml
  rar;application/vnd.rar
  ras;image/x-cmu-raster
  rast;image/x-cmu-raster
  raw-disk-image;application/x-raw-disk-image
  raw;image/x-panasonic-raw
  rax;audio/vnd.rn-realaudio
  rb;application/x-ruby
  rbw;application/x-ruby
  rcprofile;application/vnd.ipunplugged.rcprofile
  rct;application/prs.nprend
  rd;x-chemical/x-mdl-rdfile
  rdf-crypt;application/prs.rdf-xml-crypt
  rdf;application/rdf+xml
  rdfs;application/rdf+xml
  rdz;application/vnd.data-vision.rdz
  reg;text/x-ms-regedit
  rej;text/x-reject
  relo;application/p2p-overlay+xml
  rep;application/vnd.businessobjects
  req;application/vnd.nervana
  request;application/vnd.nervana
  res;application/x-dtbresource+xml
  rexx;text/x-script.rexx
  rf;image/vnd.rn-realflash
  rfcxml;application/rfc+xml
  rgb;image/x-rgb
  rgbe;image/vnd.radiance
  rhtml;application/x-html+ruby
  rif;application/reginfo+xml
  rip;audio/vnd.rip
  ris;application/x-research-info-systems
  rl;application/resource-lists+xml
  rlc;image/vnd.fujixerox.edmics-rlc
  rld;application/resource-lists-diff+xml
  rle;image/x-rle
  rm;audio/vnd.hns.audio
  rmi;audio/x-midi
  rmj;application/vnd.rn-realmedia
  rmm;audio/x-pn-realaudio
  rmp;audio/x-pn-realaudio-plugin
  rms;application/vnd.jcp.javame.midlet-rms
  rmvb;application/vnd.rn-realmedia-vbr
  rmx;application/vnd.rn-realmedia
  rnc;application/relax-ng-compact-syntax
  rnd;application/prs.nprend
  rng;application/x-ringing-tones
  rnx;application/vnd.rn-realplayer
  roa;application/rpki-roa
  roff;application/x-troff
  ros;x-chemical/x-rosdal
  rp9;application/vnd.cloanto.rp9
  rp;image/vnd.rn-realpix
  rpm;application/x-redhat-package-manager
  rpss;application/vnd.nokia.radio-presets
  rpst;application/vnd.nokia.radio-preset
  rq;application/sparql-query
  rs;application/rls-services+xml
  rsd;application/x-rsd+xml
  rsheet;application/urc-ressheet+xml
  rsm;model/vnd.gs-gdl
  rss;application/x-rss+xml
  rst;text/prs.fallenstein.rst
  rt;text/richtext
  rtf;application/rtf
  rtx;text/richtext
  rusd;application/route-usd+xml
  rv;video/vnd.rn-realvideo
  rvx;video/vnd.rn-realvideo
  rw2;image/x-panasonic-raw2
  rxn;x-chemical/x-mdl-rxnfile
  s11;video/vnd.sealed.mpeg1
  s14;video/vnd.sealed.mpeg4
  s1a;application/vnd.sealedmedia.softseal-pdf
  s1e;application/vnd.sealed-xls
  s1g;image/vnd.sealedmedia.softseal-gif
  s1h;application/vnd.sealedmedia.softseal-html
  s1j;image/vnd.sealedmedia.softseal-jpg
  s1m;audio/vnd.sealedmedia.softseal-mpeg
  s1n;image/vnd.sealed-png
  s1p;application/vnd.sealed-ppt
  s1q;video/vnd.sealedmedia.softseal-mov
  s1w;application/vnd.sealed-doc
  s3df;application/vnd.sealed.3df
  s3m;audio/x-s3m
  s;text/x-asm
  sac;application/tamp-sequence-adjust-confirm
  saf;application/vnd.yamaha.smaf-audio
  sam;application/x-amipro
  sami;application/x-sami
  sav;application/x-spss
  saveme;application/octet-stream
  sbk;application/x-tbook
  sbml;application/sbml+xml
  sbs;application/x-spss
  sc;application/vnd.ibm.secure-container
  scala;text/x-scala
  scd;application/vnd.scribus
  sce;application/vnd.etsi.asic-e+zip
  scim;application/scim+json
  scld;application/vnd.doremir.scorecloud-binary-document
  scm;application/scim+json
  scq;application/scvp-cv-request
  scr;application/x-silverlight
  scs;application/vnd.etsi.asic-s+zip
  scsf;application/vnd.sealed.csf
  sct;text/x-scriptlet
  scurl;text/vnd.curl.scurl
  sd2;audio/x-sd2
  sd;x-chemical/x-mdl-sdfile
  sda;application/vnd.stardivision.draw
  sdc;application/vnd.stardivision.calc
  sdd;application/vnd.stardivision.impress
  sdf;application/vnd.kinar
  sdkd;application/vnd.solent.sdkm+xml
  sdkm;application/vnd.solent.sdkm+xml
  sdml;text/plain
  sdo;application/vnd.sealed-doc
  sdoc;application/vnd.sealed-doc
  sdp;application/sdp
  sdr;application/x-sounder
  sds;application/vnd.stardivision.chart
  sdw;application/vnd.stardivision.writer
  sea;application/x-sea
  see;application/vnd.seemail
  seed;application/vnd.fdsn.mseed
  sem;application/vnd.sealed-eml
  sema;application/vnd.sema
  semd;application/vnd.semd
  semf;application/vnd.semf
  seml;application/vnd.sealed-eml
  ser;application/x-java-serialized-object
  set;application/x-set
  setpay;application/set-payment-initiation
  setreg;application/set-registration-initiation
  sfc;application/vnd.nintendo.snes.rom
  sfd-hdstx;application/vnd.hydrostatix.sof-data
  sfd;application/vnd.font-fontforge-sfd
  sfs;application/vnd.spotfire.sfs
  sfv;text/x-sfv
  sg;application/x-sms-rom
  sgb;application/x-gameboy-rom
  sgf;application/x-go-sgf
  sgi;image/vnd.sealedmedia.softseal-gif
  sgif;image/vnd.sealedmedia.softseal-gif
  sgl;application/vnd.stardivision.writer-global
  sgm;text/sgml
  sgml;text/sgml
  sh;application/x-sh
  shape;application/x-dia-shape
  shar;application/x-shar
  shf;application/shf+xml
  shn;application/x-shorten
  shp;application/x-qgis
  shtml;text/html
  shx;application/x-qgis
  si;text/vnd.wap.si
  siag;application/x-siag
  sic;application/vnd.wap.sic
  sid;audio/prs.sid
  sieve;application/sieve
  sig;application/pgp-signature
  sik;application/x-trash
  sil;audio/x-silk
  silo;model/mesh
  sis;application/vnd.symbian.install
  sisx;x-epoc/x-sisx-app
  sit;application/x-stuffit
  sitx;application/x-stuffit
  siv;application/sieve
  sjp;image/vnd.sealedmedia.softseal-jpg
  sjpg;image/vnd.sealedmedia.softseal-jpg
  sk1;image/x-skencil
  sk;image/x-skencil
  skd;application/x-koan
  skm;application/x-koan
  skp;application/x-koan
  skr;application/pgp-keys
  skt;application/x-koan
  sl;text/vnd.wap.sl
  sla;application/vnd.scribus
  slaz;application/vnd.scribus
  slc;application/vnd.wap-slc
  sldm;application/vnd.ms-powerpoint.slide.macroenabled.12
  sldx;application/vnd.openxmlformats-officedocument.presentationml.slide
  slk;text/x-spreadsheet
  sls;application/route-s-tsid+xml
  slt;application/vnd.epson.salt
  sm;application/vnd.stepmania.stepchart
  smaf;application/x-smaf
  smc;application/vnd.nintendo.snes.rom
  smd;application/vnd.stardivision.mail
  smf;application/vnd.stardivision.math
  smh;application/vnd.sealed-mht
  smht;application/vnd.sealed-mht
  smi;application/smil
  smil;application/smil
  smk;video/vnd.radgamettools.smacker
  sml;application/smil
  smo;video/vnd.sealedmedia.softseal-mov
  smov;video/vnd.sealedmedia.softseal-mov
  smp3;audio/vnd.sealedmedia.softseal-mpeg
  smp;audio/vnd.sealedmedia.softseal-mpeg
  smpg;video/vnd.sealed.mpeg1
  sms;application/vnd.3gpp.sms
  smv;audio/smv
  smzip;application/vnd.stepmania.package
  snd;audio/basic
  snf;application/x-font-snf
  so;application/x-sharedlib
  soa;text/dns
  soc;application/sgml-open-catalog
  sol;application/x-solids
  spc;x-chemical/x-galactic-spc
  spd;application/vnd.sealedmedia.softseal-pdf
  spdf;application/vnd.sealedmedia.softseal-pdf
  spec;text/x-rpm-spec
  spf;application/vnd.yamaha.smaf-phrase
  spl;application/x-futuresplash
  spm;application/x-source-rpm
  spn;image/vnd.sealed-png
  spng;image/vnd.sealed-png
  spo;text/vnd.in3d.spot
  spot;text/vnd.in3d.spot
  spp;application/vnd.sealed-ppt
  sppt;application/vnd.sealed-ppt
  spq;application/scvp-vp-request
  spr;application/x-sprite
  sprite;application/x-sprite
  sps;application/x-spss
  spx;audio/ogg
  sql;application/sql
  sr2;image/x-sony-sr2
  sr;application/vnd.sigrok.session
  src;application/x-wais-source
  srf;image/x-sony-srf
  srt;application/x-subrip
  sru;application/sru+xml
  srx;application/sparql-results+xml
  ss;text/x-scheme
  ssa;text/x-ssa
  ssdl;application/x-ssdl+xml
  sse;application/vnd.kodak-descriptor
  ssf;application/vnd.epson.ssf
  ssi;text/x-server-parsed-html
  ssm;application/x-streamingmedia
  ssml;application/ssml+xml
  sst;application/vnd.ms-pki.certstore
  ssw;video/vnd.sealed-swf
  sswf;video/vnd.sealed-swf
  st;application/vnd.sailingtracker.track
  stc;application/vnd.sun.xml.calc.template
  std;application/vnd.sun.xml.draw.template
  step;application/x-step
  stf;application/vnd.wt.stf
  sti;application/vnd.sun.xml.impress.template
  stif;application/vnd.sealed-tiff
  stk;application/hyperstudio
  stl;application/vnd.ms-pki.stl
  stm;application/vnd.sealedmedia.softseal-html
  stml;application/vnd.sealedmedia.softseal-html
  stp;application/x-step
  str;application/vnd.pg.format
  study-inter;application/vnd.vd-study
  stw;application/vnd.sun.xml.writer.template
  sty;text/x-tex
  sub;image/vnd.dvb.subtitle
  sun;image/x-sun-raster
  sus;application/vnd.sus-calendar
  susp;application/vnd.sus-calendar
  sv4cpio;application/x-sv4cpio
  sv4crc;application/x-sv4crc
  sv;text/x-svsrc
  svc;application/vnd.dvb_service
  svd;application/vnd.svd
  svf;image/vnd.dwg
  svg;image/svg+xml
  svgz;image/svg+xml
  svh;text/x-svhdr
  svr;application/x-world
  sw;x-chemical/x-swissprot
  swa;application/x-director
  swf;application/vnd.adobe.flash-movie
  swfl;application/x-shockwave-flash
  swi;application/vnd.arastra.swi
  swm;application/x-ms-wim
  sxc;application/vnd.sun.xml.calc
  sxd;application/vnd.sun.xml.draw
  sxg;application/vnd.sun.xml.writer.global
  sxi;application/vnd.vd-study
  sxl;application/vnd.sealed-xls
  sxls;application/vnd.sealed-xls
  sxm;application/vnd.sun.xml.math
  sxw;application/vnd.sun.xml.writer
  sylk;text/x-spreadsheet
  t2t;text/x-txt2tags
  t3;application/x-t3vm-image
  t;application/x-troff
  tag;text/prs.lines.tag
  taglet;application/vnd.mynfc
  talk;text/x-speech
  tam;application/vnd.onepager
  tamp;application/vnd.onepagertamp
  tamx;application/vnd.onepagertamx
  tao;application/vnd.tao.intent-module-archive
  tap;image/vnd.tencent.tap
  tar;application/x-tar
  tat;application/vnd.onepagertat
  tatp;application/vnd.onepagertatp
  tatx;application/vnd.onepagertatx
  tau;application/tamp-apex-update
  taz;application/x-gtar
  tb2;application/x-bzip-compressed-tar
  tbk;application/x-toolbook
  tbz2;application/x-gtar
  tbz;application/x-gtar
  tcap;application/vnd.3gpp2.tcap
  tcl;application/x-tcl
  tcsh;text/x-script.tcsh
  tcu;application/tamp-community-update
  td;application/urc-targetdesc+xml
  teacher;application/vnd.smart.teacher
  tei;application/tei+xml
  teicorpus;application/tei+xml
  ter;application/tamp-error
  tex;application/x-tex
  texi;application/x-texinfo
  texinfo;application/x-texinfo
  text;application/x-plain
  tfi;application/thraud+xml
  tfm;application/x-tex-tfm
  tga;image/x-targa
  tgf;x-chemical/x-mdl-tgf
  tgz;application/x-gtar
  theme;application/x-theme
  themepack;application/x-windows-themepack
  thmx;application/vnd.ms-officetheme
  tif;image/tiff
  tiff;image/tiff
  tk;text/x-tcl
  tlclient;application/vnd.cendio.thinlinc.clientconf
  tlrz;application/x-lrzip-compressed-tar
  tlz;application/x-lzma-compressed-tar
  tm;text/x-texmacs
  tmo;application/vnd.tmobile-livetv
  tnef;application/vnd.ms-tnef
  tnf;application/vnd.ms-tnef
  toc;application/x-cdrdao-toc
  torrent;application/x-bittorrent
  tpic;image/x-tga
  tpl;application/vnd.groove-tool-template
  tpt;application/vnd.trid.tpt
  tr;application/x-troff
  tra;application/vnd.trueapp
  tree;application/vnd.rainstor.data
  trig;application/trig
  trm;application/x-msterminal
  ts;text/vnd.trolltech.linguist
  tsa;application/tamp-sequence-adjust
  tsd;application/timestamped-data
  tsi;audio/x-tsp-audio
  tsp;application/x-dsptype
  tsq;application/tamp-status-query
  tsr;application/tamp-status-response
  tst;application/vnd.etsi.timestamp-token
  tsv;text/tab-separated-values
  tta;audio/x-tta
  ttc;font/collection
  ttf;font/ttf
  ttl;text/turtle
  ttml;application/ttml+xml
  ttx;application/x-font-ttx
  tuc;application/tamp-update-confirm
  tur;application/tamp-update
  turbot;image/x-florian
  twd;application/vnd.simtech-mindmapper
  twds;application/vnd.simtech-mindmapper
  txd;application/vnd.genomatix.tuxedo
  txf;application/vnd.mobius.txf
  txt;text/plain
  txz;application/x-xz-compressed-tar
  tzo;application/x-tzo
  u32;application/x-authorware-bin
  u8dsn;message/global-delivery-status
  u8mdn;message/global-disposition-notification
  u8msg;message/global
  udeb;application/vnd.debian.binary-package
  ufd;application/vnd.ufdl
  ufdl;application/vnd.ufdl
  ufraw;application/x-ufraw
  ui;application/x-designer
  uil;text/x-uil
  uis;application/urc-uisocketdesc+xml
  uls;text/x-iuls
  ult;audio/x-mod
  ulx;application/x-glulx
  umj;application/vnd.umajin
  unf;application/x-nes-rom
  uni;text/uri-list
  unif;application/x-nes-rom
  unis;text/uri-list
  unityweb;application/vnd.unity
  unv;application/x-i-deas
  uo;application/vnd.uoml+xml
  uoml;application/vnd.uoml+xml
  upa;application/vnd.fints
  uri;text/uri-list
  uric;text/vnd.si.uricatalogue
  urim;application/vnd.uri-map
  urimap;application/vnd.uri-map
  uris;text/uri-list
  url;application/x-mswinurl
  urls;text/uri-list
  ustar;application/x-ustar
  utz;application/vnd.uiq.theme
  uu;text/x-uuencode
  uue;text/x-uuencode
  uva;audio/vnd.dece.audio
  uvd;application/vnd.dece.data
  uvf;application/vnd.dece.data
  uvg;image/vnd.dece.graphic
  uvh;video/vnd.dece.hd
  uvi;image/vnd.dece.graphic
  uvm;video/vnd.dece.mobile
  uvp;video/vnd.dece.pd
  uvs;video/vnd.dece.sd
  uvt;application/vnd.dece.ttml+xml
  uvu;video/vnd.dece-mp4
  uvv;video/vnd.dece.video
  uvva;audio/vnd.dece.audio
  uvvd;application/vnd.dece.data
  uvvf;application/vnd.dece.data
  uvvg;image/vnd.dece.graphic
  uvvh;video/vnd.dece.hd
  uvvi;image/vnd.dece.graphic
  uvvm;video/vnd.dece.mobile
  uvvp;video/vnd.dece.pd
  uvvs;video/vnd.dece.sd
  uvvt;application/vnd.dece.ttml+xml
  uvvu;video/vnd.dece-mp4
  uvvv;video/vnd.dece.video
  uvvx;application/vnd.dece.unspecified
  uvvz;application/vnd.dece-zip
  uvx;application/vnd.dece.unspecified
  uvz;application/vnd.dece-zip
  v64;application/x-n64-rom
  v;text/x-verilog
  val;x-chemical/x-ncbi-asn1-binary
  vala;text/x-vala
  vapi;text/x-vala
  vbk;audio/vnd.nortel.vbk
  vcard;text/vcard
  vcd;application/x-cdlink
  vcf;text/vcard
  vcg;application/vnd.groove-vcard
  vcs;text/x-vcalendar
  vct;text/vcard
  vcx;application/vnd.vcx
  vd;application/vividence.scriptfile
  vda;application/x-vda
  vdo;video/x-vdo
  vew;application/x-groupwise
  vfr;application/vnd.tml
  vhd;text/x-vhdl
  vhdl;text/x-vhdl
  viaframe;application/vnd.tml
  vis;application/vnd.informix-visionary
  viv;video/vnd.vivo
  vivo;video/vnd.vivo
  vlc;audio/x-mpegurl
  vmd;x-chemical/x-vmd
  vmf;application/x-vocaltec-media-file
  vms;x-chemical/x-vamas-iso14976
  vmt;application/vnd.valve.source.material
  vob;video/x-ms-vob
  voc;audio/x-voc
  vor;application/vnd.stardivision.writer
  vos;video/x-vosaic
  vox;application/x-authorware-bin
  vqe;audio/x-twinvq-plugin
  vqf;audio/x-twinvq
  vql;audio/x-twinvq-plugin
  vrm;x-world/x-vrml
  vrml;model/vrml
  vrt;x-world/x-vrt
  vsc;application/vnd.vidsoft.vidconference
  vsd;application/vnd.visio
  vsf;application/vividence.scriptfile
  vss;application/vnd.visio
  vst;application/vnd.visio
  vsw;application/vnd.visio
  vtd;application/vividence.scriptfile
  vtf;image/vnd.valve.source.texture
  vtt;text/x-vtt
  vtu;model/vnd.vtu
  vxml;application/voicexml+xml
  w3d;application/x-director
  w60;application/x-wordperfect6.0
  w61;application/x-wordperfect6.1
  w6w;application/msword
  wad;application/x-doom
  wadl;application/vnd.sun.wadl+xml
  wav;audio/vnd.dts
  wax;audio/x-ms-wax
  wb1;application/x-qpro
  wb2;application/x-quattropro
  wb3;application/x-quattropro
  wbmp;image/vnd-wap-wbmp
  wbs;application/vnd.criticaltools.wbs+xml
  wbxml;application/vnd-wap-wmlc
  wcm;application/vnd.ms-works
  wdb;application/vnd.ms-works
  wdp;image/vnd.ms-photo
  web;application/vnd.xara
  weba;audio/x-webm
  webapp;application/x-web-app-manifest+json
  webm;video/x-webm
  webp;image/x-webp
  wg;application/vnd.pmi.widget
  wgt;application/widget
  wif;application/watcherinfo+xml
  wim;application/x-ms-wim
  win;model/vnd.gs-gdl
  wiz;application/msword
  wk1;application/x-123
  wk3;application/vnd.lotus-1-2-3
  wk4;application/vnd.lotus-1-2-3
  wk;application/x-123
  wkdownload;application/x-partial-download
  wks;application/vnd.lotus-1-2-3
  wlnk;application/link-format
  wm;video/x-ms-wm
  wma;audio/x-ms-wma
  wmc;application/vnd.wmc
  wmd;application/x-ms-wmd
  wmf;image/wmf
  wml;text/vnd.wap-wml
  wmlc;application/vnd-wap-wmlc
  wmls;text/vnd.wap.wmlscript
  wmlsc;application/vnd.wap.wmlscriptc
  wmv;video/x-ms-wmv
  wmx;video/x-ms-wmx
  wmz;application/x-ms-wmz
  woff2;font/woff2
  woff;font/woff
  word;application/msword
  wp4;application/vnd.wordperfect
  wp5;application/vnd.wordperfect5.1
  wp6;application/x-wordperfect6.1
  wp;application/wordperfect5.1
  wpd;application/vnd.wordperfect
  wpg;application/x-wpg
  wpl;application/vnd.ms-wpl
  wpp;application/vnd.wordperfect
  wps;application/vnd.ms-works
  wq1;application/x-lotus
  wqd;application/vnd.wqd
  wrd;application/x-msword
  wri;application/x-mswrite
  wrl;model/vrml
  wrz;model/vrml
  wsc;text/x-scriptlet
  wsdl;application/wsdl+xml
  wsgi;text/x-python
  wspolicy;application/wspolicy+xml
  wsrc;application/x-wais-source
  wtb;application/vnd.webturbo
  wtk;application/x-wintalk
  wv;application/vnd.wv.csp+wbxml
  wvc;audio/x-wavpack-correction
  wvp;audio/x-wavpack
  wvx;video/x-ms-wvx
  wwf;application/x-wwf
  wz;application/x-wingz
  x-png;image/png
  x32;application/x-authorware-bin
  x3d;application/vnd.hzn-3d-crossword
  x3db;model/x3d+fastinfoset
  x3dbz;model/x-x3d+binary
  x3dv;model/x3d-vrml
  x3dvz;model/x-x3d+vrml
  x3dz;model/x3d+xml
  x3f;image/x-sigma-x3f
  x_b;model/vnd.parasolid.transmit.binary
  x_t;model/vnd.parasolid.transmit.text
  xac;application/x-gnucash
  xaml;application/x-xaml+xml
  xap;application/x-silverlight-app
  xar;application/vnd.xara
  xav;application/xcap-att+xml
  xbap;application/x-ms-xbap
  xbd;application/vnd.fujixerox.docuworks.binder
  xbel;application/x-xbel
  xbl;application/xml
  xbm;image/x-xbitmap
  xca;application/xcap-caps+xml
  xcf;application/x-xcf
  xcs;application/calendar+xml
  xct;application/vnd.fujixerox.docuworks.container
  xdd;application/bacnet-xdd+zip
  xdf;application/mrb-consumer+xml
  xdm;application/vnd.syncml.dm+xml
  xdp;application/vnd.adobe.xdp+xml
  xdr;video/x-amt-demorun
  xdssc;application/dssc+xml
  xdw;application/vnd.fujixerox.docuworks
  xel;application/xcap-el+xml
  xenc;application/xenc+xml
  xer;application/patch-ops-error+xml
  xfd;application/vnd.xfdl
  xfdf;application/vnd.adobe.xfdf
  xfdl;application/vnd.xfdl
  xgz;x-xgl/x-drawing
  xht;application/xhtml+xml
  xhtm;application/vnd.pwg-xhtml-print+xml
  xhtml;application/vnd.pwg-xhtml-print+xml
  xhvml;application/xhtml-voice+xml
  xi;audio/x-xi
  xif;image/vnd.xiff
  xl;application/x-excel
  xla;application/vnd.ms-excel
  xlam;application/vnd.ms-excel.addin.macroenabled.12
  xlb;application/vnd.ms-excel
  xlc;application/vnd.ms-excel
  xld;application/x-excel
  xlf;application/x-xliff+xml
  xliff;application/x-xliff
  xlim;application/vnd.xmpie.xlim
  xlk;application/x-excel
  xll;application/x-excel
  xlm;application/vnd.ms-excel
  xlr;application/vnd.ms-works
  xls;application/vnd.ms-excel
  xlsb;application/vnd.ms-excel.sheet.binary.macroenabled.12
  xlsm;application/vnd.ms-excel.sheet.macroenabled.12
  xlsx;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  xlt;application/vnd.ms-excel
  xltm;application/vnd.ms-excel.template.macroenabled.12
  xltx;application/vnd.openxmlformats-officedocument.spreadsheetml-template
  xlv;application/x-excel
  xlw;application/vnd.ms-excel
  xm;audio/x-xm
  xmf;audio/x-xmf
  xmi;text/x-xmi
  xml;application/xml
  xmls;application/dskpp+xml
  xmt_bin;model/vnd.parasolid.transmit-binary
  xmt_txt;model/vnd.parasolid.transmit-text
  xmz;x-xgl/x-movie
  xns;application/xcap-ns+xml
  xo;application/vnd.olpc-sugar
  xodp;application/vnd.collabio.xodocuments.presentation
  xods;application/vnd.collabio.xodocuments.spreadsheet
  xodt;application/vnd.collabio.xodocuments.document
  xop;application/xop+xml
  xotp;application/vnd.collabio.xodocuments.presentation-template
  xots;application/vnd.collabio.xodocuments.spreadsheet-template
  xott;application/vnd.collabio.xodocuments.document-template
  xpdl;application/xml
  xpi;application/x-xpinstall
  xpix;application/x-vnd.ls-xpix
  xpl;application/x-xproc+xml
  xpm;image/x-xpixmap
  xpr;application/vnd.is-xpr
  xps;application/vnd.ms-xpsdocument
  xpw;application/vnd.intercon.formnet
  xpx;application/vnd.intercon.formnet
  xsd;application/xml
  xsf;application/prs.xsf+xml
  xsl;application/xml
  xslfo;text/x-xslfo
  xslt;application/xslt+xml
  xsm;application/vnd.syncml+xml
  xspf;application/x-xspf+xml
  xsr;video/x-amt-showrun
  xtel;x-chemical/x-xtel
  xul;application/vnd.mozilla.aul+xml
  xvm;application/xhtml-voice+xml
  xvml;application/xhtml-voice+xml
  xwd;image/x-xwindowdump
  xyz;x-chemical/x-xyz
  xyze;image/vnd.radiance
  xz;application/x-xz
  yaml;application/x-yaml
  yang;application/yang
  yin;application/yin+xml
  yme;application/vnd.yaoweme
  yml;application/x-yaml
  yt;application/vnd.youtube.yt
  z1;application/x-zmachine
  z2;application/x-zmachine
  z3;application/x-zmachine
  z4;application/x-zmachine
  z5;application/x-zmachine
  z64;application/x-n64-rom
  z6;application/x-zmachine
  z7;application/x-zmachine
  z8;application/x-zmachine
  z;application/x-compress
  zabw;application/x-abiword
  zaz;application/vnd.zzazz.deck+xml
  zfc;application/vnd.filmit.zfc
  zip;application/zip
  zir;application/vnd.zul
  zirz;application/vnd.zul
  zmm;application/vnd.handheld-entertainment+xml
  zmt;x-chemical/x-mopac-input
  zone;text/dns
  zoo;application/x-zoo
  zsav;application/x-spss-sav
  zsh;text/x-script.zsh
  zz;application/zlib
  ~;application/x-trash
  
  61:application::
  x-access;;
  x-amf;;
  x-appledouble;;base64
  x-arc;;
  x-bzdvi;;
  x-bzpdf;;
  x-bzpostscript;;
  x-class-file;;
  x-core;;
  x-cpio-compressed;;
  x-executable;;
  x-font-dos;;
  x-font-framemaker;;
  x-font-libgrx;;
  x-font-sunos-news;;
  x-font-tex-tfm;;
  x-font-tex;;
  x-font-vfont;;
  x-gdbm;;
  x-ghostview;;
  x-gtktalog;;
  x-gunzip;;
  x-gz-font-linux-psf;;
  x-gzdvi;;
  x-gzpdf;;
  x-gzpostscript;;
  x-ideas;;
  x-iff;;
  x-ipod-firmware;;
  x-java-applet;;
  x-java-bean;;
  x-kdelnk;;
  x-kspread-crypt;;
  x-ksysv-package;;
  x-kword-crypt;;
  x-lotus-123;;
  x-matroska;;
  x-mozilla-bookmarks;;
  x-ms-tnef;;
  x-nautilus-link;;
  x-news-message-id;;
  x-ole-storage;;
  x-pef-executable;;
  x-profile;;
  x-raw-disk-image-xz-compressed;;
  x-remote_printing;;
  x-riff;;
  x-rx;;
  x-sc;;
  x-slp;;
  x-sqlite2;;
  x-sqlite3;;
  x-toutdoux;;
  x-troff-man-compressed;;
  x-videolan;;
  x-word;;base64
  x-www-form-urlencoded;;
  x-x400-bp;;
  x-xzpdf;;
  x-zerosize;;
  x-zip-compressed-fb2;;
  
  458:application::E
  x-123;wk,wk1;
  x-7z-compressed;7z;
  x-abiword;abw,zabw;
  x-acad;dwg;
  x-ace-compressed;ace;
  x-ace;ace;
  x-aim;aim;
  x-alz;alz;
  x-amipro;sam;
  x-annodex;anx;
  x-aportisdoc;pdb,pdc;
  x-apple-diskimage;dmg;
  x-applix-spreadsheet;as;
  x-applix-word;aw;
  x-applixware;aw;
  x-archive;a,ar;
  x-arj;arj;
  x-asp;asp;
  x-atomserv+xml;atomsrv;
  x-authorware-bin;aab,x32,u32,vox;
  x-authorware-map;aam;
  x-authorware-seg;aas;
  x-awk;awk;
  x-base64;mm,mme;
  x-bbolin;lin;
  x-bcpio;bcpio;
  x-binary;bin;
  x-binhex40;hqx;
  x-binhex4;hqx;
  x-binhex;hqx;
  x-bittorrent;torrent;
  x-bleeper;bleep;base64
  x-blender;blender,blend;
  x-blorb;blb,blorb;
  x-book;boo,book;
  x-bsh;bsh,sh,shar;
  x-bytecode.elisp;elc;
  x-bytecode.python;pyc;
  x-bzip-compressed-tar;tbz2,tbz,tb2;
  x-bzip2;bz2,boz;
  x-bzip;bz,bz2;
  x-cab;cab;
  x-cap;cap,pcap;
  x-cb7;cb7;
  x-cbr;cbr,cba,cbt,cbz,cb7;
  x-cbt;cbt;
  x-cbz;cbz;
  x-ccmx;ccmx;
  x-cd-image;iso,iso9660;
  x-cdf;cdf,cda;
  x-cdlink;vcd;
  x-cdrdao-toc;toc;
  x-cfs-compressed;cfs;
  x-chat;chat,cha;
  x-chess-pgn;pgn;
  x-chrome-extension;crx;
  x-cisco-vpn-settings;pcf;
  x-clariscad;ccad;
  x-cmu-raster;ras;
  x-cocoa;cco;
  x-compactpro;cpt;
  x-compress;z;base64
  x-compressed-tar;tgz;
  x-compressed;gz,tgz,z,zip;
  x-conference;nsc;
  x-cpio;cpio;base64
  x-cpt;cpt;
  x-csh;csh;8bit
  x-cu-seeme;cu,csm;
  x-cue;cue;
  x-dar;dar;
  x-dbf;dbf;
  x-dc-rom;dc;
  x-debian-package;deb,udeb;
  x-deepv;deepv;
  x-designer;ui;
  x-desktop;desktop,kdelnk;
  x-dgc-compressed;dgc;
  x-dia-diagram;dia;
  x-dia-shape;shape;
  x-director;dcr,dir,dxr,cst,cct,cxt,w3d,fgd,swa;
  x-dms;dms;
  x-docbook+xml;dbk,docbook;
  x-doom;wad;
  x-drafting;drw;
  x-dsptype;tsp;
  x-dtbncx+xml;ncx;
  x-dtbook+xml;dtb;
  x-dtbresource+xml;res;
  x-dvi;dvi;base64
  x-dxf;dxf;
  x-e-theme;etheme;
  x-egon;egon;
  x-elc;elc;
  x-envoy;evy,env;
  x-esrehber;es;
  x-eva;eva;
  x-excel;xl,xla,xlb,xlc,xld,xlk,xll,xlm,xls,xlt,xlv,xlw;
  x-fictionbook+xml;fb2;
  x-fluid;fl;
  x-font-afm;afm;
  x-font-bdf;bdf;
  x-font-ghostscript;gsf;
  x-font-linux-psf;psf;
  x-font-otf;otf;
  x-font-pcf;pcf;
  x-font-snf;snf;
  x-font-speedo;spd;
  x-font-ttf;ttc,ttf;
  x-font-ttx;ttx;
  x-font-type1;pfa,pfb,pfm,afm,gsf;
  x-font;pfa,pfb,gsf,pcf,pcf.z;
  x-fractals;fif;
  x-frame;mif;
  x-freearc;arc;
  x-freelance;pre;
  x-freeloader;frl;
  x-freemind;mm;
  x-futuresplash;spl;
  x-gameboy-rom;gb,gbc,cgb,sgb;
  x-gamecube-rom;iso;
  x-gba-rom;gba,agb;
  x-gca-compressed;gca;
  x-gedcom;ged,gedcom;
  x-genesis-rom;gen,smd,32x,mdx;
  x-gettext-translation;gmo,mo;
  x-glade;glade;
  x-glulx;ulx;
  x-gnucash;gnucash,gnc,xac;
  x-gnumeric;gnumeric;
  x-gnunet-directory;gnd;
  x-gnuplot;gp,gplt,gnuplot;
  x-gnutar;tgz;
  x-go-sgf;sgf;
  x-gpx+xml;gpx;
  x-gramps-xml;gramps;
  x-graphing-calculator;gcf;
  x-graphite;gra;
  x-groupwise;vew;
  x-gsp;gsp;
  x-gss;gss;
  x-gtar;gtar,tgz,tbz2,tbz,taz;base64
  x-gtk-builder;ui;
  x-gxf;gxf;
  x-gzip;gz,gzip,tgz;base64
  x-hdf;hdf,hdf4,h4,hdf5,h5;
  x-helpfile;help,hlp;
  x-hep;hep;
  x-hlp;hlp;
  x-hta;hta;
  x-html+ruby;rhtml;8bit
  x-httpd-eruby;rhtml;
  x-httpd-imap;imap;
  x-httpd-php-source;phps;
  x-httpd-php3-preprocessed;php3p;
  x-httpd-php3;php3;
  x-httpd-php4;php4;
  x-httpd-php5;php5;
  x-httpd-php;phtml,pht,php;8bit
  x-hwp;hwp;
  x-hwt;hwt;
  x-i-deas;unv;
  x-ica;ica;
  x-illustrator;ai;
  x-ima;ima;
  x-imagemap;imagemap,imap;8bit
  x-inf;inf;
  x-info;info;
  x-install-instructions;install;
  x-internet-signup;ins,isp;
  x-internett-signup;ins;
  x-inventor;iv;
  x-ip2;ip;
  x-iphone;iii;
  x-iso9660-image;iso;
  x-it87;it87;
  x-iwork-keynote-sffkey;key;
  x-jam;jam;
  x-java-archive;jar;
  x-java-byte-code;class;
  x-java-class;class;
  x-java-commerce;jcm;
  x-java-jce-keystore;jceks;
  x-java-jnlp-file;jnlp;
  x-java-keystore;jks,ks;
  x-java-pack200;pack;
  x-java-serialized-object;ser;
  x-java-vm;class;
  x-java;class;
  x-javascript;js;
  x-jbuilder-project;jpr,jpx;
  x-jmol;jmz;
  x-jsonml+json;jsonml;
  x-karbon;karbon;
  x-kchart;chrt;
  x-kexi-connectiondata;kexic;
  x-kexiproject-shortcut;kexis;
  x-kexiproject-sqlite2;kexi;
  x-kexiproject-sqlite3;kexi;
  x-kformula;kfo;
  x-killustrator;kil;
  x-kivio;flw;
  x-koan;skp,skd,skt,skm;
  x-kontour;kon;
  x-kpovmodeler;kpm;
  x-kpresenter;kpr,kpt;
  x-krita;kra;
  x-ksh;ksh;
  x-kspread;ksp;
  x-kugar;kud;
  x-kword;kwd,kwt;
  x-latex;latex,ltx;8bit
  x-lha;lha,lzh;
  x-lhz;lhz;
  x-lisp;lsp;
  x-livescreen;ivy;
  x-lotus;wq1;
  x-lotusscreencam;scm;
  x-lrzip-compressed-tar;tlrz;
  x-lrzip;lrz;
  x-lua-bytecode;luac;
  x-lyx;lyx;
  x-lz4;lz4;
  x-lzh-compressed;lzh,lha;
  x-lzh;lzh;
  x-lzip;lz;
  x-lzma-compressed-tar;tlz;
  x-lzma;lzma;
  x-lzop;lzo;
  x-lzx;lzx;
  x-m3g;m3g;
  x-m4;m4;
  x-mac-binary;bin;
  x-mac-binhex40;hqx;
  x-mac-binhex;hqx;
  x-mac-compactpro;cpt;
  x-macbinary;bin;
  x-magic-cap-package-1.0;mc$;
  x-magicpoint;mgp;
  x-maker;frm,maker,frame,fm,fb,book,fbdoc;
  x-markaby;mab;
  x-mathcad;#,mcd;mcd,
  x-mbedlet;mbd;
  x-mcad;mcd;
  x-meme;mm;
  x-metalink+xml;metalink;
  x-midi;mid,midi;
  x-mie;mie;
  x-mif;mif;
  x-mime;aps;
  x-mimearchive;mhtml,mht;
  x-mix-transfer;nix;
  x-mobipocket-ebook;prc,mobi;
  x-mplayer2;asx;
  x-ms-application;application;
  x-ms-dos-executable;exe;
  x-ms-shortcut;lnk;
  x-ms-wim;wim,swm;
  x-ms-wmd;wmd;
  x-ms-wmz;wmz;
  x-ms-xbap;xbap;
  x-msaccess;mdb,mda,mde,mdf;base64
  x-msbinder;obd;
  x-mscardfile;crd;
  x-msclip;clp;
  x-msdos-program;com,exe,bat,dll;base64
  x-msdownload;exe,dll,com,bat,msi;base64
  x-msexcel;xla,xls,xlw;
  x-msi;msi;
  x-msmediaview;mvb,m13,m14;
  x-msmetafile;wmf,wmz,emf,emz;
  x-msmoney;mny;
  x-mspowerpoint;pot,pps,ppt,ppz;
  x-mspublisher;pub;
  x-msschedule;scd;
  x-msterminal;trm;
  x-mswinurl;url;
  x-msword-template;dot;
  x-msword;doc,dot,wrd;base64
  x-mswrite;wri;
  x-msx-rom;msx;
  x-n64-rom;n64,z64,v64;
  x-navi-animation;ani;
  x-navidoc;nvd;
  x-navimap;map;
  x-navistyle;stl;
  x-nes-rom;nes,nez,unf,unif;
  x-netcdf;nc,cdf;
  x-netmc;mcp;
  x-netshow-channel;nsc;
  x-newton-compatible-pkg;pkg;
  x-nintendo-ds-rom;nds;
  x-nokia-9000-communicator-add-on-software;aos;
  x-ns-proxy-autoconfig;pac,dat;
  x-nwc;nwc;
  x-nzb;nzb;
  x-object;o;
  x-oleo;oleo;
  x-omc;omc;
  x-omcdatamaker;omcd;
  x-omcregerator;omcr;
  x-omdoc+xml;omdoc;
  x-onenote;onetoc,onetoc2,onetmp,onepkg;
  x-owl+xml;owx;
  x-oz-application;oza;
  x-pagemaker;pm5,pt5,pm,pm4,p65,pm6,pmd;
  x-pak;pak;
  x-par2;PAR2;
  x-partial-download;wkdownload,crdownload,part;
  x-pc-engine-rom;pce;
  x-pcl;pcl;
  x-perl;pl,pm,al,perl,pod,t;8bit
  x-pgp;pgp;
  x-php;php,php3,php4,php5,phps;
  x-pics-rules;prf;
  x-pixclscript;plx;
  x-pkcs-12;p12;
  x-pkcs-crl;crl;
  x-pkcs10;p10;
  x-pkcs12;p12,pfx;
  x-pkcs7-certificates;p7b,spc;
  x-pkcs7-certreqresp;p7r;
  x-pkcs7-crl;crl;
  x-pkcs7-mime;p7c,p7m;
  x-pkcs7-signature;p7a;
  x-plain;text;
  x-planperfect;pln;
  x-pocket-word;psw;
  x-pointplus;css;
  x-portable-anymap;pnm;
  x-powerpoint;ppt;
  x-pro_eng;part,prt;
  x-project;mpc,mpt,mpv,mpx;
  x-pw;pw;
  x-python-bytecode;pyc,pyo;
  x-python-code;pyc,pyo;
  x-python;py;8bit
  x-qgis;qgs,shp,shx;
  x-qpress;qp;
  x-qpro;wb1;
  x-qtiplot;qti;
  x-quattropro;wb1,wb2,wb3;
  x-quicktime-media-link;qtl;
  x-quicktimeplayer;qtl;
  x-qw;qif;
  x-ram;ram;
  x-rar-compressed;rar;base64
  x-rar;rar;
  x-raw-disk-image;raw-disk-image,img;
  x-redhat-package-manager;rpm;
  x-research-info-systems;ris;
  x-ringing-tones;rng;
  x-rpm;rpm;
  x-rsd+xml;rsd;
  x-rss+xml;rss;
  x-rtf;rtf;
  x-ruby;rb,rbw;8bit
  x-sami;smi,sami;
  x-sdp;sdp;
  x-sea;sea;
  x-seelogo;sl;
  x-set;set;
  x-sh;sh;8bit
  x-shar;shar,sh;8bit
  x-shared-library-la;la;
  x-sharedlib;so;
  x-shellscript;sh;
  x-shockwave-flash;swf,swfl;
  x-shorten;shn;
  x-siag;siag;
  x-silverlight-app;xap;
  x-silverlight;scr;
  x-sit;sit;
  x-sla;stl;
  x-smaf;mmf,smaf;
  x-sms-rom;sms,gg,sg;
  x-solids;sol;
  x-sounder;sdr;
  x-source-rpm;spm;
  x-sprite;spr,sprite;
  x-spss-por;por;
  x-spss-sav;sav,zsav;
  x-spss;sav,sbs,sps,spo,spp;
  x-sql;sql;
  x-ssdl+xml;ssdl;
  x-step;step,stp;
  x-streamingmedia;ssm;
  x-stuffit;sit,sitx;base64
  x-stuffitx;sitx;
  x-subrip;srt;
  x-sv4cpio;sv4cpio;base64
  x-sv4crc;sv4crc;base64
  x-t3vm-image;t3;
  x-t602;602;
  x-tads;gam;
  x-tar;tar,gtar,gem;base64
  x-tarz;taz;
  x-tbook;sbk,tbk;
  x-tcl;tcl;8bit
  x-tex-gf;gf;
  x-tex-pk;pk;
  x-tex-tfm;tfm;
  x-tex;tex;8bit
  x-texinfo;texinfo,texi;8bit
  x-tgif;obj;
  x-theme;theme;
  x-toolbook;tbk;
  x-trash;~,%,bak,old,sik;
  x-trig;trig;
  x-troff-man;man;8bit
  x-troff-me;me;
  x-troff-ms;ms;
  x-troff-msvideo;avi;
  x-troff;t,tr,roff;8bit
  x-tzo;tzo;
  x-ufraw;ufraw;
  x-ustar;ustar;base64
  x-vda;vda;
  x-visio;vsd,vst,vsw;
  x-vmsbackup;bck;base64
  x-vnd.audioexplosion.mzz;mzz;
  x-vnd.ls-xpix;xpix;
  x-vocaltec-media-desc;vmd;
  x-vocaltec-media-file;vmf;
  x-vrml;vrml;
  x-wais-source;src,wsrc;
  x-web-app-manifest+json;webapp;
  x-wii-rom;iso;
  x-windows-themepack;themepack;
  x-wingz;wz;
  x-winhelp;hlp;
  x-winhlp;hlp;
  x-wintalk;wtk;
  x-wordperfect6.0;w60,wp5;
  x-wordperfect6.1;wp6,w61;
  x-wordperfect;wp,wp5,wp6,wpd;
  x-world;svr,wrl;
  x-wpg;wpg;
  x-wpwin;wpd;
  x-wri;wri;
  x-wwf;wwf;
  x-x509-ca-cert;crt,der,cer,cert,pem;base64
  x-x509-user-cert;crt;
  x-xaml+xml;xaml;
  x-xbel;xbel;
  x-xcf;xcf;
  x-xfig;fig;
  x-xliff+xml;xlf;
  x-xliff;xlf,xliff;
  x-xpinstall;xpi;
  x-xproc+xml;xpl;
  x-xspf+xml;xspf;
  x-xz-compressed-tar;txz;
  x-xz;xz;
  x-yaml;yaml,yml;
  x-zip-compressed;zip;
  x-zmachine;z1,z2,z3,z4,z5,z6,z7,z8;
  x-zoo;zoo;
  
  456:application:I:
  1d-interleaved-parityfec;;
  3gpdash-qoe-report+xml;;
  3gpp-ims+xml;;
  activemessage;;
  alto-costmap+json;;
  alto-costmapfilter+json;;
  alto-directory+json;;
  alto-endpointcost+json;;
  alto-endpointcostparams+json;;
  alto-endpointprop+json;;
  alto-endpointpropparams+json;;
  alto-error+json;;
  alto-networkmap+json;;
  alto-networkmapfilter+json;;
  applefile;;base64
  atomicmail;;
  batch-smtp;;
  beep+xml;;
  calendar+json;;
  call-completion;;
  cals-1840;;
  cdni;;
  cfw;;
  cnrp+xml;;
  coap-payload;;
  csta+xml;;
  cstadata+xml;;
  cybercash;;
  dca-rft;;
  dec-dx;;
  diff.txt;;
  dns;;
  edi-consent;;
  edi-x12;;
  edifact;;
  emergencycalldata.ecall.msd;;
  encaprtp;;
  eshop;;
  example;;
  fastinfoset;;
  fastsoap;;
  font-sfnt - deprecated in favor of font/sfnt;;
  font-sfnt;;
  font-woff - deprecated in favor of font/woff;;
  framework-attributes+xml;;
  geo+json-seq;;
  geoxacml+xml;;
  h224;;
  http;;
  ibe-key-request+xml;;
  ibe-pkg-reply+xml;;
  ibe-pp-data;;
  im-iscomposing+xml;;
  index-obj;;
  index.cmd;;
  index.obj;;
  index.response;;
  index.vnd;;
  index;;
  iotp;;
  ipp;;
  isup;;
  jose+json;;
  jose;;
  json-seq;;
  jwk+json;;
  jwk-set+json;;
  jwt;;
  kpml-request+xml;;
  kpml-response+xml;;
  macwriteii;;
  mathematica-old;;
  mathml-content+xml;;
  mathml-presentation+xml;;
  mbms-associated-procedure-description+xml;;
  mbms-deregister+xml;;
  mbms-envelope+xml;;
  mbms-msk+xml;;
  mbms-msk-response+xml;;
  mbms-protection-description+xml;;
  mbms-reception-report+xml;;
  mbms-register+xml;;
  mbms-register-response+xml;;
  mbms-schedule+xml;;
  mbms-user-service-description+xml;;
  media_control+xml;;
  merge-patch+json;;
  mikey;;
  moss-keys;;
  moss-signature;;
  mosskey-data;;
  mosskey-request;;
  mpeg4-generic;;
  msc-ivr+xml;;
  msc-mixer+xml;;
  mud+json (temporary - registered 2016-11-17, extension registered 2017-10-02, expires 2018-11-17);;
  mud+json;;
  nasdata;;
  news-checkgroups;;
  news-groupinfo;;
  news-transmission;;
  nlsml+xml;;
  nss;;
  parityfec;;
  passport;;
  pidf+xml;;
  poc-settings+xml;;
  ppsp-tracker+json;;
  problem+json;;
  problem+xml;;
  prs.alvestrand.titrax-sheet;;
  prs.plucker;;
  qsig;;
  raptorfec;;
  rdap+json;;
  remote-printing;;
  reputon+json;;
  riscos;;
  rlmi+xml;;
  rpki-publication;;
  rpki-updown;;
  rtploopback;;
  rtx;;
  samlassertion+xml;;
  samlmetadata+xml;;
  scaip+xml;;
  sep+xml;;
  sep-exi;;
  session-info;;
  set-payment;;
  set-registration;;
  sgml;;
  simple-message-summary;;
  simplesymbolcontainer;;
  slate;;
  smpte336m;;
  soap+fastinfoset;;
  soap+xml;;
  spirits-event+xml;;
  timestamp-query;;
  timestamp-reply;;
  tnauthlist;;
  tve-trigger;;
  ulpfec;;
  vcard+json;;
  vemmi;;
  vnd-fdf;;
  vnd-mif;;
  vnd-sema;;
  vnd.3gpp-prose+xml;;
  vnd.3gpp-prose-pc3ch+xml;;
  vnd.3gpp-v2x-local-service-information;;
  vnd.3gpp.access-transfer-events+xml;;
  vnd.3gpp.bsf+xml;;
  vnd.3gpp.gmop+xml;;
  vnd.3gpp.mcptt-affiliation-command+xml;;
  vnd.3gpp.mcptt-floor-request+xml;;
  vnd.3gpp.mcptt-info+xml;;
  vnd.3gpp.mcptt-location-info+xml;;
  vnd.3gpp.mcptt-mbms-usage-info+xml;;
  vnd.3gpp.mcptt-signed+xml;;
  vnd.3gpp.mid-call+xml;;
  vnd.3gpp.sms+xml;;
  vnd.3gpp.srvcc-ext+xml;;
  vnd.3gpp.srvcc-info+xml;;
  vnd.3gpp.state-and-event-info+xml;;
  vnd.3gpp.ussd+xml;;
  vnd.3gpp2.bcmcsinfo+xml;;
  vnd.adobe.partial-upload;;
  vnd.aether.imp;;
  vnd.ah-barcode;;
  vnd.apache.thrift.binary;;
  vnd.apache.thrift.compact;;
  vnd.apache.thrift.json;;
  vnd.artsquare;;
  vnd.bbf.usp.msg+json;;
  vnd.bbf.usp.msg;;
  vnd.bint.med-content;;
  vnd.blink-idb-value-wrapper;;
  vnd.cab-jscript;;
  vnd.canon-cpdl;;
  vnd.canon-lips;;
  vnd.century-systems.tcp_stream;;
  vnd.cirpack.isdn-ext;;
  vnd.comsocaller;;
  vnd.ctct.ws+xml;;
  vnd.cups-pdf;;
  vnd.cups-postscript;;
  vnd.cups-raster;;
  vnd.cups-raw;;
  vnd.cybank;;
  vnd.d2l.coursepackage1p0+zip;;
  vnd.desmume.movie;;
  vnd.dir-bi.plate-dl-nosuffix;;
  vnd.dm.delegation+xml;;
  vnd.dolby.mobile.1;;
  vnd.dolby.mobile.2;;
  vnd.dtg.local.html;;
  vnd.dtg.local;;
  vnd.dvb.esgcontainer;;
  vnd.dvb.ipdcdftnotifaccess;;
  vnd.dvb.ipdcesgaccess2;;
  vnd.dvb.ipdcesgaccess;;
  vnd.dvb.ipdcesgpdd;;
  vnd.dvb.ipdcroaming;;
  vnd.dvb.iptv.alfec-base;;
  vnd.dvb.iptv.alfec-enhancement;;
  vnd.dvb.notif-aggregate-root+xml;;
  vnd.dvb.notif-container+xml;;
  vnd.dvb.notif-generic+xml;;
  vnd.dvb.notif-ia-msglist+xml;;
  vnd.dvb.notif-ia-registration-request+xml;;
  vnd.dvb.notif-ia-registration-response+xml;;
  vnd.dvb.notif-init+xml;;
  vnd.dxr;;
  vnd.ecdis-update;;
  vnd.ecip.rlp;;
  vnd.ecowin.filerequest;;
  vnd.ecowin.fileupdate;;
  vnd.ecowin.series;;
  vnd.ecowin.seriesrequest;;
  vnd.ecowin.seriesupdate;;
  vnd.efi.img;;
  vnd.efi.iso;;
  vnd.emclient.accessrequest+xml;;
  vnd.enphase.envoy;;
  vnd.etsi.aoc+xml;;
  vnd.etsi.cug+xml;;
  vnd.etsi.iptvcommand+xml;;
  vnd.etsi.iptvdiscovery+xml;;
  vnd.etsi.iptvprofile+xml;;
  vnd.etsi.iptvsad-bc+xml;;
  vnd.etsi.iptvsad-cod+xml;;
  vnd.etsi.iptvsad-npvr+xml;;
  vnd.etsi.iptvservice+xml;;
  vnd.etsi.iptvsync+xml;;
  vnd.etsi.iptvueprofile+xml;;
  vnd.etsi.mcid+xml;;
  vnd.etsi.mheg5;;
  vnd.etsi.overload-control-policy-dataset+xml;;
  vnd.etsi.sci+xml;;
  vnd.etsi.simservs+xml;;
  vnd.etsi.tsl+xml;;
  vnd.etsi.tsl.der;;
  vnd.eudora.data;;
  vnd.f-secure.mobile;;
  vnd.ffsns;;
  vnd.firemonkeys.cloudcell;;
  vnd.fujixerox.art-ex;;
  vnd.fujixerox.art4;;
  vnd.fujixerox.hbpl;;
  vnd.fut-misnet;;
  vnd.globalplatform.card-content-mgt-response;;
  vnd.globalplatform.card-content-mgt;;
  vnd.gmx - deprecated;;
  vnd.gridmp;;
  vnd.httphone;;
  vnd.ibm.afplinedata;;
  vnd.innopath.wamp.notification;;
  vnd.intertrust.digibox;;
  vnd.intertrust.nncp;;
  vnd.japanet-registration-wakeup;;
  vnd.japannet-directory-service;;
  vnd.japannet-jpnstore-wakeup;;
  vnd.japannet-payment-wakeup;;
  vnd.japannet-registration-wakeup;;
  vnd.japannet-registration;;
  vnd.japannet-setstore-wakeup;;
  vnd.japannet-verification-wakeup;;
  vnd.japannet-verification;;
  vnd.jsk.isdn-ngn;;
  vnd.liberty-request+xml;;
  vnd.marlin.drm.actiontoken+xml;;
  vnd.marlin.drm.conftoken+xml;;
  vnd.marlin.drm.license+xml;;
  vnd.meridian-slingshot;;
  vnd.microsoft.windows.thumbnail-cache;;
  vnd.minisoft-hp3000-save;;
  vnd.motorola.flexsuite.adsi;;
  vnd.motorola.flexsuite.fis;;
  vnd.motorola.flexsuite.gotap;;
  vnd.motorola.flexsuite.kmr;;
  vnd.motorola.flexsuite.ttc;;
  vnd.motorola.flexsuite.wem;;
  vnd.motorola.flexsuite;;
  vnd.motorola.iprm;;
  vnd.ms-color.iccprofile;;
  vnd.ms-office.activex+xml;;
  vnd.ms-opentype;;
  vnd.ms-package.obfuscated-opentype;;
  vnd.ms-playready.initiator+xml;;
  vnd.ms-printdevicecapabilities+xml;;
  vnd.ms-printing.printticket+xml;;
  vnd.ms-printschematicket+xml;;
  vnd.ms-windows.devicepairing;;
  vnd.ms-windows.nwprinting.oob;;
  vnd.ms-windows.printerpairing;;
  vnd.ms-windows.wsd.oob;;
  vnd.ms-wmdrm.lic-chlg-req;;
  vnd.ms-wmdrm.lic-resp;;
  vnd.ms-wmdrm.meter-chlg-req;;
  vnd.ms-wmdrm.meter-resp;;
  vnd.msign;;
  vnd.music-niff;;
  vnd.ncd.control;;
  vnd.ncd.reference;;
  vnd.nokia.catalogs;;
  vnd.nokia.conml+wbxml;;
  vnd.nokia.conml+xml;;
  vnd.nokia.iptv.config+xml;;
  vnd.nokia.isds-radio-presets;;
  vnd.nokia.landmark+wbxml;;
  vnd.nokia.landmark+xml;;
  vnd.nokia.landmarkcollection+xml;;
  vnd.nokia.ncd;;
  vnd.nokia.pcd+wbxml;;
  vnd.nokia.pcd+xml;;
  vnd.ntt-local.content-share;;
  vnd.ntt-local.file-transfer;;
  vnd.ntt-local.ogw_remote-access;;
  vnd.ntt-local.sip-ta_remote;;
  vnd.ntt-local.sip-ta_tcp_stream;;
  vnd.obn;;
  vnd.ocf+cbor;;
  vnd.oipf.contentaccessdownload+xml;;
  vnd.oipf.contentaccessstreaming+xml;;
  vnd.oipf.cspg-hexbinary;;
  vnd.oipf.dae.svg+xml;;
  vnd.oipf.dae.xhtml+xml;;
  vnd.oipf.mippvcontrolmessage+xml;;
  vnd.oipf.pae.gem;;
  vnd.oipf.spdiscovery+xml;;
  vnd.oipf.spdlist+xml;;
  vnd.oipf.ueprofile+xml;;
  vnd.oipf.userprofile+xml;;
  vnd.oma-scws-config;;
  vnd.oma-scws-http-request;;
  vnd.oma-scws-http-response;;
  vnd.oma.bcast.associated-procedure-parameter+xml;;
  vnd.oma.bcast.drm-trigger+xml;;
  vnd.oma.bcast.imd+xml;;
  vnd.oma.bcast.ltkm;;
  vnd.oma.bcast.notification+xml;;
  vnd.oma.bcast.provisioningtrigger;;
  vnd.oma.bcast.sgboot;;
  vnd.oma.bcast.sgdd+xml;;
  vnd.oma.bcast.sgdu;;
  vnd.oma.bcast.simple-symbol-container;;
  vnd.oma.bcast.smartcard-trigger+xml;;
  vnd.oma.bcast.sprov+xml;;
  vnd.oma.bcast.stkm;;
  vnd.oma.cab-address-book+xml;;
  vnd.oma.cab-feature-handler+xml;;
  vnd.oma.cab-pcc+xml;;
  vnd.oma.cab-subs-invite+xml;;
  vnd.oma.cab-user-prefs+xml;;
  vnd.oma.dcd;;
  vnd.oma.dcdc;;
  vnd.oma.drm.risd+xml;;
  vnd.oma.group-usage-list+xml;;
  vnd.oma.lwm2m+json;;
  vnd.oma.lwm2m+tlv;;
  vnd.oma.pal+xml;;
  vnd.oma.poc.detailed-progress-report+xml;;
  vnd.oma.poc.final-report+xml;;
  vnd.oma.poc.groups+xml;;
  vnd.oma.poc.invocation-descriptor+xml;;
  vnd.oma.poc.optimized-progress-report+xml;;
  vnd.oma.push;;
  vnd.oma.scidm.messages+xml;;
  vnd.oma.xcap-directory+xml;;
  vnd.omads-email+xml;;
  vnd.omads-file+xml;;
  vnd.omads-folder+xml;;
  vnd.omaloc-supl-init;;
  vnd.openxmlformats-officedocument.vmldrawing;;
  vnd.orange.indata;;
  vnd.osa.netdeploy;;
  vnd.otps.ct-kip+xml;;
  vnd.pagerduty+json;;
  vnd.paos+xml;;
  vnd.paos.xml;;
  vnd.pcos;;
  vnd.poc.group-advertisement+xml;;
  vnd.pwg-multiplexed;;
  vnd.pwg-xmhtml-print+xml;;
  vnd.quarantainenet;;
  vnd.radisys.moml+xml;;
  vnd.radisys.msml+xml;;
  vnd.radisys.msml-audit+xml;;
  vnd.radisys.msml-audit-conf+xml;;
  vnd.radisys.msml-audit-conn+xml;;
  vnd.radisys.msml-audit-dialog+xml;;
  vnd.radisys.msml-audit-stream+xml;;
  vnd.radisys.msml-conf+xml;;
  vnd.radisys.msml-dialog+xml;;
  vnd.radisys.msml-dialog-base+xml;;
  vnd.radisys.msml-dialog-fax-detect+xml;;
  vnd.radisys.msml-dialog-fax-sendrecv+xml;;
  vnd.radisys.msml-dialog-group+xml;;
  vnd.radisys.msml-dialog-speech+xml;;
  vnd.radisys.msml-dialog-transform+xml;;
  vnd.rapid;;
  vnd.renlearn.rlprint;;
  vnd.ruckus.download;;
  vnd.s3sms;;
  vnd.sbm.cid;;
  vnd.sbm.mid2;;
  vnd.sealed.net;;
  vnd.sealed.tiff;;
  vnd.sss-cod;;
  vnd.sss-dtf;;
  vnd.street-stream;;
  vnd.swiftview-ics;;
  vnd.syncml.dm.notification;;
  vnd.syncml.dmtnds+wbxml;;
  vnd.syncml.dmtnds+xml;;
  vnd.syncml.ds.notification;;
  vnd.tri.onesource;;
  vnd.truedoc;;
  vnd.tve-trigger;;
  vnd.uplanet.alert-wbxml;;
  vnd.uplanet.alert;;
  vnd.uplanet.bearer-choice-wbxml;;
  vnd.uplanet.bearer-choice;;
  vnd.uplanet.cacheop-wbxml;;
  vnd.uplanet.cacheop;;
  vnd.uplanet.channel-wbxml;;
  vnd.uplanet.channel;;
  vnd.uplanet.list-wbxml;;
  vnd.uplanet.list;;
  vnd.uplanet.listcmd-wbxml;;
  vnd.uplanet.listcmd;;
  vnd.uplanet.signal;;
  vnd.verimatrix.vcas;;
  vnd.windows.devicepairing;;
  vnd.wmf.bootstrap;;
  vnd.wrq-hp3000-labelled;;
  vnd.wv.csp+xml;;8bit
  vnd.wv.ssp+xml;;8bit
  vnd.xfdl.webform;;
  vnd.xmi+xml;;
  vnd.yamaha.remote-setup;;
  vnd.yamaha.through-ngn;;
  vnd.yamaha.tunnel-udpencap;;
  vq-rtcpxr;;
  whoispp-query;;
  whoispp-response;;
  wita;;
  x400-bp;;
  xacml+xml;;
  xmpp+xml;;
  yang-data+json;;
  yang-data+xml;;
  yang-patch+json;;
  yang-patch+xml;;
  
  908:application:I:E
  a2l;a2l;
  aml;aml;
  andrew-inset;ez;
  atf;atf;
  atfx;atfx;
  atom+xml;atom;8bit
  atomcat+xml;atomcat;
  atomdeleted+xml;atomdeleted;
  atomsvc+xml;atomsvc;
  atxml;atxml;
  auth-policy+xml;apxml;
  bacnet-xdd+zip;xdd;
  calendar+xml;xcs;
  cbor;cbor;
  cccex;c3ex;
  ccmp+xml;ccmp;
  ccxml+xml;ccxml;
  cdfx+xml;cdfx;
  cdmi-capability;cdmia;
  cdmi-container;cdmic;
  cdmi-domain;cdmid;
  cdmi-object;cdmio;
  cdmi-queue;cdmiq;
  cea-2018+xml;xml;
  cea;cea;
  cellml+xml;cellml;
  clue_info+xml;clue;
  cms;cmsc;
  coap-group+json;json;
  commonground;dp;
  conference-info+xml;xml;
  cose-key-set;cbor;
  cose-key;cbor;
  cose;cbor;
  cpl+xml;cpl,xml;
  csrattrs;csrattrs;
  csvm+json;json;
  dash+xml;mpd,mdp;
  dashdelta;mpdd;
  davmount+xml;davmount;
  dcd;dcd;
  dialog-info+xml;xml;
  dicom+json;json;
  dicom+xml;xml;
  dicom;dcm;
  dii;dii;
  dit;dit;
  dskpp+xml;xmls;
  dssc+der;dssc;
  dssc+xml;xdssc;
  dvcs;dvc;
  ecmascript;es,ecma,js;
  efi;efi;
  emergencycalldata.comment+xml;xml;
  emergencycalldata.control+xml;xml;
  emergencycalldata.deviceinfo+xml;xml;
  emergencycalldata.providerinfo+xml;xml;
  emergencycalldata.serviceinfo+xml;xml;
  emergencycalldata.subscriberinfo+xml;xml;
  emergencycalldata.veds+xml;xml;
  emma+xml;emma;
  emotionml+xml;emotionml;
  epp+xml;xml;
  epub+zip;epub;
  exi;exi;
  fdt+xml;fdt;
  fits;fits;
  font-tdpfr;PFR;
  font-woff;woff;
  geo+json;json,geojson;
  gml+xml;xml,gml;
  gzip;gz;
  held+xml;heldxml;
  hyperstudio;stk;
  iges;iges,igs;
  inkml+xml;inkml+xml,ink,inkml;
  ipfix;ipfix;
  its+xml;its;
  javascript;js,jsm;8bit
  jf2feed+json;json;
  jrd+json;jrd;
  json-patch+json;json-patch;
  json;json,map;8bit
  ld+json;jsonld;
  lgr+xml;lgr;
  link-format;wlnk;
  load-control+xml;xml;
  lost+xml;lostxml;
  lostsync+xml;lostsyncxml;
  lxf;lxf;
  mac-binhex40;hqx;8bit
  mads+xml;mads;
  marc;mrc;
  marcxml+xml;mrcx;
  mathematica;nb,ma,mb,nbp;
  mathml+xml;mathml,mml;
  mbox;mbox;
  media-policy-dataset+xml;mpf,xml;
  mediaservercontrol+xml;mscml;
  metalink4+xml;meta4;
  mets+xml;mets;
  mf4;mf4;
  mmt-usd+xml;musd;
  mods+xml;mods;
  mp21;mp21,m21;
  mp4;mpg4,mp4,mp4s,m4p;
  mpeg4-iod-xmt;mpg4,mp4;
  mpeg4-iod;mpg4,mp4;
  mrb-consumer+xml;xdf;
  mrb-publish+xml;xdf;
  msword;doc,dot,w6w,wiz,word;
  mxf;mxf;
  n-quads;nq;
  n-triples;nt;
  node;js;
  ocsp-request;ORQ;
  ocsp-response;ORS;
  octet-stream;lrf,mar,bpk,dump,deploy,lhx,saveme,buffer;base64
  oda;oda;
  odx;odx;
  oebps-package+xml;opf;
  ogg;ogx;
  oxps;oxps,xps;
  p2p-overlay+xml;relo;
  patch-ops-error+xml;xer;
  pdf;pdf;base64
  pdx;pdx;
  pgp-encrypted;pgp,gpg,asc;7bit
  pgp-keys;key,skr,pkr,asc,pgp,gpg;7bit
  pgp-signature;asc,sig,pgp,gpg;base64
  pidf-diff+xml;xml;
  pkcs10;p10;
  pkcs12;p12,pfx;
  pkcs7-mime;p7m,p7c;
  pkcs7-signature;p7s;
  pkcs8-encrypted;p8e;
  pkcs8;p8;
  pkix-attr-cert;ac;
  pkix-cert;CER,crt;
  pkix-crl;CRL;
  pkix-pkipath;pkipath;
  pkixcmp;PKI;
  pls+xml;pls;
  postscript;ps-z,ps,ai,eps,epsi,epsf,eps2,eps3;base64
  provenance+xml;provx;
  prs.cww;cw,cww;
  prs.hpub+zip;HPUB;
  prs.nprend;rnd,rct;
  prs.rdf-xml-crypt;rdf-crypt;
  prs.xsf+xml;xsf,xml;
  pskc+xml;pskcxml;
  rdf+xml;rdf,rdfs,owl;8bit
  reginfo+xml;rif,xml;
  relax-ng-compact-syntax;rnc;
  resource-lists+xml;rl;
  resource-lists-diff+xml;rld;
  rfc+xml;xml,rfcxml;
  rls-services+xml;rs;
  route-apd+xml;rapd;
  route-s-tsid+xml;sls;
  route-usd+xml;rusd;
  rpki-ghostbusters;gbr;
  rpki-manifest;mft;
  rpki-roa;roa;
  rtf;rtf,rtx;8bit
  sbml+xml;sbml;
  scim+json;scim,scm;
  scvp-cv-request;SCQ;
  scvp-cv-response;SCS;
  scvp-vp-request;SPQ;
  scvp-vp-response;SPP;
  sdp;sdp;
  set-payment-initiation;setpay;
  set-registration-initiation;setreg;
  sgml-open-catalog;soc;
  shf+xml;shf;
  sieve;siv,sieve;
  simple-filter+xml;cl,xml;
  smil+xml;smi,smil,sml,kino;
  smil;smil,smi,sml;8bit
  sparql-query;rq;
  sparql-results+xml;srx;
  sql;sql;
  srgs+xml;grxml;
  srgs;gram;
  sru+xml;sru;
  ssml+xml;ssml;
  tamp-apex-update-confirm;auc;
  tamp-apex-update;tau;
  tamp-community-update-confirm;cuc;
  tamp-community-update;tcu;
  tamp-error;ter;
  tamp-sequence-adjust-confirm;sac;
  tamp-sequence-adjust;tsa;
  tamp-status-query;tsq;
  tamp-status-response;tsr;
  tamp-update-confirm;tuc;
  tamp-update;tur;
  tei+xml;tei,teicorpus;
  thraud+xml;tfi;
  timestamped-data;tsd;
  trig;trig;
  ttml+xml;ttml;
  urc-grpsheet+xml;gsheet;
  urc-ressheet+xml;rsheet;
  urc-targetdesc+xml;td;
  urc-uisocketdesc+xml;uis;
  vcard+xml;xml;
  vividence.scriptfile;vsf,vtd,vd;
  vnd-acucobol;acu;
  vnd-curl;curl;
  vnd-dart;dart;
  vnd-dxr;dxr;
  vnd-wap-wmlc;wmlc,wbxml;
  vnd.1000minds.decision-model+xml;1km;
  vnd.3gpp.pic-bw-large;plb;
  vnd.3gpp.pic-bw-small;psb;
  vnd.3gpp.pic-bw-var;pvb;
  vnd.3gpp.sms;sms;
  vnd.3gpp2.sms;sms;
  vnd.3gpp2.tcap;tcap;
  vnd.3lightssoftware.imagescal;imgcal;
  vnd.3m.post-it-notes;pwn;
  vnd.accpac.simply.aso;aso;
  vnd.accpac.simply.imp;imp;
  vnd.acucobol;acu;
  vnd.acucorp;atc,acutc;7bit
  vnd.adobe.air-application-installer-package+zip;air;
  vnd.adobe.flash-movie;swf;
  vnd.adobe.flash.movie;swf,spl;
  vnd.adobe.formscentral.fcdt;fcdt;
  vnd.adobe.fxp;fxp,fxpl;
  vnd.adobe.xdp+xml;xdp;
  vnd.adobe.xfdf;xfdf;
  vnd.ahead.space;ahead;
  vnd.airzip.filesecure.azf;azf;
  vnd.airzip.filesecure.azs;azs;
  vnd.amadeus+json;json;
  vnd.amazon.ebook;azw;
  vnd.amazon.mobi8-ebook;azw3;
  vnd.americandynamics.acc;acc;
  vnd.amiga.ami;ami;
  vnd.amiga.amu;ami;
  vnd.amundsen.maze+xml;xml;
  vnd.android.package-archive;apk;
  vnd.anki;apkg;
  vnd.anser-web-certificate-issue-initiation;cii;
  vnd.anser-web-funds-transfer-initiation;fti;
  vnd.antix.game-component;atx;
  vnd.api+json;json;
  vnd.apothekende.reservation+json;json;
  vnd.apple.installer+xml;dist,distz,pkg,mpkg;
  vnd.apple.mpegurl;m3u8,m3u;
  vnd.arastra.swi;swi;
  vnd.aristanetworks.swi;swi;
  vnd.astraea-software.iota;iota;
  vnd.audiograph;aep;
  vnd.autopackage;package;
  vnd.avalon+json;json;
  vnd.avistar+xml;xml;
  vnd.balsamiq.bmml+xml;bmml;
  vnd.balsamiq.bmpr;bmpr;
  vnd.bekitzur-stech+json;json;
  vnd.biopax.rdf+xml;owl,rdf;
  vnd.blueice.multipass;mpm;
  vnd.bluetooth.ep.oob;EP;
  vnd.bluetooth.le.oob;LE;
  vnd.bmi;BMI;
  vnd.businessobjects;rep;
  vnd.capasystems-pg+json;json;
  vnd.cendio.thinlinc.clientconf;tlclient;
  vnd.chemdraw+xml;cdxml;
  vnd.chess-pgn;pgn;
  vnd.chipnuts.karaoke-mmd;mmd;
  vnd.cinderella;cdy;
  vnd.citationstyles.style+xml;csl;
  vnd.claymore;cla;
  vnd.cloanto.rp9;rp9;
  vnd.clonk.c4group;c4g,c4d,c4f,c4p,c4u;
  vnd.cluetrust.cartomobile-config-pkg;c11amz;
  vnd.cluetrust.cartomobile-config;c11amc;
  vnd.coffeescript;coffee;
  vnd.collabio.xodocuments.document-template;xott;
  vnd.collabio.xodocuments.document;xodt;
  vnd.collabio.xodocuments.presentation-template;xotp;
  vnd.collabio.xodocuments.presentation;xodp;
  vnd.collabio.xodocuments.spreadsheet-template;xots;
  vnd.collabio.xodocuments.spreadsheet;xods;
  vnd.collection+json;json;
  vnd.collection.doc+json;json;
  vnd.collection.next+json;json;
  vnd.comicbook+zip;cbz;
  vnd.comicbook-rar;cbr;
  vnd.commerce-battelle;ica,icf,icd,icc,ic1;
  vnd.commonspace;csp,cst;
  vnd.contact.cmsg;cdbcmsg;
  vnd.corel-draw;cdr;
  vnd.coreos.ignition+json;ign,ignition;
  vnd.cosmocaller;cmc;
  vnd.crick.clicker.keyboard;clkk;
  vnd.crick.clicker.palette;clkp;
  vnd.crick.clicker.template;clkt;
  vnd.crick.clicker.wordbank;clkw;
  vnd.crick.clicker;clkx;
  vnd.criticaltools.wbs+xml;wbs;
  vnd.ctc-posml;pml;
  vnd.cups-ppd;ppd,gz;
  vnd.curl.car;car;
  vnd.curl.pcurl;pcurl;
  vnd.curl;curl;
  vnd.cyan.dean.root+xml;xml;
  vnd.dart;dart;
  vnd.data-vision.rdz;rdz;
  vnd.datapackage+json;json;
  vnd.dataresource+json;json;
  vnd.debian.binary-package;deb,udeb;
  vnd.dece-zip;uvz,uvvz;
  vnd.dece.data;uvf,uvvf,uvd,uvvd;
  vnd.dece.ttml+xml;uvt,uvvt;
  vnd.dece.unspecified;uvx,uvvx;
  vnd.dece.zip;uvz,uvvz;
  vnd.denovo.fcselayout-link;fe_launch;
  vnd.desmume-movie;dsm;
  vnd.dna;dna;
  vnd.document+json;docjson;
  vnd.dolby.mlp;mlp;
  vnd.doremir.scorecloud-binary-document;scld;
  vnd.dpgraph;dpg,mwc,dpgraph;
  vnd.dreamfactory;dfac;
  vnd.drive+json;json;
  vnd.ds-keypoint;kpxx;
  vnd.dtg.local-html;html;
  vnd.dtg.local.flash;fla;
  vnd.dvb.ait;AIT;
  vnd.dvb.dvbj;class;
  vnd.dvb.pfr;pfr;
  vnd.dvb.service;svc;
  vnd.dvb_service;svc;
  vnd.dynageo;geo;
  vnd.dzr;dzr;
  vnd.easykaraoke.cdgdownload;zip;
  vnd.ecowin.chart;mag;
  vnd.efi-img;img;
  vnd.efi-iso;iso;
  vnd.emusic-emusic_package;emp;
  vnd.enliven;nml;
  vnd.eprints.data+xml;xml;
  vnd.epson.esf;esf;
  vnd.epson.msf;msf;
  vnd.epson.quickanime;qam;
  vnd.epson.salt;slt;
  vnd.epson.ssf;ssf;
  vnd.ericsson.quickcall;qcall,qca;
  vnd.espass-espass+zip;espass;
  vnd.eszigno3+xml;es3,et3;
  vnd.etsi.asic-e+zip;asice,or,sce;
  vnd.etsi.asic-s+zip;asics,or,scs;
  vnd.etsi.pstn+xml;xml;
  vnd.etsi.timestamp-token;tst;
  vnd.evolv.ecig.profile;ecigprofile;
  vnd.evolv.ecig.settings;ecig;
  vnd.evolv.ecig.theme;ecigtheme;
  vnd.ezpix-album;ez2;
  vnd.ezpix-package;ez3;
  vnd.fastcopy-disk-image;dim;
  vnd.fdf;fdf;
  vnd.fdsn.mseed;msd,mseed,seed,dataless;
  vnd.fdsn.seed;seed,dataless;
  vnd.filmit.zfc;zfc;
  vnd.fints;hbci,hbc,kom,upa,pkd,bpd;
  vnd.flographit;gph;
  vnd.fluxtime.clip;FTC;
  vnd.font-fontforge-sfd;sfd;
  vnd.framemaker;fm,frame,maker,book;
  vnd.frogans.fnc;FNC;
  vnd.frogans.ltf;LTF;
  vnd.fsc.weblauch;fsc;7bit
  vnd.fsc.weblaunch;fsc;
  vnd.fujitsu.oasys2;oa2;
  vnd.fujitsu.oasys3;oa3;
  vnd.fujitsu.oasys;oas;
  vnd.fujitsu.oasysgp;fg5;
  vnd.fujitsu.oasysprs;bh2;
  vnd.fujixerox.ddd;ddd;
  vnd.fujixerox.docuworks.binder;xbd;
  vnd.fujixerox.docuworks.container;xct;
  vnd.fujixerox.docuworks;xdw;
  vnd.fuzzysheet;fzs;
  vnd.genomatix.tuxedo;txd;
  vnd.geo+json;json,geojson;
  vnd.geocube+xml;g3;
  vnd.geogebra.file;ggb;
  vnd.geogebra.tool;ggt;
  vnd.geometry-explorer;gex,gre;
  vnd.geonext;gxt;
  vnd.geoplan;g2w;
  vnd.geospace;g3w;
  vnd.gerber;gbr;
  vnd.gmx;gmx;
  vnd.google-earth.kml+xml;kml;8bit
  vnd.google-earth.kmz;kmz;8bit
  vnd.gov.sk.e-form+xml;xml;
  vnd.gov.sk.e-form+zip;zip;
  vnd.gov.sk.xmldatacontainer+xml;xml;
  vnd.grafeq;gqf,gqs;
  vnd.groove-account;gac;
  vnd.groove-help;ghf;
  vnd.groove-identity-message;gim;
  vnd.groove-injector;grv;
  vnd.groove-tool-message;gtm;
  vnd.groove-tool-template;tpl;
  vnd.groove-vcard;vcg;
  vnd.hal+json;json;
  vnd.hal+xml;hal;
  vnd.handheld-entertainment+xml;ZMM;
  vnd.hbci;hbci,hbc,kom,upa,pkd,bpd;
  vnd.hc+json;json;
  vnd.hcl-bireports;rep;
  vnd.hdt;hdt;
  vnd.heroku+json;json;
  vnd.hhe.lesson-player;les;
  vnd.hp-hpgl;plt,hpgl,hgl,hpg;
  vnd.hp-hpid;hpi,hpid;
  vnd.hp-hps;hps;
  vnd.hp-jlyt;jlt;
  vnd.hp-pcl;pcl;
  vnd.hp-pclxl;pclxl;
  vnd.hydrostatix.sof-data;sfd-hdstx;
  vnd.hyper-item+json;json;
  vnd.hyperdrive+json;json;
  vnd.hzn-3d-crossword;x3d;
  vnd.ibm.electronic-media;emm;
  vnd.ibm.minipay;mpy;
  vnd.ibm.modcap;list3820,listafp,afp,pseg3820;
  vnd.ibm.rights-management;irm;
  vnd.ibm.secure-container;sc;
  vnd.iccprofile;icc,icm;
  vnd.ieee.1905;1;
  vnd.igloader;igl;
  vnd.imagemeter.folder+zip;imf;
  vnd.imagemeter.image+zip;imi;
  vnd.immervision-ivp;ivp;
  vnd.immervision-ivu;ivu;
  vnd.ims.imsccv1p1;imscc;
  vnd.ims.imsccv1p2;imscc;
  vnd.ims.imsccv1p3;imscc;
  vnd.ims.lis.v2.result+json;jsonld,json;
  vnd.ims.lti.v2.toolconsumerprofile+json;jsonld,json;
  vnd.ims.lti.v2.toolproxy+json;jsonld,json;
  vnd.ims.lti.v2.toolproxy.id+json;jsonld,json;
  vnd.ims.lti.v2.toolsettings+json;jsonld,json;
  vnd.ims.lti.v2.toolsettings.simple+json;jsonld,json;
  vnd.informedcontrol.rms+xml;xml;
  vnd.informix-visionary;vis;
  vnd.infotech.project+xml;XML;
  vnd.infotech.project;json;
  vnd.insors.igm;igm;
  vnd.intercon.formnet;XPW,XPX;
  vnd.intergeo;i2g;
  vnd.intu.qbo;QBO;
  vnd.intu.qfx;QFX;
  vnd.iptc.g2.catalogitem+xml;xml;
  vnd.iptc.g2.conceptitem+xml;xml;
  vnd.iptc.g2.knowledgeitem+xml;xml;
  vnd.iptc.g2.newsitem+xml;xml;
  vnd.iptc.g2.newsmessage+xml;xml;
  vnd.iptc.g2.packageitem+xml;xml;
  vnd.iptc.g2.planningitem+xml;xml;
  vnd.ipunplugged.rcprofile;rcprofile;
  vnd.irepository.package+xml;irp;
  vnd.is-xpr;XPR;
  vnd.isac.fcs;fcs;
  vnd.jam;jam;
  vnd.jcp.javame.midlet-rms;rms;
  vnd.jisp;jisp;
  vnd.joost.joda-archive;joda;
  vnd.kahootz;ktz,ktr;
  vnd.kde.karbon;KARBON;
  vnd.kde.kchart;CHRT;
  vnd.kde.kformula;KFO;
  vnd.kde.kivio;FLW;
  vnd.kde.kontour;KON;
  vnd.kde.kpresenter;KPR,KPT;
  vnd.kde.kspread;KSP;
  vnd.kde.kword;KWT,KWD;
  vnd.kenameaapp;htke;
  vnd.kenameapp;htke;
  vnd.kidspiration;kia;
  vnd.kinar;kne,knp,sdf;
  vnd.koan;skp,skd,skt,skm;
  vnd.kodak-descriptor;SSE;
  vnd.las.las+json;lasjson;
  vnd.las.las+xml;lasxml;
  vnd.llamagraphics.life-balance.desktop;lbd;
  vnd.llamagraphics.life-balance.exchange+xml;lbe;
  vnd.lotus-1-2-3;123,wks,wk1,wk3,wk4;
  vnd.lotus-approach;apr;
  vnd.lotus-freelance;prz,pre;
  vnd.lotus-notes;nsf;
  vnd.lotus-organizer;or3,org;
  vnd.lotus-screencam;scm;
  vnd.lotus-wordpro;lwp;
  vnd.macports.portpkg;portpkg;
  vnd.mapbox-vector-tile;mvt;
  vnd.marlin.drm.mdcf;mdc;
  vnd.mason+json;json;
  vnd.maxmind.maxmind-db;mmdb;
  vnd.mcd;MCD;
  vnd.medcalcdata;MC1;
  vnd.mediastation.cdkey;cdkey;
  vnd.mfer;mwf;
  vnd.mfmp;mfm;
  vnd.micro+json;json;
  vnd.micrografx-igx;igx;
  vnd.micrografx.flo;flo;
  vnd.micrografx.igx;igx;
  vnd.microsoft.portable-executable;exe,dll;
  vnd.miele+json;json;
  vnd.mif;mif;
  vnd.mitsubishi.misty-guard.trustweb;any;
  vnd.mobius.daf;DAF;
  vnd.mobius.dis;DIS;
  vnd.mobius.mbk;MBK;
  vnd.mobius.mqy;MQY;
  vnd.mobius.msl;MSL;
  vnd.mobius.plc;PLC;
  vnd.mobius.txf;TXF;
  vnd.mophun.application;mpn;
  vnd.mophun.certificate;mpc;
  vnd.mozilla.aul+xml;xul;
  vnd.mozilla.xul+xml;xul;
  vnd.ms-3mfdocument;3MF;
  vnd.ms-access;mdb;
  vnd.ms-artgalry;cil;
  vnd.ms-asf;asf;
  vnd.ms-cab-compressed;cab;
  vnd.ms-excel.addin.macroenabled.12;xlam;
  vnd.ms-excel.sheet.binary.macroenabled.12;xlsb;
  vnd.ms-excel.sheet.macroenabled.12;xlsm;
  vnd.ms-excel.template.macroenabled.12;xltm;
  vnd.ms-excel;xls,xlt,xlb,xla,xlm,xlc,xlw,xll,xld;base64
  vnd.ms-fontobject;eot;
  vnd.ms-htmlhelp;chm;
  vnd.ms-ims;ims;
  vnd.ms-lrm;lrm;
  vnd.ms-officetheme;thmx;
  vnd.ms-pki.certstore;sst;
  vnd.ms-pki.pko;pko;
  vnd.ms-pki.seccat;cat;
  vnd.ms-pki.stl;stl;
  vnd.ms-powerpoint.addin.macroenabled.12;ppam;
  vnd.ms-powerpoint.presentation.macroenabled.12;pptm;
  vnd.ms-powerpoint.slide.macroenabled.12;sldm;
  vnd.ms-powerpoint.slideshow.macroenabled.12;ppsm;
  vnd.ms-powerpoint.template.macroenabled.12;potm;
  vnd.ms-powerpoint;ppt,pps,pot,ppa,pwz,ppz;base64
  vnd.ms-project;mpp,mpt;base64
  vnd.ms-publisher;pub;
  vnd.ms-tnef;tnef,tnf;base64
  vnd.ms-word.document.macroenabled.12;docm;
  vnd.ms-word.template.macroenabled.12;dotm;
  vnd.ms-works;wps,wks,wcm,wdb,xlr;base64
  vnd.ms-wpl;wpl;base64
  vnd.ms-xpsdocument;xps;8bit
  vnd.msa-disk-image;msa;
  vnd.mseq;mseq;
  vnd.multiad.creator.cif;cif;
  vnd.multiad.creator;crtr;
  vnd.musician;mus;
  vnd.muvee.style;msty;
  vnd.mynfc;taglet;
  vnd.nearst.inv+json;json;
  vnd.nervana;ent,entity,req,request,bkm,kcm;
  vnd.netfpx;fpx;
  vnd.neurolanguage.nlu;nlu;
  vnd.nintendo.nitro.rom;nds;
  vnd.nintendo.snes.rom;sfc,smc;
  vnd.nitf;ntf,nitf;
  vnd.noblenet-directory;NND;
  vnd.noblenet-sealer;NNS;
  vnd.noblenet-web;NNW;
  vnd.nokia.configuration-message;ncm;
  vnd.nokia.n-gage.ac+xml;ac;
  vnd.nokia.n-gage.data;ngdat;
  vnd.nokia.n-gage.symbian.install;n-gage;
  vnd.nokia.radio-preset;rpst;
  vnd.nokia.radio-presets;rpss;
  vnd.nokia.ringing-tone;rng;
  vnd.novadigm.edm;EDM;
  vnd.novadigm.edx;EDX;
  vnd.novadigm.ext;EXT;
  vnd.oasis.opendocument.chart-template;otc;
  vnd.oasis.opendocument.chart;odc;
  vnd.oasis.opendocument.database;odb;
  vnd.oasis.opendocument.formula-template;otf,odft;
  vnd.oasis.opendocument.formula;odf;
  vnd.oasis.opendocument.graphics-flat-xml;fodg;
  vnd.oasis.opendocument.graphics-template;otg;
  vnd.oasis.opendocument.graphics;odg;
  vnd.oasis.opendocument.image-template;oti;
  vnd.oasis.opendocument.image;odi;
  vnd.oasis.opendocument.presentation-flat-xml;fodp;
  vnd.oasis.opendocument.presentation-template;otp;
  vnd.oasis.opendocument.presentation;odp;
  vnd.oasis.opendocument.spreadsheet-flat-xml;fods;
  vnd.oasis.opendocument.spreadsheet-template;ots;
  vnd.oasis.opendocument.spreadsheet;ods;
  vnd.oasis.opendocument.text-flat-xml;fodt;
  vnd.oasis.opendocument.text-master;odm,otm;
  vnd.oasis.opendocument.text-template;ott;
  vnd.oasis.opendocument.text-web;oth;
  vnd.oasis.opendocument.text;odt;
  vnd.oftn.l10n+json;json;
  vnd.olpc-sugar;xo;
  vnd.oma.dd2+xml;xml,dd2;
  vnd.onepager;tam;
  vnd.onepagertamp;tamp;
  vnd.onepagertamx;tamx;
  vnd.onepagertat;tat;
  vnd.onepagertatp;tatp;
  vnd.onepagertatx;tatx;
  vnd.openblox.game+xml;obgx;
  vnd.openblox.game-binary;obg;
  vnd.openeye.oeb;oeb;
  vnd.openofficeorg.extension;oxt;
  vnd.openstreetmap.data+xml;osm;
  vnd.openxmlformats-officedocument.custom-properties+xml;xml;
  vnd.openxmlformats-officedocument.customxmlproperties+xml;xml;
  vnd.openxmlformats-officedocument.drawing+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.chart+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.chartshapes+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.diagramdata+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml;xml;
  vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml;xml;
  vnd.openxmlformats-officedocument.extended-properties+xml;xml;
  vnd.openxmlformats-officedocument.presentationml-template;potx;
  vnd.openxmlformats-officedocument.presentationml.commentauthors+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.comments+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.notesmaster+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.notesslide+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.presentation.main+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.presentation;pptx;base64
  vnd.openxmlformats-officedocument.presentationml.presprops+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.slide+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.slide;sldx;
  vnd.openxmlformats-officedocument.presentationml.slidelayout+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.slidemaster+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.slideshow;ppsx;base64
  vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.tablestyles+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.tags+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.template.main+xml;xml;
  vnd.openxmlformats-officedocument.presentationml.template;potx;base64
  vnd.openxmlformats-officedocument.presentationml.viewprops+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml-template;xltx;
  vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.comments+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.connections+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.sheet;xltx,xlsx;base64
  vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.styles+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.table+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.template;xltx;base64
  vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml;xml;
  vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml;xml;
  vnd.openxmlformats-officedocument.theme+xml;xml;
  vnd.openxmlformats-officedocument.themeoverride+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml-template;dotx;
  vnd.openxmlformats-officedocument.wordprocessingml.comments+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.document;docx;base64
  vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.footer+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.settings+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.styles+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml;xml;
  vnd.openxmlformats-officedocument.wordprocessingml.template;dotx;base64
  vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml;xml;
  vnd.openxmlformats-package.core-properties+xml;xml;
  vnd.openxmlformats-package.digital-signature-xmlsignature+xml;xml;
  vnd.openxmlformats-package.relationships+xml;xml;
  vnd.oracle.resource+json;json;
  vnd.osgeo.mapguide.package;mgp;
  vnd.osgi.bundle;jar;
  vnd.osgi.dp;dp;
  vnd.osgi.subsystem;esa;
  vnd.oxli.countgraph;oxlicg;
  vnd.palm;prc,pdb,pqa,oprc;
  vnd.panoply;plp;
  vnd.patentdive;dive;
  vnd.pawaafile;paw;
  vnd.pg.format;str;
  vnd.pg.osasli;ei6;
  vnd.piaccess.application-licence;pil;
  vnd.picsel;eFIF;
  vnd.pmi.widget;wg;
  vnd.pocketlearn;plf;
  vnd.powerbuilder6-s;pbd;
  vnd.powerbuilder6;pbd;
  vnd.powerbuilder7-s;pbd;
  vnd.powerbuilder75-s;pbd;
  vnd.powerbuilder75;pbd;
  vnd.powerbuilder7;pbd;
  vnd.preminet;preminet;
  vnd.previewsystems.box;BOX,VBOX;
  vnd.proteus.magazine;mgz;
  vnd.publishare-delta-tree;qps;
  vnd.pvi.ptid1;pti,ptid;
  vnd.pwg-xhtml-print+xml;xhtml,xhtm;
  vnd.qualcomm.brew-app-res;bar;
  vnd.quark.quarkxpress;qxd,qxt,qwd,qwt,qxl,qxb;8bit
  vnd.quobject-quoxdocument;quox,quiz;
  vnd.rainstor.data;tree;
  vnd.rar;rar;
  vnd.realvnc.bed;BED;
  vnd.recordare.musicxml+xml;xml,musicxml;
  vnd.recordare.musicxml;mxl;
  vnd.rig.cryptonote;cryptonote;
  vnd.rim.cod;cod;
  vnd.rn-realmedia-vbr;rmvb;
  vnd.rn-realmedia;rm,rmj,rmm,rms,rmx,rmvb;
  vnd.rn-realplayer;rnx;
  vnd.route66.link66+xml;link66;
  vnd.rs-274x;gbr;
  vnd.sailingtracker.track;st;
  vnd.scribus;scd,gz,sla,slaz;
  vnd.sealed-doc;sdoc,sdo,s1w;
  vnd.sealed-eml;seml,sem;
  vnd.sealed-mht;smht,smh;
  vnd.sealed-ppt;sppt,spp,s1p;
  vnd.sealed-tiff;stif;
  vnd.sealed-xls;sxls,sxl,s1e;
  vnd.sealed.3df;s3df;
  vnd.sealed.csf;scsf;
  vnd.sealed.doc;sdoc,sdo,s1w;
  vnd.sealed.eml;seml,sem;
  vnd.sealed.mht;smht,smh;
  vnd.sealed.ppt;sppt,spp,s1p;
  vnd.sealed.xls;sxls,sxl,s1e;
  vnd.sealedmedia.softseal-html;stml,stm,s1h;
  vnd.sealedmedia.softseal-pdf;spdf,spd,s1a;
  vnd.sealedmedia.softseal.html;stml,stm,s1h;
  vnd.sealedmedia.softseal.pdf;spdf,spd,s1a;
  vnd.seemail;see;
  vnd.sema;sema;
  vnd.semd;semd;
  vnd.semf;semf;
  vnd.shana.informed.formdata;ifm;
  vnd.shana.informed.formtemplate;itp;
  vnd.shana.informed.interchange;iif;
  vnd.shana.informed.package;ipk;
  vnd.sigrok.session;sr;
  vnd.simtech-mindmapper;twd,twds;
  vnd.siren+json;json;
  vnd.smaf;mmf;
  vnd.smart.notebook;notebook;
  vnd.smart.teacher;teacher;
  vnd.software602.filler.form+xml;FO;
  vnd.software602.filler.form-xml-zip;ZFO;
  vnd.solent.sdkm+xml;sdkm,sdkd;
  vnd.spotfire.dxp;dxp;
  vnd.spotfire.sfs;sfs;
  vnd.sss-ntf;disclosed;
  vnd.stardivision.calc;sdc;
  vnd.stardivision.chart;sds;
  vnd.stardivision.draw;sda;
  vnd.stardivision.impress;sdd,sdp;
  vnd.stardivision.mail;smd;
  vnd.stardivision.math;sdf,smf;
  vnd.stardivision.writer-global;sgl;
  vnd.stardivision.writer;sdw,vor,sgl;
  vnd.stepmania.package;smzip;
  vnd.stepmania.stepchart;sm;
  vnd.sun.wadl+xml;wadl;
  vnd.sun.xml.calc.template;stc;
  vnd.sun.xml.calc;sxc;
  vnd.sun.xml.draw.template;std;
  vnd.sun.xml.draw;sxd;
  vnd.sun.xml.impress.template;sti;
  vnd.sun.xml.impress;sxi;
  vnd.sun.xml.math;sxm;
  vnd.sun.xml.writer.global;sxg;
  vnd.sun.xml.writer.template;stw;
  vnd.sun.xml.writer;sxw;
  vnd.sus-calendar;sus,susp;
  vnd.svd;svd;
  vnd.symbian.install;sis,sisx;
  vnd.syncml+xml;XSM;
  vnd.syncml.dm+wbxml;BDM;
  vnd.syncml.dm+xml;XDM;
  vnd.syncml.dmddf+wbxml;ddf;
  vnd.syncml.dmddf+xml;ddf;
  vnd.tableschema+json;json;
  vnd.tao.intent-module-archive;tao;
  vnd.tcpdump.pcap;pcap,cap,dmp;
  vnd.theqvd;qvd;
  vnd.tmd.mediaflex.api+xml;xml;
  vnd.tml;vfr,viaframe;
  vnd.tmobile-livetv;tmo;
  vnd.trid.tpt;tpt;
  vnd.triscape.mxs;mxs;
  vnd.trueapp;tra;
  vnd.ubisoft.webplayer;CAB;
  vnd.ufdl;ufdl,ufd,frm;
  vnd.uiq.theme;UTZ;
  vnd.umajin;umj;
  vnd.unity;unityweb;
  vnd.uoml+xml;uoml,uo;
  vnd.uri-map;urim,urimap;
  vnd.valve.source.material;vmt;
  vnd.vcx;vcx;
  vnd.vd-study;sxi,mxi,study-inter,model-inter;
  vnd.vectorworks;MCD,VWX;
  vnd.vel+json;json;
  vnd.vidsoft.vidconference;vsc;8bit
  vnd.visio;vsd,vst,vsw,vss;
  vnd.visionary;vis;
  vnd.vividence.scriptfile;vsc;
  vnd.vsf;vsf;
  vnd.wap-slc;slc,wbxml;
  vnd.wap-wbxml;wbxml;
  vnd.wap.sic;sic,wbxml;
  vnd.wap.slc;slc;
  vnd.wap.wbxml;wbxml;
  vnd.wap.wmlc;wmlc;
  vnd.wap.wmlscriptc;wmlsc;
  vnd.webturbo;wtb;
  vnd.wfa.p2p;P2P;
  vnd.wfa.wsc;WSC;
  vnd.wmc;wmc;
  vnd.wolfram.mathematica.package;m;
  vnd.wolfram.mathematica;nb;
  vnd.wolfram.player;nbp;
  vnd.wordperfect5.1;wp5;
  vnd.wordperfect;wpd,wp,wp4,wp5,wp6,wpp;
  vnd.wqd;wqd;
  vnd.wt.stf;stf;
  vnd.wv.csp+wbxml;wv;
  vnd.xacml+json;json;
  vnd.xara;XAR,web;
  vnd.xfdl;xfdl,xfd,frm;
  vnd.xmpie.cpkg;cpkg;
  vnd.xmpie.dpkg;dpkg;
  vnd.xmpie.plan;dpkg;
  vnd.xmpie.ppkg;ppkg;
  vnd.xmpie.xlim;xlim;
  vnd.yamaha.hv-dic;hvd;
  vnd.yamaha.hv-script;hvs;
  vnd.yamaha.hv-voice;hvp;
  vnd.yamaha.openscoreformat.osfpvg+xml;xml,osfpvg;
  vnd.yamaha.openscoreformat;osf;
  vnd.yamaha.smaf-audio;saf;
  vnd.yamaha.smaf-phrase;spf;
  vnd.yaoweme;yme;
  vnd.yellowriver-custom-menu;cmp;
  vnd.youtube.yt;yt;
  vnd.zul;zir,zirz;
  vnd.zzazz.deck+xml;zaz;
  voicexml+xml;vxml;
  watcherinfo+xml;wif,xml;
  webpush-options+json;json;
  widget;wgt;
  wordperfect5.1;wp5,wp;
  wsdl+xml;wsdl;
  wspolicy+xml;wspolicy;
  xcap-att+xml;xav;
  xcap-caps+xml;xca;
  xcap-diff+xml;xdf;
  xcap-el+xml;xel;
  xcap-error+xml;xer;
  xcap-ns+xml;xns;
  xcon-conference-info+xml;xml;
  xcon-conference-info-diff+xml;xml;
  xenc+xml;xml,xenc;
  xhtml+xml;xhtml,xht;8bit
  xhtml-voice+xml;mxml,xhvml,xvml,xvm;
  xml-dtd;dtd,mod;8bit
  xml-external-parsed-entity;xml,ent;
  xml-patch+xml;xml;
  xml;xml,xsl,xsd,xpdl,xbl,rng;8bit
  xop+xml;XOP;
  xslt+xml;xslt,xsl;8bit
  xv+xml;mxml,xhvml,xvml,xvm;
  yang;yang;
  yin+xml;yin;
  zip;zip;base64
  zlib;zz;
  
  3:audio::
  x-g.722.1;;
  x-isac;;
  x-riff;;
  
  66:audio::E
  x-aac;aac;
  x-adpcm;adp,snd;
  x-aifc;aifc,aiffc;
  x-aiff;aif,aifc,aiff;base64
  x-amzxml;amz;
  x-annodex;axa;
  x-ape;ape;
  x-au;au;
  x-caf;caf;
  x-flac+ogg;oga,ogg;
  x-flac;flac;
  x-gsm;gsm,gsd;
  x-iriver-pla;pla;
  x-it;it;
  x-jam;jam;
  x-liveaudio;lam;
  x-m4b;m4b,f4b;
  x-make.my.funk;pfunk;
  x-make;funk,my,pfunk;
  x-matroska;mka;
  x-mid;mid,midi,rmi;
  x-midi;mid,midi,kar,rmi;base64
  x-minipsf;minipsf;
  x-mo3;mo3;
  x-mod;mod,ult,uni,m15,mtm,669,med;
  x-mp2;mp2;
  x-mpeg-3;mp3;
  x-mpeg3;mp3;
  x-mpeg;mp2;
  x-mpegurl;m3u,m3u8,vlc;
  x-mpequrl;m3u;
  x-ms-asx;asx,wax,wvx,wmx;
  x-ms-wax;wax;
  x-ms-wma;wma;
  x-musepack;mpc,mpp,mp+;
  x-nspaudio;la,lma;
  x-opus+ogg;opus;
  x-pn-realaudio-plugin;rpm,rmp,ra;
  x-pn-realaudio;rm,ram,ra,rmm,rmp;base64
  x-psf;psf;
  x-psflib;psflib;
  x-psid;sid;
  x-realaudio;ra;base64
  x-s3m;s3m;
  x-scpls;pls;
  x-sd2;sd2;
  x-silk;sil;
  x-speex+ogg;oga,ogg;
  x-speex;spx;
  x-stm;stm;
  x-tsp-audio;tsi;
  x-tsplayer;tsp;
  x-tta;tta;
  x-twinvq-plugin;vqe,vql;
  x-twinvq;vqf;
  x-vnd.audioexplosion.mjuicemediafile;mjf;
  x-voc;voc;
  x-vorbis+ogg;oga,ogg;
  x-voxware;vox;
  x-wav;wav;base64
  x-wavpack-correction;wvc;
  x-wavpack;wv,wvp;
  x-webm;weba;base64
  x-xi;xi;
  x-xm;xm;
  x-xmf;xmf;
  
  101:audio:I:
  1d-interleaved-parityfec;;
  3gpp2;;
  amr-wb+;;
  aptx;;
  asc;;
  bv16;;
  bv32;;
  clearmode;;
  cn;;
  dat12;;
  dsr-es201108;;
  dsr-es202050;;
  dsr-es202211;;
  dsr-es202212;;
  dv;;
  dvi4;;
  eac3;;
  encaprtp;;
  evrc0;;
  evrc1;;
  evrcb0;;
  evrcb1;;
  evrcnw0;;
  evrcnw1;;
  evrcwb0;;
  evrcwb1;;
  example;;
  fwdred;;
  g711-0;;
  g719;;
  g7221;;
  g722;;
  g723;;
  g726-16;;
  g726-24;;
  g726-32;;
  g726-40;;
  g728;;
  g7291;;
  g729;;
  g729d;;
  g729e;;
  gsm-efr;;
  gsm-hr-08;;
  gsm;;
  ip-mr_v2.5;;
  l20;;
  l24;;
  l8;;
  lpc;;
  melp1200;;
  melp2400;;
  melp600;;
  melp;;
  mp4a-latm;;
  mpa-robust;;
  mpa;;
  mpeg4-generic;;
  opus;;
  parityfec;;
  pcma-wb;;
  pcma;;
  pcmu-wb;;
  pcmu;;
  raptorfec;;
  red;;
  rtp-enc-aescm128;;
  rtp-midi;;
  rtploopback;;
  rtx;;
  smv0;;
  speex;;
  t140c;;
  t38;;
  telephone-event;;
  tone;;
  uemclip;;
  ulpfec;;
  vdvi;;
  vmr-wb;;
  vnd.3gpp.iufp;;
  vnd.4sb;;
  vnd.celp;;
  vnd.cisco.nse;;
  vnd.cmles.radio-events;;
  vnd.cns.anp1;;
  vnd.cns.inf1;;
  vnd.dlna.adts;;
  vnd.dolby.heaac.1;;
  vnd.dolby.heaac.2;;
  vnd.dolby.mps;;
  vnd.dolby.pl2;;
  vnd.dolby.pl2x;;
  vnd.dolby.pl2z;;
  vnd.dolby.pulse.1;;
  vnd.octel.sbc;;
  vnd.qcelp - deprecated in favor of audio/qcelp;;
  vnd.rhetorex.32kadpcm;;
  vnd.vmx.cvsd;;
  vorbis-config;;
  vorbis;;
  
  50:audio:I:E
  32kadpcm;726;
  3gpp;3gp,3gpp;
  ac3;ac3;
  amr-wb;awb;base64
  amr;amr;base64
  atrac-advanced-lossless;aal,aa3,and,omg;
  atrac-x;atx,aa3,and,omg;
  atrac3;at3,aa3,and,omg;
  basic;au,snd;base64
  dls;dls;
  evrc-qcp;qcp;
  evrc;evc;
  evrcb;evb;
  evrcnw;enw;
  evrcwb;evw;
  evs;3gp,3gpp;
  ilbc;lbc;
  l16;WAV,L16;
  mobile-xmf;mxmf;
  mp4;mp4,mpg4,f4a,f4b,m4a,mp4a;
  mpeg;mp1,mp2,mp3,mpga,mpega,m4a,mp2a,m2a,m3a,mpa,mpg;base64
  ogg;oga,ogg,spx,opus;
  prs.sid;sid,psid;
  qcelp;qcp;
  smv-qcp;qcp;
  smv;smv;
  sp-midi;mid;
  vnd.audiokoz;koz;
  vnd.dece.audio;uva,uvva;
  vnd.digital-winds;eol;7bit
  vnd.dolby.mlp;mlp;
  vnd.dra;dra;
  vnd.dts.hd;dtshd;
  vnd.dts;wav,cpt,dts;
  vnd.dvb.file;dvb;
  vnd.everad.plj;plj;
  vnd.hns.audio;rm;
  vnd.lucent.voice;lvp;
  vnd.ms-playready.media.pya;pya;
  vnd.nokia.mobile-xmf;mxmf;
  vnd.nortel.vbk;vbk;
  vnd.nuera.ecelp4800;ecelp4800;
  vnd.nuera.ecelp7470;ecelp7470;
  vnd.nuera.ecelp9600;ecelp9600;
  vnd.presonus.multitrack;multitrack;
  vnd.qcelp;qcp;
  vnd.rip;rip;
  vnd.rn-realaudio;ra,rax;
  vnd.sealedmedia.softseal-mpeg;smp3,smp,s1m;
  vnd.sealedmedia.softseal.mpeg;smp3,smp,s1m;
  
  1:font::E
  x-opentype;otf;
  
  1:font:I:
  sfnt;;
  
  5:font:I:E
  collection;ttc;
  otf;otf;
  ttf;ttf;
  woff2;woff2;
  woff;woff;
  
  11:image::
  x-bzeps;;
  x-compressed-xcf;;
  x-dcraw;;
  x-dib;;
  x-dpx;;
  x-emf - deprecated in favor of image/emf;;
  x-fpx;;
  x-gzeps;;
  x-tiff-multipage;;
  x-wmf - deprecated in favor of image/wmf;;
  x-xcursor;;
  
  84:image::E
  x-3ds;3ds;
  x-adobe-dng;dng;
  x-applix-graphics;ag;
  x-bmp;bmp;
  x-canon-cr2;cr2;
  x-canon-crw;crw;
  x-cmu-raster;ras,rast;
  x-cmx;cmx;
  x-coreldraw;cdr;
  x-coreldrawpattern;pat;
  x-coreldrawtemplate;cdt;
  x-corelphotopaint;cpt;
  x-dds;dds;
  x-dwg;dwg,dxf,svf;
  x-emf;emf;
  x-eps;eps,epsi,epsf;
  x-epson-erf;erf;
  x-exr;exr;
  x-fax-g3;g3;
  x-fif;fif;
  x-florian;flo,turbot;
  x-freehand;fh,fhc,fh4,fh5,fh7;
  x-fuji-raf;raf;
  x-icns;icns;
  x-icon;ico;
  x-ilbm;iff,ilbm,lbm;
  x-jg;art;
  x-jng;jng;
  x-jps;jps;
  x-jutvision;jut;
  x-kodak-dcr;dcr;
  x-kodak-k25;k25;
  x-kodak-kdc;kdc;
  x-lwo;lwo,lwob;
  x-lws;lws;
  x-macpaint;pntg;
  x-minolta-mrw;mrw;
  x-mrsid-image;sid;
  x-ms-bmp;bmp;
  x-msod;msod;
  x-niff;nif,niff;
  x-nikon-nef;nef;
  x-olympus-orf;orf;
  x-openraster;ora;
  x-panasonic-raw2;rw2;
  x-panasonic-raw;raw;
  x-pcx;pcx;
  x-pentax-pef;pef;
  x-photo-cd;pcd;
  x-photoshop;psd;
  x-pict;pic,pct,pict,pict1,pict2;
  x-pjpeg;jfif,jpe,jpeg,jpg;
  x-portable-anymap;pnm;base64
  x-portable-bitmap;pbm;base64
  x-portable-graymap;pgm;base64
  x-portable-greymap;pgm;
  x-portable-pixmap;ppm;base64
  x-quicktime;qif,qti,qtif;
  x-rgb;rgb;base64
  x-rle;rle;
  x-sgi;sgi;
  x-sigma-x3f;x3f;
  x-skencil;sk,sk1;
  x-sony-arw;arw;
  x-sony-sr2;sr2;
  x-sony-srf;srf;
  x-sun-raster;sun;
  x-svg+xml-compressed;svgz;
  x-targa;tga;
  x-tga;tga,icb,tpic,vda,vst;
  x-tiff;tif,tiff;
  x-vasa;mcf;
  x-webp;webp;
  x-win-bitmap;cur;
  x-windows-bmp;bmp;
  x-wmf;wmf;
  x-xbitmap;xbm;7bit
  x-xbm;xbm;
  x-xcf;xcf;
  x-xfig;fig;
  x-xpixmap;xpm,pm;8bit
  x-xpm;xpm;
  x-xwd;xwd;
  x-xwindowdump;xwd;base64
  
  6:image:I:
  example;;
  pwg-raster;;
  vnd-svf;;
  vnd.cns.inf2;;
  vnd.mix;;
  vnd.svf;;
  
  60:image:I:E
  aces;exr;
  bmp;bmp,dib,bm;
  cgm;cgm;
  dicom-rle;drle;
  emf;emf;
  fits;fits;
  g3fax;g3;
  gif;gif;base64
  ief;ief,iefs;base64
  jls;jls;
  jp2;jp2,jpg2,jpx,jpf;base64
  jpeg;jpeg,jpg,jpe,jfif,jfif-tbnl;base64
  jpm;jpm,jpgm;
  jpx;jpf,jpx;
  ktx;ktx;
  naplps;nap,naplps;
  png;png,x-png;base64
  prs.btif;btif,btf;
  prs.pti;pti;
  svg+xml;svg,svgz;8bit
  t38;T38;
  tiff-fx;TFX;
  tiff;TIF,tiff;base64
  vnd-djvu;djvu,djv;
  vnd-wap-wbmp;wbmp;
  vnd.adobe.photoshop;psd;
  vnd.airzip.accelerator.azv;azv;
  vnd.dece.graphic;uvi,uvvi,uvg,uvvg;
  vnd.dgn;dgn;
  vnd.djvu;djvu,djv;
  vnd.dvb.subtitle;sub;
  vnd.dwg;dwg,dxf,svf;
  vnd.dxf;dxf;
  vnd.fastbidsheet;fbs;
  vnd.fpx;fpx;
  vnd.fst;fst;
  vnd.fujixerox.edmics-mmr;mmr;
  vnd.fujixerox.edmics-rlc;rlc;
  vnd.globalgraphics.pgb;PGB;
  vnd.glocalgraphics.pgb;pgb;
  vnd.microsoft.icon;ico;
  vnd.mozilla.apng;apng,png;
  vnd.ms-modi;mdi;
  vnd.ms-photo;wdp;
  vnd.net-fpx;npx,fpx;
  vnd.radiance;pic,hdr,rgbe,xyze;
  vnd.rn-realflash;rf;
  vnd.rn-realpix;rp;
  vnd.sealed-png;spng,spn,s1n;
  vnd.sealed.png;spng,spn,s1n;
  vnd.sealedmedia.softseal-gif;sgif,sgi,s1g;
  vnd.sealedmedia.softseal-jpg;sjpg,sjp,s1j;
  vnd.sealedmedia.softseal.gif;sgif,sgi,s1g;
  vnd.sealedmedia.softseal.jpg;sjpg,sjp,s1j;
  vnd.tencent.tap;tap;
  vnd.valve.source.texture;vtf;
  vnd.wap.wbmp;wbmp;
  vnd.xiff;xif;
  vnd.zbrush.pcx;pcx;
  wmf;wmf;
  
  1:message::
  x-gnu-rmail;;
  
  14:message:I:
  cpim;;
  delivery-status;;
  example;;
  external-body;;8bit
  feedback-report;;
  global-headers;;
  http;;
  news;;8bit
  partial;;8bit
  s-http;;
  sip;;
  sipfrag;;
  tracking-status;;
  vnd.si.simp;;
  
  7:message:I:E
  disposition-notification;disposition-notification;
  global-delivery-status;u8dsn;
  global-disposition-notification;u8mdn;
  global;u8msg;
  imdn+xml;cl,xml;
  rfc822;eml,mime,mht,mhtml,nws;8bit
  vnd.wfa.wsc;WSC;
  
  3:model::E
  x-pov;pov;
  x-x3d+binary;x3db,x3dbz;
  x-x3d+vrml;x3dv,x3dvz;
  
  3:model:I:
  example;;
  vnd.gs.gdl;;
  vnd.rosette.annotated-data-model;;
  
  25:model:I:E
  3mf;3mf;
  gltf+json;gltf;
  gltf-binary;glb;
  iges;igs,iges;
  mesh;msh,mesh,silo;
  vnd-dwf;dwf;
  vnd.collada+xml;dae;
  vnd.dwf;dwf;
  vnd.flatland.3dml;3dml,3dm;
  vnd.gdl;gdl;
  vnd.gs-gdl;gdl,gsm,win,dor,lmp,rsm,msm,ism;
  vnd.gtw;gtw;
  vnd.moml+xml;xml,moml;
  vnd.mts;mts;
  vnd.opengex;ogex;
  vnd.parasolid.transmit-binary;X_B,xmt_bin;
  vnd.parasolid.transmit-text;X_T,xmt_txt;
  vnd.parasolid.transmit.binary;X_B,xmt_bin;
  vnd.parasolid.transmit.text;X_T,xmt_txt;quoted-printable
  vnd.valve.source.compiled-map;bsp;
  vnd.vtu;vtu;
  vrml;wrl,vrml,wrz,vrm;
  x3d+fastinfoset;x3db;
  x3d+xml;x3d,x3dz;
  x3d-vrml;x3dv;
  
  3:multipart::
  x-mixed-replace;;
  x-tar;;
  x-www-form-urlencoded;;
  
  3:multipart::E
  x-gzip;gzip;
  x-ustar;ustar;
  x-zip;zip;
  
  14:multipart:I:
  alternative;;8bit
  appledouble;;8bit
  byteranges;;
  digest;;8bit
  encrypted;;
  example;;
  form-data;;
  header-set;;
  mixed;;8bit
  multilingual;;
  parallel;;8bit
  related;;
  report;;
  signed;;
  
  2:multipart:I:E
  vnd.bint.med-plus;bmed;
  voice-message;VPM;
  
  14:text::
  x-authors;;
  x-changelog;;
  x-comma-separated-values;;8bit
  x-copying;;
  x-credits;;
  x-crontab;;
  x-english;;
  x-htmlh;;
  x-install;;
  x-meson;;
  x-readme;;
  x-scons;;
  x-uri;;
  x-xmcd;;
  
  123:text::E
  x-adasrc;adb,ads;
  x-asm;s,asm;
  x-asp;asp;
  x-audiosoft-intra;aip;
  x-bibtex;bib;
  x-boo;boo;
  x-c++hdr;h++,hpp,hxx,hh,hp;
  x-c++src;c++,cpp,cxx,cc,C;
  x-c;c,cc,cxx,cpp,h,hh,dic;
  x-chdr;h;
  x-cmake;cmake;
  x-cobol;cbl,cob;
  x-component;htc;8bit
  x-csh;csh;
  x-csharp;cs;
  x-csrc;c;
  x-dcl;dcl;
  x-diff;diff,patch;
  x-dsl;dsl;
  x-dsrc;d,di;
  x-eiffel;e,eif;
  x-emacs-lisp;el;
  x-erlang;erl;
  x-event-stream;event-stream;
  x-fortran;f,for,f77,f90,f95;
  x-genie;gs;
  x-gettext-translation-template;pot;
  x-gettext-translation;po;
  x-go;go;
  x-google-video-pointer;gvp;
  x-h323;323;
  x-h;h,hh;
  x-haskell;hs;
  x-idl;idl;
  x-imelody;imy,ime;
  x-iptables;iptables;
  x-iuls;uls;
  x-java-source;java,jav;
  x-java;java;
  x-la-asf;lsx;
  x-ldif;ldif;
  x-lilypond;ly;
  x-literate-haskell;lhs;
  x-log;log;
  x-lua;lua;
  x-m;m;
  x-makefile;mk,mak;
  x-markdown;markdown,md,mkd;
  x-mathml;mml;
  x-matlab;m;
  x-mcf;mcf;
  x-microdvd;sub;
  x-moc;moc;
  x-modelica;mo;
  x-mof;mof;
  x-mpsub;sub;
  x-mrml;mrml,mrl;
  x-ms-regedit;reg;
  x-mup;mup,not;
  x-nfo;nfo;
  x-objcsrc;m;
  x-ocaml;ml,mli;
  x-ocl;ocl;
  x-ooc;ooc;
  x-opml+xml;opml;
  x-opml;opml;
  x-pascal;p,pas;
  x-patch;diff,patch;
  x-pcs-gcd;gcd;
  x-python;py,pyx,wsgi;
  x-qml;qml,qmltypes,qmlproject;
  x-reject;rej;
  x-rpm-spec;spec;
  x-rust;rs;
  x-scala;scala;
  x-scheme;scm,ss;
  x-scriplet;wsc;
  x-script.csh;csh;
  x-script.elisp;el;
  x-script.guile;scm;
  x-script.ksh;ksh;
  x-script.lisp;lsp;
  x-script.perl-module;pm;
  x-script.perl;pl;
  x-script.phyton;py;
  x-script.rexx;rexx;
  x-script.scheme;scm;
  x-script.sh;sh;
  x-script.tcl;tcl;
  x-script.tcsh;tcsh;
  x-script.zsh;zsh;
  x-script;hlb;
  x-scriptlet;sct,wsc;
  x-server-parsed-html;shtml,ssi;
  x-setext;etx;
  x-sfv;sfv;
  x-sgml;sgml,sgm;8bit
  x-sh;sh;
  x-speech;spc,talk;
  x-spreadsheet;sylk,slk;
  x-ssa;ssa,ass;
  x-subviewer;sub;
  x-svhdr;svh;
  x-svsrc;sv;
  x-tcl;tcl,tk;
  x-tex;tex,ltx,sty,cls,dtx,ins,latex;
  x-texinfo;texi,texinfo;
  x-texmacs;tm,ts;
  x-troff-me;me;
  x-troff-mm;mm;
  x-troff-ms;ms;
  x-txt2tags;t2t;
  x-uil;uil;
  x-uuencode;uu,uue;
  x-vala;vala,vapi;
  x-vcalendar;vcs;8bit
  x-vcard;vcf;8bit
  x-verilog;v;
  x-vhdl;vhd,vhdl;
  x-vtt;vtt;
  x-webviewhtml;htt;
  x-xmi;xmi;
  x-xslfo;fo,xslfo;
  
  26:text:I:
  1d-interleaved-parityfec;;
  directory - deprecated by rfc6350;;
  directory;;
  encaprtp;;
  enriched;;
  example;;
  fwdred;;
  grammar-ref-list;;
  parameters;;
  parityfec;;
  provenance-notation;;
  raptorfec;;
  red;;
  rfc822-headers;;
  rtp-enc-aescm128;;
  rtploopback;;
  rtx;;
  strings;;
  t140;;
  ulpfec;;
  vnd.a;;
  vnd.debian.copyright;;
  vnd.flatland.3dml;;
  vnd.latex-z;;
  vnd.motorola.reflex;;
  vnd.radisys.msml-basic-layout;;
  
  56:text:I:E
  cache-manifest;appcache,manifest;
  calendar;ics,icz,ifb,vcs;
  css;css;8bit
  csv-schema;csvs;
  csv;CSV;8bit
  dns;soa,zone;
  ecmascript;es,js;
  html;html,htm,htmlx,shtml,htx,acgi,htmls;8bit
  javascript;js;
  jcr-cnd;cnd;
  markdown;md,markdown,mkd;
  mizar;miz;
  n3;n3;
  plain;txt,brf,conf,def,list,in,g,idc,lst,sdml,ini;8bit
  prs.fallenstein.rst;txt,rst;
  prs.lines.tag;tag,dsc;
  prs.prop.logic;txt;
  richtext;rtx,rt,rtf;8bit
  rtf;rtf;8bit
  sgml;sgml,sgm;
  tab-separated-values;tsv;
  troff;t,tr,roff,man,me,ms;
  turtle;ttl;
  uri-list;uris,uri,urls,uni,unis;
  vcard;vcf,vcard,vct,gcrd;
  vnd-a;a;
  vnd-curl;curl;
  vnd.abc;abc;
  vnd.ascii-art;ascii;
  vnd.curl.dcurl;dcurl;
  vnd.curl.mcurl;mcurl;
  vnd.curl.scurl;scurl;
  vnd.curl;curl;
  vnd.dmclientscript;dms;
  vnd.dvb.subtitle;sub;
  vnd.esmertec.theme-descriptor;jtd;
  vnd.fly;fly;
  vnd.fmi.flexstor;flx;
  vnd.graphviz;gv,dot;
  vnd.in3d.3dml;3dml,3dm;
  vnd.in3d.spot;spot,spo;
  vnd.iptc.newsml;xml;
  vnd.iptc.nitf;xml;
  vnd.ms-mediapackage;mpf;
  vnd.net2phone.commcenter.command;ccc;
  vnd.rn-realtext;rt;
  vnd.si.uricatalogue;uric;
  vnd.sun.j2me.app-descriptor;jad;8bit
  vnd.trolltech.linguist;ts;
  vnd.wap-wml;wml,xml;
  vnd.wap.si;si,xml;
  vnd.wap.sl;sl,xml;
  vnd.wap.wml;wml;
  vnd.wap.wmlscript;wmls;
  xml-external-parsed-entity;xml,ent;
  xml;xml;
  
  3:video::
  x-anim;;
  x-isivideo;;
  x-wavelet;;
  
  43:video::E
  x-amt-demorun;xdr;
  x-amt-showrun;xsr;
  x-animaflex;afl;
  x-annodex;axv;
  x-atomic3d-feature;fmf;
  x-avi;avi;
  x-avs-video;avs;
  x-dl;dl;base64
  x-dv;dif,dv;
  x-f4v;f4v;
  x-fli;fli;base64
  x-flic;fli,flc;
  x-flv;flv;base64
  x-gl;gl;base64
  x-isvideo;isu;
  x-javafx;fxm;
  x-la-asf;lsf,lsx;
  x-m4v;m4v;
  x-matroska-3d;mk3d;
  x-matroska;mpv,mkv,mk3d,mks;
  x-mng;mng;
  x-motion-jpeg;mjpg;
  x-mpeg;mp2,mp3;
  x-mpeq2a;mp2;
  x-ms-asf-plugin;asx;
  x-ms-asf;asf,asx;
  x-ms-vob;vob;
  x-ms-wm;wm;
  x-ms-wmv;wmv;
  x-ms-wmx;wmx;
  x-ms-wvx;wvx;
  x-msvideo;avi,avf,divx;base64
  x-nsv;nsv;
  x-ogm+ogg;ogm;
  x-qtc;qtc;
  x-scm;scm;
  x-sgi-movie;movie,mv;base64
  x-smv;smv;
  x-theora+ogg;ogg;
  x-vdo;vdo;
  x-vivo;viv,vivo;
  x-vosaic;vos;
  x-webm;webm;base64
  
  48:video:I:
  1d-interleaved-parityfec;;
  3gpp-tt;;
  bmpeg;;
  bt656;;
  celb;;
  encaprtp;;
  example;;
  h263-1998;;
  h263-2000;;
  h264-rcdo;;
  h264-svc;;
  h265;;
  jpeg2000;;
  mp1s;;
  mp2p;;
  mp4v-es;;
  mpeg4-generic;;
  mpv;;
  nv;;
  parityfec;;
  pointer;;
  raptorfec;;
  raw;;
  rtp-enc-aescm128;;
  rtploopback;;
  rtx;;
  smpte291;;
  smpte292m;;
  ulpfec;;
  vc1;;
  vnd-vivo;;
  vnd.cctv;;
  vnd.dece.mp4;;
  vnd.directv-mpeg;;
  vnd.directv.mpeg-tts;;
  vnd.directv.mpeg;;
  vnd.dlna.mpeg-tts;;
  vnd.iptvforum.1dparityfec-1010;;
  vnd.iptvforum.1dparityfec-2005;;
  vnd.iptvforum.2dparityfec-1010;;
  vnd.iptvforum.2dparityfec-2005;;
  vnd.iptvforum.ttsavc;;
  vnd.iptvforum.ttsmpeg2;;
  vnd.motorola.video;;
  vnd.motorola.videop;;
  vnd.mts;;
  vnd.nokia.videovoip;;
  vp8;;
  
  42:video:I:E
  3gpp2;3g2,3gpp2,3gp2;base64
  3gpp;3gp,3gpp,3ga;base64
  dv;dif,dv;
  h261;h261;
  h263;h263;
  h264;h264;
  iso.segment;m4s;
  jpeg;jpgv;
  jpm;jpm,jpgm;
  mj2;mj2,mjp2;
  mp2t;ts,m2t,m2ts,mts,cpi,clpi,mpl,mpls,bdm,bdmv;
  mp4;mp4,mpg4,f4v,f4p,mp4v,m4v,lrv;
  mpeg;mp2,mpe,mpeg,mpg,m1v,m2v,mp3,mpa,vob;base64
  ogg;ogv,ogg;
  quicktime;qt,mov,moov,qtvr;base64
  vnd-mpegurl;mxu,m4u;
  vnd.dece-mp4;uvu,uvvu;
  vnd.dece.hd;uvh,uvvh;
  vnd.dece.mobile;uvm,uvvm;
  vnd.dece.pd;uvp,uvvp;
  vnd.dece.sd;uvs,uvvs;
  vnd.dece.video;uvv,uvvv;
  vnd.dvb.file;dvb;
  vnd.fvt;fvt;
  vnd.hns.video;rm;
  vnd.mpegurl;mxu,m4u,m1u;8bit
  vnd.ms-playready.media.pyv;pyv;
  vnd.nokia.interleaved-multimedia;nim;
  vnd.nokia.mp4vr;mp4;
  vnd.objectvideo;mp4;
  vnd.radgamettools.bink;bik,bk2;
  vnd.radgamettools.smacker;smk;
  vnd.rn-realvideo;rv,rvx;
  vnd.sealed-swf;sswf,ssw;
  vnd.sealed.mpeg1;smpg,s11;
  vnd.sealed.mpeg4;smpg,s14;
  vnd.sealed.swf;sswf,ssw;
  vnd.sealedmedia.softseal-mov;smov,smo,s1q;
  vnd.sealedmedia.softseal.mov;smov,smo,s1q;
  vnd.uvvu-mp4;uvu,uvvu;
  vnd.uvvu.mp4;uvu,uvvu;
  vnd.vivo;viv,vivo;
  
  54:x-chemical::E
  x-alchemy;alc;
  x-cache-csf;csf;
  x-cache;cac,cache;
  x-cactvs-binary;cbin,cascii,ctab;
  x-cdx;cdx;
  x-cerius;cer;
  x-chem3d;c3d;
  x-chemdraw;chm;
  x-cif;cif;
  x-cmdf;cmdf;
  x-cml;cml;
  x-compass;cpa;
  x-crossfire;bsd;
  x-csml;csml,csm;
  x-ctx;ctx;
  x-cxf;cxf,cef;
  x-embl-dl-nucleotide;emb,embl;
  x-galactic-spc;spc;
  x-gamess-input;inp,gam,gamin;
  x-gaussian-checkpoint;fch,fchk;
  x-gaussian-cube;cub;
  x-gaussian-input;gau,gjc,gjf;
  x-gaussian-log;gal;
  x-gcg8-sequence;gcg;
  x-genbank;gen;
  x-hin;hin;
  x-isostar;istr,ist;
  x-jcamp-dx;jdx,dx;
  x-kinemage;kin;
  x-macmolecule;mcm;
  x-macromodel-input;mmd,mmod;
  x-mdl-molfile;mol;
  x-mdl-rdfile;rd;
  x-mdl-rxnfile;rxn;
  x-mdl-sdfile;sd,sdf;
  x-mdl-tgf;tgf;
  x-mmcif;mcif;
  x-mol2;mol2;
  x-molconn-z;b;
  x-mopac-graph;gpt;
  x-mopac-input;mop,mopcrt,mpc,zmt;
  x-mopac-out;moo;
  x-mopac-vib;mvb;
  x-ncbi-asn1-ascii;prt,ent;
  x-ncbi-asn1-binary;val,aso;
  x-ncbi-asn1-spec;asn;
  x-ncbi-asn1;asn;
  x-pdb;pdb,ent,xyz;
  x-rosdal;ros;
  x-swissprot;sw;
  x-vamas-iso14976;vms;
  x-vmd;vmd;
  x-xtel;xtel;
  x-xyz;xyz;
  
  1:x-conference::E
  x-cooltalk;ice;
  
  18:x-content::
  x-audio-cdda;;
  x-audio-dvd;;
  x-audio-player;;
  x-blank-bd;;
  x-blank-cd;;
  x-blank-dvd;;
  x-blank-hddvd;;
  x-ebook-reader;;
  x-image-dcf;;
  x-image-picturecd;;
  x-software;;
  x-unix-software;;
  x-video-bluray;;
  x-video-dvd;;
  x-video-hddvd;;
  x-video-svcd;;
  x-video-vcd;;
  x-win32-software;;
  
  1:x-drawing::E
  x-dwf;dwf;
  
  1:x-epoc::E
  x-sisx-app;sisx;
  
  1:x-i-world::E
  x-i-vrml;ivr;
  
  8:x-inode::
  x-blockdevice;;
  x-chardevice;;
  x-directory-locked;;
  x-directory;;
  x-fifo;;
  x-mount-point;;
  x-socket;;
  x-symlink;;
  
  3:x-music::E
  x-crescendo;mid,midi;
  x-karaoke;kar;
  x-midi;mid,midi;
  
  1:x-paleovu::E
  x-pv;pvu;
  
  1:x-windows::E
  x-metafile;wmf;
  
  4:x-world::E
  x-3dmf;3dm,3dmf,qd3,qd3d;
  x-svr;svr;
  x-vrml;wrl,vrml,vrm,wrz;
  x-vrt;vrt;
  
  1:x-www::E
  x-mime;mime;
  
  2:x-xgl::E
  x-drawing;xgz;
  x-movie;xmz;
MIME_TYPES

$fatpacked{"Mail/Address.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_ADDRESS';
  package Mail::Address;use vars '$VERSION';$VERSION='2.21';use strict;use Carp;sub Version {our$VERSION}sub _extract_name {my$self=@_ && ref $_[0]? shift : undef;local $_=shift or return '';return '' if m/\=\?.*?\?\=/;s/^\s+//;s/\s+$//;s/\s+/ /;return "" if /^[\d ]+$/;s/^\((.*)\)$/$1/;s/^"(.*)"$/$1/;s/\(.*?\)//g;s/\\//g;s/^"(.*)"$/$1/;s/^([^\s]+) ?, ?(.*)$/$2 $1/;s/,.*//;unless(m/[A-Z]/ && m/[a-z]/){s/\b(\w+)/\L\u$1/igo;s/\bMc(\w)/Mc\u$1/igo;s/\bo'(\w)/O'\u$1/igo;s/\b(x*(ix)?v*(iv)?i*)\b/\U$1/igo}s/\[[^\]]*\]//g;s/(^[\s'"]+|[\s'"]+$)//g;s/\s{2,}/ /g;$_}sub _tokenise {local $_=join ',',@_;my (@words,$snippet,$field);s/\A\s+//;s/[\r\n]+/ /g;while ($_ ne ''){$field='';if(s/^\s*\(/(/){my$depth=0;PAREN: while(s/^(\(([^\(\)\\]|\\.)*)//){$field .= $1;$depth++;while(s/^(([^\(\)\\]|\\.)*\)\s*)//){$field .= $1;last PAREN unless --$depth;$field .= $1 if s/^(([^\(\)\\]|\\.)+)//}}carp "Unmatched () '$field' '$_'" if$depth;$field =~ s/\s+\Z//;push@words,$field;next}if(s/^("(?:[^"\\]+|\\.)*")\s*// || s/^(\[(?:[^\]\\]+|\\.)*\])\s*// || s/^([^\s()<>\@,;:\\".[\]]+)\s*// || s/^([()<>\@,;:\\".[\]])\s*//){push@words,$1;next}croak "Unrecognised line: $_"}push@words,",";\@words}sub _find_next {my ($idx,$tokens,$len)=@_;while($idx < $len){my$c=$tokens->[$idx];return$c if$c eq ',' || $c eq ';' || $c eq '<';$idx++}""}sub _complete {my ($class,$phrase,$address,$comment)=@_;@$phrase || @$comment || @$address or return undef;my$o=$class->new(join(" ",@$phrase),join("",@$address),join(" ",@$comment));@$phrase=@$address=@$comment=();$o}sub new(@) {my$class=shift;bless [@_],$class}sub parse(@) {my$class=shift;my@line=grep {defined}@_;my$line=join '',@line;my (@phrase,@comment,@address,@objs);my ($depth,$idx)=(0,0);my$tokens=_tokenise@line;my$len=@$tokens;my$next=_find_next$idx,$tokens,$len;local $_;for(my$idx=0;$idx < $len;$idx++){$_=$tokens->[$idx];if(substr($_,0,1)eq '('){push@comment,$_}elsif($_ eq '<'){$depth++}elsif($_ eq '>'){$depth-- if$depth}elsif($_ eq ',' || $_ eq ';'){warn "Unmatched '<>' in $line" if$depth;my$o=$class->_complete(\@phrase,\@address,\@comment);push@objs,$o if defined$o;$depth=0;$next=_find_next$idx+1,$tokens,$len}elsif($depth){push@address,$_}elsif($next eq '<'){push@phrase,$_}elsif(/^[.\@:;]$/ ||!@address || $address[-1]=~ /^[.\@:;]$/){push@address,$_}else {warn "Unmatched '<>' in $line" if$depth;my$o=$class->_complete(\@phrase,\@address,\@comment);push@objs,$o if defined$o;$depth=0;push@address,$_}}@objs}sub phrase {shift->set_or_get(0,@_)}sub address {shift->set_or_get(1,@_)}sub comment {shift->set_or_get(2,@_)}sub set_or_get($) {my ($self,$i)=(shift,shift);@_ or return$self->[$i];my$val=$self->[$i];$self->[$i]=shift if @_;$val}my$atext='[\-\w !#$%&\'*+/=?^`{|}~]';sub format {my@addrs;for (@_){my ($phrase,$email,$comment)=@$_;my@addr;if(defined$phrase && length$phrase){push@addr ,$phrase =~ /^(?:\s*$atext\s*)+$/o ? $phrase : $phrase =~ /(?<!\\)"/ ? $phrase : qq("$phrase");push@addr,"<$email>" if defined$email && length$email}elsif(defined$email && length$email){push@addr,$email}if(defined$comment && $comment =~ /\S/){$comment =~ s/^\s*\(?/(/;$comment =~ s/\)?\s*$/)/}push@addr,$comment if defined$comment && length$comment;push@addrs,join(" ",@addr)if@addr}join ", ",@addrs}sub name {my$self=shift;my$phrase=$self->phrase;my$addr=$self->address;$phrase=$self->comment unless defined$phrase && length$phrase;my$name=$self->_extract_name($phrase);if($name eq '' && $addr =~ /([^\%\.\@_]+([\._][^\%\.\@_]+)+)[\@\%]/){($name=$1)=~ s/[\._]+/ /g;$name=_extract_name$name}if($name eq '' && $addr =~ m#/g=#i){my ($f)=$addr =~ m#g=([^/]*)#i;my ($l)=$addr =~ m#s=([^/]*)#i;$name=_extract_name "$f $l"}length$name ? $name : undef}sub host {my$addr=shift->address || '';my$i=rindex$addr,'@';$i >= 0 ? substr($addr,$i+1): undef}sub user {my$addr=shift->address || '';my$i=rindex$addr,'@';$i >= 0 ? substr($addr,0,$i): $addr}1;
MAIL_ADDRESS

$fatpacked{"Mail/Box.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX';
  package Mail::Box;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Mail::Box::Message;use Mail::Box::Locker;use File::Spec;use Carp;use Scalar::Util 'weaken';use List::Util qw/sum first/;use Devel::GlobalDestruction 'in_global_destruction';use overload '@{}'=>sub {shift->{MB_messages}},'""'=>'name' ,'cmp'=>sub {$_[0]->name cmp "${_[1]}"};sub new(@) {my$class=shift;if($class eq __PACKAGE__){my$package=__PACKAGE__;croak <<USAGE}my%args=@_;weaken$args{manager};my$self=$class->SUPER::new (@_ ,init_options=>\%args)or return;$self->read or return if$self->{MB_access}=~ /r|a/;$self}sub init($) {my ($self,$args)=@_;return unless defined$self->SUPER::init($args);my$class=ref$self;my$foldername=$args->{folder}|| $ENV{MAIL};unless($foldername){$self->log(ERROR=>"No folder name specified.");return}$self->{MB_foldername}=$foldername;$self->{MB_init_options}=$args->{init_options};$self->{MB_coerce_opts}=$args->{coerce_options}|| [];$self->{MB_access}=$args->{access}|| 'r';$self->{MB_remove_empty}=defined$args->{remove_when_empty}? $args->{remove_when_empty}: 1;$self->{MB_save_on_exit}=defined$args->{save_on_exit}? $args->{save_on_exit}: 1;$self->{MB_messages}=[];$self->{MB_msgid}={};$self->{MB_organization}=$args->{organization}|| 'FILE';$self->{MB_linesep}="\n";$self->{MB_keep_dups}=!$self->writable || $args->{keep_dups};$self->{MB_fix_headers}=$args->{fix_headers};my$folderdir=$self->folderdir($args->{folderdir});$self->{MB_trusted}=exists$args->{trusted}? $args->{trusted}: substr($foldername,0,1)eq '=' ? 1 :!defined$folderdir ? 0 : substr($foldername,0,length$folderdir)eq $folderdir;if(exists$args->{manager}){$self->{MB_manager}=$args->{manager};weaken($self->{MB_manager})}my$message_type=$self->{MB_message_type}=$args->{message_type}|| $class .'::Message';$self->{MB_body_type}=$args->{body_type}|| 'Mail::Message::Body::Lines';$self->{MB_body_delayed_type}=$args->{body_delayed_type}|| 'Mail::Message::Body::Delayed';$self->{MB_head_delayed_type}=$args->{head_delayed_type}|| 'Mail::Message::Head::Delayed';$self->{MB_multipart_type}=$args->{multipart_type}|| 'Mail::Message::Body::Multipart';$self->{MB_field_type}=$args->{field_type};my$headtype=$self->{MB_head_type}=$args->{head_type}|| 'Mail::Message::Head::Complete';my$extract=$args->{extract}|| 'extractDefault';$self->{MB_extract}=ref$extract eq 'CODE' ? $extract : $extract eq 'ALWAYS' ? sub {1}: $extract eq 'LAZY' ? sub {0}: $extract eq 'NEVER' ? sub {1}: $extract =~ m/\D/ ? sub {no strict 'refs';shift->$extract(@_)}: sub {my$size=$_[1]->guessBodySize;defined$size && $size < $extract};$self->{MB_locker}=$args->{locker}|| Mail::Box::Locker->new (folder=>$self ,method=>$args->{lock_type},timeout=>$args->{lock_timeout},expires=>$args->{lock_wait},file=>($args->{lockfile}|| $args->{lock_file}),$self->logSettings);$self}sub folderdir(;$) {my$self=shift;$self->{MB_folderdir}=shift if @_;$self->{MB_folderdir}}sub foundIn($@) {shift->notImplemented}sub name() {shift->{MB_foldername}}sub type() {shift->notImplemented}sub url() {my$self=shift;$self->type .':' .$self->name}sub size() {sum map {$_->size}shift->messages('ACTIVE')}sub update(@) {my$self=shift;$self->updateMessages (trusted=>$self->{MB_trusted},head_type=>$self->{MB_head_type},field_type=>$self->{MB_field_type},message_type=>$self->{MB_message_type},body_delayed_type=>$self->{MB_body_delayed_type},head_delayed_type=>$self->{MB_head_delayed_type},@_);$self}sub organization() {shift->notImplemented}sub addMessage($@) {my$self=shift;my$message=shift or return$self;my%args=@_;confess <<ERROR if$message->can('folder')&& defined$message->folder;my$coerced=$self->coerce($message);$coerced->folder($self);unless($coerced->head->isDelayed){my$msgid=$coerced->messageId;unless($self->{MB_keep_dups}){if(my$found=$self->messageId($msgid)){$coerced->label(deleted=>1);return$found}}$self->messageId($msgid,$coerced);$self->toBeThreaded($coerced)}$self->storeMessage($coerced);$coerced}sub addMessages(@) {my$self=shift;map$self->addMessage($_),@_}sub copyTo($@) {my ($self,$to,%args)=@_;my$select=$args{select}|| 'ACTIVE';my$subfolders=exists$args{subfolders}? $args{subfolders}: 1;my$can_recurse=not $self->isa('Mail::Box::POP3');my ($flatten,$recurse)=$subfolders eq 'FLATTEN' ? (1,0): $subfolders eq 'RECURSE' ? (0,1):!$subfolders ? (0,0): $can_recurse ? (0,1): (1,0);my$delete=$args{delete_copied}|| 0;my$share=$args{share}|| 0;$self->_copy_to($to,$select,$flatten,$recurse,$delete,$share)}sub _copy_to($@) {my ($self,$to,@options)=@_;my ($select,$flatten,$recurse,$delete,$share)=@options;$self->log(ERROR=>"Destination folder $to is not writable."),return unless$to->writable;my@select=$self->messages($select);$self->log(PROGRESS=>"Copying ".@select." messages from $self to $to.");for my$msg (@select){if($msg->copyTo($to,share=>$share)){$msg->label(deleted=>1)if$delete}else {$self->log(ERROR=>"Copying failed for one message.")}}return$self unless$flatten || $recurse;SUBFOLDER: foreach ($self->listSubFolders(check=>1)){my$subfolder=$self->openSubFolder($_,access=>'r');$self->log(ERROR=>"Unable to open subfolder $_"),next unless defined$subfolder;if($flatten){unless($subfolder->_copy_to($to,@options)){$subfolder->close;return}}else {my$subto=$to->openSubFolder($_,create=>1,access=>'rw');unless($subto){$self->log(ERROR=>"Unable to create subfolder $_ of $to");next SUBFOLDER}unless($subfolder->_copy_to($subto,@options)){$subfolder->close;$subto->close;return}$subto->close}$subfolder->close}$self}sub close(@) {my ($self,%args)=@_;my$force=$args{force}|| 0;return 1 if$self->{MB_is_closed};$self->{MB_is_closed}++;my$manager=delete$self->{MB_manager};$manager->close($self,close_by_self=>1)if defined$manager &&!$args{close_by_manager};my$write;for($args{write}|| 'MODIFIED'){$write=$_ eq 'MODIFIED' ? $self->isModified : $_ eq 'ALWAYS' ? 1 : $_ eq 'NEVER' ? 0 : croak "Unknown value to folder->close(write => $_)."}my$locker=$self->locker;if($write &&!$force &&!$self->writable){$self->log(WARNING=>"Changes not written to read-only folder $self.
  You should not instantiate $package directly, but rather one of the
  sub-classes, such as Mail::Box::Mbox.  If you need automatic folder
  type detection then use Mail::Box::Manager.
  USAGE
  You cannot add a message which is already part of a folder to a new
  one.  Please use moveTo or copyTo.
  ERROR
  Suggestion: \$folder->close(write => 'NEVER')");$locker->unlock if$locker;$self->{MB_messages}=[];return 0}my$rc=!$write || $self->write (force=>$force ,save_deleted=>$args{save_deleted}|| 0);$locker->unlock if$locker;$self->{MB_messages}=[];$rc}sub delete(@) {my ($self,%args)=@_;my$recurse=exists$args{recursive}? $args{recursive}: 1;unless($self->writable){$self->log(ERROR=>"Folder $self not deleted: not writable.");$self->close(write=>'NEVER');return}if($recurse){for ($self->listSubFolders){my$sub=$self->openRelatedFolder (folder=>"$self/$_",access=>'d',create=>0);defined$sub && $sub->delete(%args)}}$self->close(write=>'NEVER');$self}sub appendMessages(@) {shift->notImplemented}sub writable() {shift->{MB_access}=~ /w|a|d/}sub writeable() {shift->writable}sub readable() {1}sub access() {shift->{MB_access}}sub modified(;$) {my$self=shift;return$self->isModified unless @_;return if$self->{MB_modified}=shift;$_->modified(0)foreach$self->messages;0}sub isModified() {my$self=shift;return 1 if$self->{MB_modified};for (@{$self->{MB_messages}}){return$self->{MB_modified}=1 if $_->isDeleted || $_->isModified}0}sub message(;$$) {my ($self,$index)=(shift,shift);@_ ? $self->{MB_messages}[$index]=shift : $self->{MB_messages}[$index]}sub messageId($;$) {my ($self,$msgid)=(shift,shift);if($msgid =~ m/\<([^>]+)\>/s){$msgid=$1;$msgid =~ s/\s//gs;$self->log(WARNING=>"Message-id '$msgid' does not contain a domain.")unless index($msgid,'@')>= 0}return$self->{MB_msgid}{$msgid}unless @_;my$message=shift;unless($message){delete$self->{MB_msgid}{$msgid};return}my$double=$self->{MB_msgid}{$msgid};if(defined$double &&!$self->{MB_keep_dups}){my$head1=$message->head;my$head2=$double->head;my$subj1=$head1->get('subject')|| '';my$subj2=$head2->get('subject')|| '';my$to1=$head1->get('to')|| '';my$to2=$head2->get('to')|| '';return$message->label(deleted=>1)if$subj1 eq $subj2 && $to1 eq $to2;$self->log(WARNING=>"Different messages with id $msgid");$msgid=$message->takeMessageId(undef)}$self->{MB_msgid}{$msgid}=$message;weaken($self->{MB_msgid}{$msgid});$message}sub messageID(@) {shift->messageId(@_)}sub find($) {my ($self,$msgid)=(shift,shift);my$msgids=$self->{MB_msgid};if($msgid =~ m/\<([^>]*)\>/s){$msgid=$1;$msgid =~ s/\s//gs}else {$msgid =~ s/\s/+/gs}$self->scanForMessages(undef,$msgid,'EVER','ALL')unless exists$msgids->{$msgid};$msgids->{$msgid}}sub messages($;$) {my$self=shift;return @{$self->{MB_messages}}unless @_;my$nr=@{$self->{MB_messages}};if(@_==2){my ($begin,$end)=@_;$begin += $nr if$begin < 0;$begin=0 if$begin < 0;$end += $nr if$end < 0;$end=$nr-1 if$end >= $nr;return ()if$begin > $end;my@range=@{$self->{MB_messages}}[$begin..$end];return@range}my$what=shift;my$action =ref$what eq 'CODE'? $what : $what eq 'DELETED' ? sub {$_[0]->isDeleted}: $what eq 'ACTIVE' ? sub {not $_[0]->isDeleted}: $what eq 'ALL' ? sub {1}: $what =~ s/^\!// ? sub {not $_[0]->label($what)}: sub {$_[0]->label($what)};grep {$action->($_)}@{$self->{MB_messages}}}sub nrMessages(@) {scalar shift->messages(@_)}sub messageIds() {map {$_->messageId}shift->messages}sub allMessageIds() {shift->messageIds}sub allMessageIDs() {shift->messageIds}sub current(;$) {my$self=shift;unless(@_){return$self->{MB_current}if exists$self->{MB_current};my$current =$self->findFirstLabeled(current=>1)|| $self->findFirstLabeled(seen=>0)|| $self->message(-1)|| return undef;$current->label(current=>1);$self->{MB_current}=$current;return$current}my$next=shift;if(my$previous=$self->{MB_current}){$previous->label(current=>0)}($self->{MB_current}=$next)->label(current=>1);$next}sub scanForMessages($$$$) {my ($self,$startid,$msgids,$moment,$window)=@_;my%search=map +($_=>1),ref$msgids ? @$msgids : $msgids;return ()unless keys%search;my$nr_messages=$self->messages or return keys%search;my$startmsg=defined$startid ? $self->messageId($startid): undef;my$bound=0;if($window ne 'ALL' && defined$startmsg){$bound=$startmsg->seqnr - $window;$bound=0 if$bound < 0}my$last=($self->{MBM_last}|| $nr_messages)-1;return keys%search if defined$bound && $bound > $last;my$after=$moment eq 'EVER' ? 0 : $moment =~ m/^\d+$/ ? $moment :!$startmsg ? 0 : $startmsg->timestamp - $self->timespan2seconds($moment);while($last >= $bound){my$message=$self->message($last);my$msgid=$message->messageId;if(delete$search{$msgid}){last unless keys%search}last if$message->timestamp < $after;$last--}$self->{MBM_last}=$last;keys%search}sub findFirstLabeled($;$$) {my ($self,$label,$set,$msgs)=@_;if(!defined$set || $set){my$f=first {$_->label($label)}(defined$msgs ? @$msgs : $self->messages)}else {return first {not $_->label($label)}(defined$msgs ? @$msgs : $self->messages)}}sub listSubFolders(@) {()}sub openRelatedFolder(@) {my$self=shift;my@options=(%{$self->{MB_init_options}},@_);$self->{MB_manager}? $self->{MB_manager}->open(type=>ref($self),@options): (ref$self)->new(@options)}sub openSubFolder($@) {my$self=shift;my$name=$self->nameOfSubFolder(shift);$self->openRelatedFolder(@_,folder=>$name)}sub nameOfSubFolder($;$) {my ($thing,$name)=(shift,shift);my$parent=@_ ? shift : ref$thing ? $thing->name : undef;defined$parent ? "$parent/$name" : $name}sub topFolderWithMessages() {1}sub read(@) {my$self=shift;$self->{MB_open_time}=time;local$self->{MB_lazy_permitted}=1;return unless$self->readMessages (trusted=>$self->{MB_trusted},head_type=>$self->{MB_head_type},field_type=>$self->{MB_field_type},message_type=>$self->{MB_message_type},body_delayed_type=>$self->{MB_body_delayed_type},head_delayed_type=>$self->{MB_head_delayed_type},@_);if($self->{MB_modified}){$self->log(INTERNAL=>"Modified $self->{MB_modified}");$self->{MB_modified}=0}$self}sub write(@) {my ($self,%args)=@_;unless($args{force}|| $self->writable){$self->log(ERROR=>"Folder $self is opened read-only.");return}my (@keep,@destroy);if($args{save_deleted}){@keep=$self->messages}else {for ($self->messages){if($_->isDeleted){push@destroy,$_;$_->diskDelete}else {push@keep,$_}}}unless(@destroy || $self->isModified){$self->log(PROGRESS=>"Folder $self not changed, so not updated.");return$self}$args{messages}=\@keep;unless($self->writeMessages(\%args)){$self->log(WARNING=>"Writing folder $self failed.");return undef}$self->modified(0);$self->{MB_messages}=\@keep;$self}sub determineBodyType($$) {my ($self,$message,$head)=@_;return$self->{MB_body_delayed_type}if$self->{MB_lazy_permitted}&&!$message->isPart &&!$self->{MB_extract}->($self,$head);my$bodytype=$self->{MB_body_type};ref$bodytype ? $bodytype->($head): $bodytype}sub extractDefault($) {my ($self,$head)=@_;my$size=$head->guessBodySize;defined$size ? $size < 10000 : 0}sub lazyPermitted($) {my$self=shift;$self->{MB_lazy_permitted}=shift}sub storeMessage($) {my ($self,$message)=@_;push @{$self->{MB_messages}},$message;$message->seqnr(@{$self->{MB_messages}}-1);$message}my%seps=(CR=>"\015",LF=>"\012",CRLF=>"\015\012");sub lineSeparator(;$) {my$self=shift;return$self->{MB_linesep}unless @_;my$sep=shift;$sep=$seps{$sep}if exists$seps{$sep};$self->{MB_linesep}=$sep;$_->lineSeparator($sep)foreach$self->messages;$sep}sub create($@) {shift->notImplemented}sub coerce($@) {my ($self,$message)=(shift,shift);my$mmtype=$self->{MB_message_type};$message->isa($mmtype)? $message : $mmtype->coerce($message,@_)}sub readMessages(@) {shift->notImplemented}sub updateMessages(@) {shift}sub writeMessages(@) {shift->notImplemented}sub locker() {shift->{MB_locker}}sub toBeThreaded(@) {my$self=shift;my$manager=$self->{MB_manager}or return$self;$manager->toBeThreaded($self,@_);$self}sub toBeUnthreaded(@) {my$self=shift;my$manager=$self->{MB_manager}or return$self;$manager->toBeThreaded($self,@_);$self}sub timespan2seconds($) {if($_[1]=~ /^\s*(\d+\.?\d*|\.\d+)\s*(hour|day|week)s?\s*$/){$2 eq 'hour' ? $1 * 3600 : $2 eq 'day' ? $1 * 86400 : $1 * 604800}else {$_[0]->log(ERROR=>"Invalid timespan '$_' specified.");undef}}sub DESTROY {my$self=shift;$self->close unless in_global_destruction || $self->{MB_is_closed}}1;
MAIL_BOX

$fatpacked{"Mail/Box/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_COLLECTION';
  package Mail::Box::Collection;use vars '$VERSION';$VERSION='3.007';use base qw/User::Identity::Collection Mail::Reporter/;use strict;use warnings;use Mail::Box::Identity;use Scalar::Util qw/weaken/;sub new(@) {my$class=shift;unshift @_,'name' if @_ % 2;$class->Mail::Reporter::new(@_)}sub init($) {my ($self,$args)=@_;$args->{item_type}||='Mail::Box::Identity';$self->Mail::Reporter::init($args);$self->User::Identity::Collection::init($args);weaken($self->{MBC_manager})if$self->{MBC_manager}=delete$args->{manager};$self->{MBC_ftype}=delete$args->{folder_type};$self}sub type() {'folders'}sub manager() {my$self=shift;return$self->{MBC_manager}if defined$self->{MBC_manager};my$parent=$self->parent;defined$parent ? $self->parent->manager : undef}sub folderType() {my$self=shift;return($self->{MBC_ftype}=shift)if @_;return$self->{MBC_ftype}if exists$self->{MBC_ftype};if(my$parent=$self->parent){return$self->{MBC_ftype}=$parent->folderType}undef}1;
MAIL_BOX_COLLECTION

$fatpacked{"Mail/Box/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_DIR';
  package Mail::Box::Dir;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box';use strict;use warnings;use filetest 'access';use Mail::Box::Dir::Message;use Mail::Message::Body::Lines;use Mail::Message::Body::File;use Mail::Message::Body::Delayed;use Mail::Message::Body::Multipart;use Mail::Message::Head;use Mail::Message::Head::Delayed;use Carp;use File::Copy;use File::Spec;use File::Basename;sub init($) {my ($self,$args)=@_;$args->{body_type}||=sub {'Mail::Message::Body::Lines'};return undef unless$self->SUPER::init($args);my$class=ref$self;my$directory=$self->{MBD_directory}=$args->{directory}|| $self->directory;if(-d $directory){}elsif($args->{create}&& $class->create($directory,%$args)){}else {$self->log(NOTICE=>"No directory $directory for folder of $class");return undef}for($args->{lock_file}){$self->locker->filename (!defined $_ ? File::Spec->catfile($directory,'.lock'): File::Spec->file_name_is_absolute($_)? $_ : File::Spec->catfile($directory,$_))}if($self->writable && -e $directory &&!-w $directory){$self->log(WARNING=>"Folder directory $directory is write-protected.");$self->{MB_access}='r'}$self}sub organization() {'DIRECTORY'}sub directory() {my$self=shift;$self->{MBD_directory}||=$self->folderToDirectory($self->name,$self->folderdir)}sub nameOfSubFolder($;$) {my ($thing,$name)=(shift,shift);my$parent=@_ ? shift : ref$thing ? $thing->directory : undef;defined$parent ? "$parent/$name" : $name}sub folderToDirectory($$) {my ($class,$name,$folderdir)=@_;my$dir=($name =~ m#^=\/?(.*)# ? "$folderdir/$1" : $name);$dir =~ s!/$!!;$dir}sub readMessageFilenames() {shift->notImplemented}1;
MAIL_BOX_DIR

$fatpacked{"Mail/Box/Dir/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_DIR_MESSAGE';
  package Mail::Box::Dir::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Message';use strict;use warnings;use File::Copy qw/move/;use IO::File;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->filename($args->{filename})if$args->{filename};$self->{MBDM_fix_header}=$args->{fix_header};$self}sub print(;$) {my$self=shift;my$out=shift || select;return$self->SUPER::print($out)if$self->isModified;my$filename=$self->filename;if($filename && -r $filename){if(open my$in,'<:raw',$filename){local $_;print$out $_ while <$in>;close$in;return$self}}$self->SUPER::print($out);1}BEGIN {*write=\&print}sub filename(;$) {my$self=shift;@_ ? ($self->{MBDM_filename}=shift): $self->{MBDM_filename}}sub size() {my$self=shift;unless($self->isModified){my$filename=$self->filename;if(defined$filename){my$size=-s $filename;return$size if defined$size}}$self->SUPER::size}sub diskDelete() {my$self=shift;$self->SUPER::diskDelete;my$filename=$self->filename;unlink$filename if$filename;$self}sub parser() {my$self=shift;my$parser=Mail::Box::Parser->new (filename=>$self->{MBDM_filename},mode=>'r' ,fix_header_errors=>$self->{MBDM_fix_header},$self->logSettings);unless($parser){$self->log(ERROR=>"Cannot create parser for $self->{MBDM_filename}.");return}$parser}sub loadHead() {my$self=shift;my$head=$self->head;return$head unless$head->isDelayed;my$folder=$self->folder;$folder->lazyPermitted(1);my$parser=$self->parser or return;$self->readFromParser($parser);$parser->stop;$folder->lazyPermitted(0);$self->log(PROGRESS=>'Loaded delayed head.');$self->head}sub loadBody() {my$self=shift;my$body=$self->body;return$body unless$body->isDelayed;my$head=$self->head;my$parser=$self->parser or return;if($head->isDelayed){$head=$self->readHead($parser);if(defined$head){$self->log(PROGRESS=>'Loaded delayed head.');$self->head($head)}else {$self->log(ERROR=>'Unable to read delayed head.');return}}else {my ($begin,$end)=$body->fileLocation;$parser->filePosition($begin)}my$newbody=$self->readBody($parser,$head);$parser->stop;unless(defined$newbody){$self->log(ERROR=>'Unable to read delayed body.');return}$self->log(PROGRESS=>'Loaded delayed body.');$self->storeBody($newbody->contentInfoFrom($head))}sub create($) {my ($self,$filename)=@_;my$old=$self->filename || '';return$self if$filename eq $old &&!$self->isModified;my$new=$filename .'.new';my$newfile=IO::File->new($new,'w');$self->log(ERROR=>"Cannot write message to $new: $!"),return unless$newfile;$self->write($newfile);$newfile->close;unlink$old if$old;$self->log(ERROR=>"Failed to move $new to $filename: $!"),return unless move($new,$filename);$self->modified(0);$self->Mail::Box::Dir::Message::filename($filename);$self}1;
MAIL_BOX_DIR_MESSAGE

$fatpacked{"Mail/Box/FastScalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_FASTSCALAR';
  package Mail::Box::FastScalar;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use integer;sub new($) {my ($class,$ref)=@_;$$ref='' unless defined $$ref;bless {ref=>$ref,pos=>0 },$class}sub autoflush() {}sub binmode() {}sub clearerr {return 0}sub flush() {}sub sync() {return 0}sub opened() {return $_[0]->{ref}}sub open($) {my$self=$_[0];${$_[1]}='' unless defined(${$_[1]});$self->{ref}=$_[1];$self->{pos}=0}sub close() {undef $_[0]->{ref}}sub eof() {my$self=$_[0];return$self->{pos}>= length(${$self->{ref}})}sub getc() {my$self=$_[0];return substr(${$self->{ref}},$self->{pos}++,1)}sub print {my$self=shift;my$pos=$self->{pos};my$ref=$self->{ref};my$len=length($$ref);if ($pos >= $len){$$ref .= $_ foreach @_;$self->{pos}=length($$ref)}else {my$buf=$#_ ? join('',@_): $_[0];$len=length($buf);substr($$ref,$pos,$len)=$buf;$self->{pos}=$pos + $len}1}sub read($$;$) {my$self=$_[0];my$buf=substr(${$self->{ref}},$self->{pos},$_[2]);$self->{pos}+= $_[2];($_[3]? substr($_[1],$_[3]): $_[1])=$buf;return length($buf)}sub sysread($$;$) {return shift()->read(@_)}sub seek($$) {my$self=$_[0];my$whence=$_[2];my$len=length(${$self->{ref}});if ($whence==0){$self->{pos}=$_[1]}elsif ($whence==1){$self->{pos}+= $_[1]}elsif ($whence==2){$self->{pos}=$len + $_[1]}else {return}if ($self->{pos}> $len){$self->{pos}=$len}elsif ($self->{pos}< 0){$self->{pos}=0}return 1}sub sysseek($$) {return $_[0]->seek($_[1],$_[2])}sub setpos($) {return $_[0]->seek($_[1],0)}sub sref() {return $_[0]->{ref}}sub getpos() {return $_[0]->{pos}}sub tell() {return $_[0]->{pos}}sub write($$;$) {my$self=$_[0];my$pos=$self->{pos};my$ref=$self->{ref};my$len=length($$ref);if ($pos >= $len){$$ref .= substr($_[1],$_[3]|| 0,$_[2]);$self->{pos}=length($$ref);$len=$self->{pos}- $len}else {my$buf=substr($_[1],$_[3]|| 0,$_[2]);$len=length($buf);substr($$ref,$pos,$len)=$buf;$self->{pos}=$pos + $len}return$len}sub syswrite($;$$) {return shift()->write(@_)}sub getline() {my$self=$_[0];my$ref=$self->{ref};my$pos=$self->{pos};if (!defined($/)|| (my$idx=index($$ref,$/,$pos))==-1){return if ($pos >= length($$ref));$self->{pos}=length($$ref);return substr($$ref,$pos)}else {return substr($$ref,$pos,($self->{pos}=$idx + length($/))- $pos)}}sub getlines() {my$self=$_[0];my@lines;my$ref=$self->{ref};my$pos=$self->{pos};if (defined($/)){my$idx;while (($idx=index($$ref,$/,$pos))!=-1){push(@lines,substr($$ref,$pos,($idx + 1)- $pos));$pos=$idx + 1}}my$r=substr($$ref,$pos);if (length($r)> 0){push(@lines,$r)}$self->{pos}=length($$ref);return wantarray()? @lines : \@lines}sub TIEHANDLE {((defined($_[1])&& UNIVERSAL::isa($_[1],"Mail::Box::FastScalar"))? $_[1]: shift->new(@_))}sub GETC {shift()->getc(@_)}sub PRINT {shift()->print(@_)}sub PRINTF {shift()->print(sprintf(shift,@_))}sub READ {shift()->read(@_)}sub READLINE {wantarray ? shift()->getlines(@_): shift()->getline(@_)}sub WRITE {shift()->write(@_)}sub CLOSE {shift()->close(@_)}sub SEEK {shift()->seek(@_)}sub TELL {shift()->tell(@_)}sub EOF {shift()->eof(@_)}1;1;
MAIL_BOX_FASTSCALAR

$fatpacked{"Mail/Box/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_FILE';
  package Mail::Box::File;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box';use strict;use warnings;use filetest 'access';use Mail::Box::File::Message;use Mail::Message::Body::Lines;use Mail::Message::Body::File;use Mail::Message::Body::Delayed;use Mail::Message::Body::Multipart;use Mail::Message::Head;use Carp;use File::Copy;use File::Spec;use File::Basename;use POSIX ':unistd_h';use IO::File;my$windows;BEGIN {$windows=$^O =~ m/mswin32/i}my$default_folder_dir=exists$ENV{HOME}? $ENV{HOME}.'/Mail' : '.';sub _default_body_type($$) {my$size=shift->guessBodySize || 0;'Mail::Message::Body::'.($size > 100000 ? 'File' : 'Lines')}sub init($) {my ($self,$args)=@_;$args->{folderdir}||=$default_folder_dir;$args->{body_type}||=\&_default_body_type;$args->{lock_file}||='--';defined$self->SUPER::init($args)or return;my$class=ref$self;my$filename=$self->{MBF_filename}=$self->folderToFilename ($self->name ,$self->folderdir);if(-e $filename){}elsif($args->{create}&& $class->create($args->{folder},%$args)){}else {$self->log(PROGRESS=>"File $filename for folder $self does not exist.");return}$self->{MBF_policy}=$args->{write_policy};my$locker=$self->locker;my$lockfile=$locker->filename;if($lockfile eq '--'){my$lockdir=$filename;$lockdir =~ s!/([^/]*)$!!;my$extension=$args->{lock_extension}|| '.lock';$locker->filename (File::Spec->file_name_is_absolute($extension)? $extension : $extension =~ m!^\.! ? "$filename$extension" : File::Spec->catfile($lockdir,$extension))}unless($locker->lock){$self->log(ERROR=>"Cannot get a lock on $class folder $self.");return}if($self->writable &&!-w $filename){$self->log(WARNING=>"Folder $self file $filename is write-protected.");$self->{MB_access}='r'}$self->{MB_access}!~ m/r/ ? $self : $self->parser ? $self : undef}sub create($@) {my ($thingy,$name,%args)=@_;my$class=ref$thingy || $thingy;my$folderdir=$args{folderdir}|| $default_folder_dir;my$subext=$args{subfolder_extension};my$filename=$class->folderToFilename($name,$folderdir,$subext);return$class if -f $filename;my$dir=dirname$filename;if(-f $dir && defined$subext){$dir .= $subext;$filename=File::Spec->catfile($dir,basename$filename)}$class->log(ERROR=>"Cannot create directory $dir for folder $name: $!"),return unless -d $dir || mkdir$dir,0755;$class->moveAwaySubFolder($filename,$subext)if -d $filename && defined$subext;my$create=IO::File->new($filename,'w');unless($create){$class->log(WARNING=>"Cannot create folder file $name: $!");return}$class->log(PROGRESS=>"Created folder $name.");$create->close or return;$class}sub foundIn($@) {my$class=shift;my$name=@_ % 2 ? shift : undef;my%args=@_;$name ||=$args{folder}or return;my$folderdir=$args{folderdir}|| $default_folder_dir;my$filename=$class->folderToFilename($name,$folderdir);-f $filename}sub organization() {'FILE'}sub size() {my$self=shift;$self->isModified ? $self->SUPER::size : -s $self->filename}sub close(@) {my$self=$_[0];undef $_[0];shift;my$rc=$self->SUPER::close(@_);if(my$parser=delete$self->{MBF_parser}){$parser->stop}$rc}sub appendMessages(@) {my$class=shift;my%args=@_;my@messages =exists$args{message}? $args{message}: exists$args{messages}? @{$args{messages}}: return ();my$folder=$class->new(lock_type=>'NONE',@_,access=>'w+')or return ();my$filename=$folder->filename;my$out=IO::File->new($filename,'a');unless($out){$class->log(ERROR=>"Cannot append messages to folder file $filename: $!");return ()}my$msgtype=$class.'::Message';my@coerced;for my$msg (@messages){my$coerced =$msg->isa($msgtype)? $msg : $msg->can('clone')? $msgtype->coerce($msg->clone): $msgtype->coerce($msg);$coerced->write($out);push@coerced,$coerced}my$ok=$folder->close;$out->close && $ok or return 0;@coerced}sub filename() {shift->{MBF_filename}}sub parser() {my$self=shift;return$self->{MBF_parser}if defined$self->{MBF_parser};my$source=$self->filename;my$mode=$self->{MB_access}|| 'r';$mode='r+' if$mode eq 'rw' || $mode eq 'a';my$parser=$self->{MBF_parser}=Mail::Box::Parser->new (filename=>$source ,mode=>$mode ,trusted=>$self->{MB_trusted},fix_header_errors=>$self->{MB_fix_headers},$self->logSettings)or return;$parser->pushSeparator('From ');$parser}sub readMessages(@) {my ($self,%args)=@_;$self->messageCreateOptions ($args{message_type},$self->logSettings ,folder=>$self ,head_type=>$args{head_type},field_type=>$args{field_type},trusted=>$args{trusted});$self->updateMessages}sub updateMessages(@) {my ($self,%args)=@_;my$parser=$self->parser or return;my$filename=$self->filename;return$self if -d $filename;if(my$last=$self->message(-1)){(undef,my$end)=$last->fileLocation;$parser->filePosition($end)}my ($type,@msgopts)=$self->messageCreateOptions;my$count=0;while(1){my$message=$type->new(@msgopts);last unless$message->readFromParser($parser);$self->storeMessage($message);$count++}$self->log(PROGRESS=>"Found $count new messages in $filename")if$count;$self}sub messageCreateOptions(@) {my ($self,@options)=@_;if(@options){ref($_)&& ref($_)=~ m/^Mail::/ && weaken $_ for@options;$self->{MBF_create_options}=\@options}@{$self->{MBF_create_options}}}sub moveAwaySubFolder($$) {my ($self,$dir,$extension)=@_;$self->log(ERROR=>"Cannot move away sub-folder $dir")unless move$dir,$dir.$extension;$self}sub delete(@) {my$self=shift;$self->SUPER::delete(@_);unlink$self->filename}sub writeMessages($) {my ($self,$args)=@_;my$filename=$self->filename;if(!@{$args->{messages}}&& $self->{MB_remove_empty}){$self->log(WARNING=>"Cannot remove folder $self file $filename: $!")unless unlink$filename;return$self}my$policy=exists$args->{policy}? $args->{policy}: $self->{MBF_policy};$policy ||='';my$success =!-e $filename ? $self->_write_new($args): $policy eq 'INPLACE' ? $self->_write_inplace($args): $policy eq 'REPLACE' ? $self->_write_replace($args): $self->_write_replace($args)? 1 : $self->_write_inplace($args);unless($success){$self->log(ERROR=>"Unable to update folder $self.");return}$self}sub _write_new($) {my ($self,$args)=@_;my$filename=$self->filename;my$new=IO::File->new($filename,'w');return 0 unless defined$new;$new->binmode;$_->write($new)foreach @{$args->{messages}};$new->close or return 0;$self->log(PROGRESS=>"Wrote new folder $self with ".@{$args->{messages}}."msgs.");1}sub _write_replace($) {my ($self,$args)=@_;my$filename=$self->filename;my$tmpnew=$self->tmpNewFolder($filename);my$new=IO::File->new($tmpnew,'w')or return 0;$new->binmode;my$old=IO::File->new($filename,'r')or return 0;$old->binmode;my ($reprint,$kept)=(0,0);for my$message (@{$args->{messages}}){my$newbegin=$new->tell;my$oldbegin=$message->fileLocation;if($message->isModified){$message->write($new);$message->moveLocation($newbegin - $oldbegin)if defined$oldbegin;$reprint++;next}my ($begin,$end)=$message->fileLocation;my$need=$end-$begin;$old->seek($begin,0);my$whole;my$size=$old->read($whole,$need);$self->log(ERROR=>"File too short to get write message " .$message->seqnr." ($size, $need)")unless$size==$need;$new->print($whole);$new->print($Mail::Message::crlf_platform ? "\r\n" : "\n");$message->moveLocation($newbegin - $oldbegin);$kept++}my$ok=$new->close;$old->close && $ok or return 0;if($windows){unlink$filename;$self->parser->closeFile}unless(move$tmpnew,$filename){$self->log(WARNING=>"Cannot replace $filename by $tmpnew, to update folder $self: $!");unlink$tmpnew;return 0}$self->log(PROGRESS=>"Folder $self replaced ($kept, $reprint)");1}sub _write_inplace($) {my ($self,$args)=@_;my@messages=@{$args->{messages}};my$last;my ($msgnr,$kept)=(0,0);while(@messages){my$next=$messages[0];last if$next->isModified || $next->seqnr!=$msgnr++;$last=shift@messages;$kept++}if(@messages==0 && $msgnr==$self->messages){$self->log(PROGRESS=>"No changes to be written to $self.");return 1}$_->body->load foreach@messages;my$mode=$^O eq 'MSWin32' ? 'a' : 'r+';my$filename=$self->filename;my$old=IO::File->new($filename,$mode)or return 0;my$end=defined$last ? ($last->fileLocation)[1]: 0;$end =~ m/(.*)/;$end=$1;unless($old->truncate($end)){$old->close;return 0}unless(@messages){$old->close or return 0;$self->log(PROGRESS=>"Folder $self shortened in-place ($kept kept)");return 1}$old->seek(0,2);my$printed=@messages;for my$message (@messages){my$oldbegin=$message->fileLocation;my$newbegin=$old->tell;$message->write($old);$message->moveLocation($newbegin - $oldbegin)}$old->close or return 0;$self->log(PROGRESS=>"Folder $self updated in-place ($kept, $printed)");1}sub folderToFilename($$;$) {my ($thing,$name,$folderdir)=@_;substr$name,0,1,$folderdir if substr$name,0,1 eq '=';$name}sub tmpNewFolder($) {shift->filename .'.tmp'}1;
MAIL_BOX_FILE

$fatpacked{"Mail/Box/File/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_FILE_MESSAGE';
  package Mail::Box::File::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Message';use strict;use warnings;use List::Util qw/sum/;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->fromLine($args->{from_line})if exists$args->{from_line};$self}sub coerce($) {my ($self,$message)=@_;return$message if$message->isa(__PACKAGE__);$self->SUPER::coerce($message)->labelsToStatus}sub write(;$) {my$self=shift;my$out=shift || select;my$escaped=$self->escapedBody;$out->print($self->fromLine);my$size=sum 0,map {length($_)}@$escaped;my$head=$self->head;$head->set('Content-Length'=>$size);$head->set('Lines'=>scalar @$escaped);$head->print($out);$out->print($_)for @$escaped;$out->print("\n");$self}sub clone() {my$self=shift;my$clone=$self->SUPER::clone;$clone->{MBMM_from_line}=$self->{MBMM_from_line};$clone}sub fromLine(;$) {my$self=shift;$self->{MBMM_from_line}=shift if @_;$self->{MBMM_from_line}||=$self->head->createFromLine}sub escapedBody() {my@lines=shift->body->lines;s/^(\>*From )/>$1/ for@lines;\@lines}sub readFromParser($) {my ($self,$parser)=@_;my ($start,$fromline)=$parser->readSeparator;return unless$fromline;$self->{MBMM_from_line}=$fromline;$self->{MBMM_begin}=$start;$self->SUPER::readFromParser($parser)or return;$self}sub loadHead() {shift->head}sub loadBody() {my$self=shift;my$body=$self->body;return$body unless$body->isDelayed;my ($begin,$end)=$body->fileLocation;my$parser=$self->folder->parser;$parser->filePosition($begin);my$newbody=$self->readBody($parser,$self->head);unless($newbody){$self->log(ERROR=>'Unable to read delayed body.');return}$self->log(PROGRESS=>'Loaded delayed body.');$self->storeBody($newbody->contentInfoFrom($self->head));$newbody}sub fileLocation() {my$self=shift;wantarray ? ($self->{MBMM_begin},($self->body->fileLocation)[1]): $self->{MBMM_begin}}sub moveLocation($) {my ($self,$dist)=@_;$self->{MBMM_begin}-= $dist;$self->head->moveLocation($dist);$self->body->moveLocation($dist);$self}1;
MAIL_BOX_FILE_MESSAGE

$fatpacked{"Mail/Box/Identity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_IDENTITY';
  package Mail::Box::Identity;use vars '$VERSION';$VERSION='3.007';use base qw/User::Identity::Item Mail::Reporter/;use strict;use warnings;use Mail::Box::Collection;sub type {"mailbox"}sub new(@) {my$class=shift;unshift @_,'name' if @_ % 2;$class->Mail::Reporter::new(@_)}sub init($) {my ($self,$args)=@_;$self->Mail::Reporter::init($args);$self->User::Identity::init($args);$self->{MBI_location}=delete$args->{location};$self->{MBI_ftype}=delete$args->{folder_type};$self->{MBI_manager}=delete$args->{manager};$self->{MBI_subf_type}=delete$args->{subf_type}||'Mail::Box::Collection';$self->{MBI_only_subs}=delete$args->{only_subs};$self->{MBI_marked}=delete$args->{marked};$self->{MBI_deleted}=delete$args->{deleted};$self->{MBI_inferiors}=exists$args->{inferiors}? $args->{inferiors}: 1;$self}sub fullname(;$) {my$self=shift;my$delim=@_ && defined $_[0]? shift : '/';my$parent=$self->parent or return$self->name;$parent->parent->fullname($delim).$delim .$self->name}sub location(;$) {my$self=shift;return ($self->{MBI_location}=shift)if @_;return$self->{MBI_location}if defined$self->{MBI_location};my$parent=$self->parent;unless(defined$parent){$self->log(ERROR=>"Toplevel directory requires explicit location");return undef}$self->folderType ->nameOfSubFolder($self->name,$parent->parent->location)}sub folderType() {my$self=shift;return$self->{MBI_ftype}if defined$self->{MBI_ftype};my$parent=$self->parent;unless(defined$parent){$self->log(ERROR=>"Toplevel directory requires explicit folder type");return undef}$parent->parent->folderType}sub manager() {my$self=shift;return$self->{MBI_manager}if$self->{MBI_manager};my$parent=$self->parent or return undef;$self->parent->manager}sub topfolder() {my$self=shift;my$parent=$self->parent or return$self;$parent->parent->topfolder}sub onlySubfolders(;$) {my$self=shift;return($self->{MBI_only_subs}=shift)if @_;return$self->{MBI_only_subs}if exists$self->{MBI_only_subs};$self->parent ? 1 :!$self->folderType->topFolderWithMessages}sub marked(;$) {my$self=shift;@_ ? ($self->{MBI_marked}=shift): $self->{MBI_marked}}sub inferiors(;$) {my$self=shift;@_ ? ($self->{MBI_inferiors}=shift): $self->{MBI_inferiors}}sub deleted(;$) {my$self=shift;@_ ? ($self->{MBI_deleted}=shift): $self->{MBI_deleted}}sub subfolders() {my$self=shift;my$subs=$self->collection('subfolders');return (wantarray ? $subs->roles : $subs)if defined$subs;my@subs;if(my$location=$self->location){@subs=$self->folderType->listSubFolders (folder=>$location)}else {my$mgr=$self->manager;my$top=defined$mgr ? $mgr->folderdir : '.';@subs=$self->folderType->listSubFolders (folder=>$self->fullname ,folderdir=>$top)}@subs or return ();my$subf_type =$self->{MBI_subf_type}|| ref($self->parent)|| 'Mail::Box::Collection';$subs=$subf_type->new('subfolders');$self->addCollection($subs);$subs->addRole(name=>$_)for@subs;wantarray ? $subs->roles : $subs}sub subfolderNames() {map {$_->name}shift->subfolders}sub folder(@) {my$self=shift;return$self unless @_ && defined $_[0];my$subs=$self->subfolders or return undef;my$nest=$subs->find(shift)or return undef;$nest->folder(@_)}sub open(@) {my$self=shift;$self->manager->open($self->fullname,type=>$self->folderType,@_)}sub foreach($) {my ($self,$code)=@_;$code->($self);my$subs=$self->subfolders or return ();$_->foreach($code)for$subs->sorted;$self}sub addSubfolder(@) {my$self=shift;my$subs=$self->subfolders;if(defined$subs){}elsif(!$self->inferiors){my$name=$self->fullname;$self->log(ERROR=>"It is not permitted to add subfolders to $name");return undef}else {$subs=$self->{MBI_subf_type}->new('subfolders');$self->addCollection($subs)}$subs->addRole(@_)}sub remove(;$) {my$self=shift;my$parent=$self->parent;unless(defined$parent){$self->log(ERROR=>"The toplevel folder cannot be removed this way");return ()}return$parent->removeRole($self->name)unless @_;my$name=shift;my$subs=$self->subfolders or return ();$subs->removeRole($name)}sub rename($;$) {my ($self,$folder,$newname)=@_;$newname=$self->name unless defined$newname;my$away=$self->remove;$away->name($newname);$folder->addSubfolder($away)}1;
MAIL_BOX_IDENTITY

$fatpacked{"Mail/Box/Locker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER';
  package Mail::Box::Locker;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Carp;use Scalar::Util 'weaken';use Devel::GlobalDestruction 'in_global_destruction';my%lockers=(DOTLOCK=>__PACKAGE__ .'::DotLock' ,FCNTLLOCK=>__PACKAGE__ .'::FcntlLock' ,FLOCK=>__PACKAGE__ .'::Flock' ,MULTI=>__PACKAGE__ .'::Multi' ,MUTT=>__PACKAGE__ .'::Mutt' ,NFS=>__PACKAGE__ .'::NFS' ,NONE=>__PACKAGE__ ,POSIX=>__PACKAGE__ .'::POSIX');sub new(@) {my$class=shift;return$class->SUPER::new(@_)unless$class eq __PACKAGE__;my%args=@_;my$method=!defined$args{method}? 'DOTLOCK' : ref$args{method}eq 'ARRAY' ? 'MULTI' : uc$args{method};my$create=$lockers{$method}|| $args{$method};local $"=' or ';confess "No locking method $method defined: use @{[ keys %lockers ]}" unless$create;eval "require $create";confess $@ if $@;$args{use}=$args{method}if ref$args{method}eq 'ARRAY';$create->SUPER::new(%args)}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBL_expires}=$args->{expires}|| 3600;$self->{MBL_timeout}=$args->{timeout}|| 10;$self->{MBL_filename}=$args->{file}|| $args->{folder}->name;$self->{MBL_has_lock}=0;$self->folder($args->{folder});$self}sub timeout(;$) {my$self=shift;@_ ? $self->{MBL_timeout}=shift : $self->{MBL_timeout}}sub expires(;$) {my$self=shift;@_ ? $self->{MBL_expires}=shift : $self->{MBL_expires}}sub name {shift->notImplemented}sub lockMethod($$$$) {confess "Method removed: use inheritance to implement own method."}sub folder(;$) {my$self=shift;@_ && $_[0]or return$self->{MBL_folder};$self->{MBL_folder}=shift;weaken$self->{MBL_folder}}sub filename(;$) {my$self=shift;$self->{MBL_filename}=shift if @_;$self->{MBL_filename}}sub lock($) {shift->{MBL_has_lock}=1}sub isLocked($) {0}sub hasLock() {shift->{MBL_has_lock}}sub unlock() {shift->{MBL_has_lock}=0}sub DESTROY() {my$self=shift;return$self if in_global_destruction;$self->unlock if$self->hasLock;$self->SUPER::DESTROY;$self}1;
MAIL_BOX_LOCKER

$fatpacked{"Mail/Box/Locker/DotLock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_DOTLOCK';
  package Mail::Box::Locker::DotLock;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use IO::File;use File::Spec;use Errno qw/EEXIST/;use Carp;sub init($) {my ($self,$args)=@_;$args->{file}=$args->{dotlock_file}if$args->{dotlock_file};$self->SUPER::init($args)}sub name() {'DOTLOCK'}sub folder(;$) {my$self=shift;@_ && $_[0]or return$self->SUPER::folder;my$folder=shift;unless(defined$self->filename){my$org=$folder->organization;my$filename =$org eq 'FILE' ? $folder->filename .'.lock' : $org eq 'DIRECTORY'? File::Spec->catfile($folder->directory,'.lock'): croak "Need lock file name for DotLock.";$self->filename($filename)}$self->SUPER::folder($folder)}sub _try_lock($) {my ($self,$lockfile)=@_;return if -e $lockfile;my$flags=$^O eq 'MSWin32' ? O_CREAT|O_EXCL|O_WRONLY : O_CREAT|O_EXCL|O_WRONLY|O_NONBLOCK;my$lock=IO::File->new($lockfile,$flags,0600);if($lock){close$lock;return 1}if($!!=EEXIST){$self->log(ERROR=>"lockfile $lockfile can never be created: $!");return 1}}sub unlock() {my$self=shift;$self->hasLock or return$self;my$lock=$self->filename;unlink$lock or $self->log(WARNING=>"Couldn't remove lockfile $lock: $!");$self->SUPER::unlock;$self}sub lock() {my$self=shift;my$lockfile=$self->filename;if($self->hasLock){$self->log(WARNING=>"Folder already locked with file $lockfile");return 1}my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;my$expire=$self->expires/86400;while(1){return$self->SUPER::lock if$self->_try_lock($lockfile);if(-e $lockfile && -A $lockfile > $expire){if(unlink$lockfile){$self->log(WARNING=>"Removed expired lockfile $lockfile");redo}else {$self->log(ERROR=>"Failed to remove expired lockfile $lockfile: $!");last}}last unless --$end;sleep 1}return 0}sub isLocked() {-e shift->filename}1;
MAIL_BOX_LOCKER_DOTLOCK

$fatpacked{"Mail/Box/Locker/FcntlLock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_FCNTLLOCK';
  package Mail::Box::Locker::FcntlLock;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use Fcntl;use IO::File;use Errno qw/EAGAIN/;use File::FcntlLock;sub init($) {my ($self,$args)=@_;$args->{file}=$args->{posix_file}if$args->{posix_file};$self->SUPER::init($args)}sub name() {'FcntlLock'}sub _try_lock($) {my ($self,$file)=@_;my$fl=File::FcntlLock->new;$fl->l_type(F_WRLCK);$?=$fl->lock($file,F_SETLK);$?==0}sub _unlock($) {my ($self,$file)=@_;my$fl=File::FcntlLock->new;$fl->l_type(F_UNLCK);$fl->lock($file,F_SETLK);$self}sub lock() {my$self=shift;if($self->hasLock){my$folder=$self->folder;$self->log(WARNING=>"Folder $folder already lockf'd");return 1}my$filename=$self->filename;my$file=IO::File->new($filename,'r+');unless(defined$file){my$folder=$self->folder;$self->log(ERROR=>"Unable to open FcntlLock lock file $filename for $folder: $!");return 0}my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;while(1){if($self->_try_lock($file)){$self->SUPER::lock;$self->{MBLF_filehandle}=$file;return 1}unless($!==EAGAIN){my$folder=$self->folder;$self->log(ERROR=>"Will never get a FcntlLock lock on $filename for $folder: $!");last}last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;my$filename=$self->filename;my$file=IO::File->new($filename,"r");unless($file){my$folder=$self->folder;$self->log(ERROR=>"Unable to check lock file $filename for $folder: $!");return 0}$self->_try_lock($file)==0 or return 0;$self->_unlock($file);$file->close;$self->SUPER::unlock;1}sub unlock() {my$self=shift;$self->_unlock(delete$self->{MBLF_filehandle})if$self->hasLock;$self->SUPER::unlock;$self}1;
MAIL_BOX_LOCKER_FCNTLLOCK

$fatpacked{"Mail/Box/Locker/Flock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_FLOCK';
  package Mail::Box::Locker::Flock;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use IO::File;use Fcntl qw/:DEFAULT :flock/;use Errno qw/EAGAIN/;sub name() {'FLOCK'}sub _try_lock($) {my ($self,$file)=@_;flock$file,LOCK_EX|LOCK_NB}sub _unlock($) {my ($self,$file)=@_;flock$file,LOCK_UN;$self}my$lockfile_access_mode=($^O eq 'solaris' || $^O eq 'aix')? 'r+' : 'r';sub lock() {my$self=shift;my$folder=$self->folder;if($self->hasLock){$self->log(WARNING=>"Folder $folder already flocked.");return 1}my$filename=$self->filename;my$file=IO::File->new($filename,$lockfile_access_mode);unless($file){$self->log(ERROR=>"Unable to open flock file $filename for $folder: $!");return 0}my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;while(1){if($self->_try_lock($file)){$self->{MBLF_filehandle}=$file;return$self->SUPER::lock}if($!!=EAGAIN){$self->log(ERROR=>"Will never get a flock on $filename for $folder: $!");last}last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;my$filename=$self->filename;my$file=IO::File->new($filename,$lockfile_access_mode);unless($file){my$folder=$self->folder;$self->log(ERROR=>"Unable to check lock file $filename for $folder: $!");return 0}$self->_try_lock($file)or return 0;$self->_unlock($file);$file->close;$self->SUPER::unlock;1}sub unlock() {my$self=shift;$self->_unlock(delete$self->{MBLF_filehandle})if$self->hasLock;$self->SUPER::unlock;$self}1;
MAIL_BOX_LOCKER_FLOCK

$fatpacked{"Mail/Box/Locker/Multi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_MULTI';
  package Mail::Box::Locker::Multi;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);my@use =exists$args->{use}? @{delete$args->{use}}: $^O eq 'MSWin32' ? qw/Flock/ : qw/NFS FcntlLock Flock/;my (@lockers,@used);for my$method (@use){if(UNIVERSAL::isa($method,'Mail::Box::Locker')){push@lockers,$method;(my$used=ref$method)=~ s/.*\:\://;push@used,$used;next}my$locker=eval {Mail::Box::Locker->new (%$args ,method=>$method ,timeout=>1)};next unless defined$locker;push@lockers,$locker;push@used,$method}$self->{MBLM_lockers}=\@lockers;$self->log(PROGRESS=>"Multi-locking via @used.");$self}sub name() {'MULTI'}sub _try_lock($) {my$self=shift;my@successes;for my$locker ($self->lockers){unless($locker->lock){$_->unlock foreach@successes;return 0}push@successes,$locker}1}sub unlock() {my$self=shift;$self->hasLock or return$self;$_->unlock foreach$self->lockers;$self->SUPER::unlock;$self}sub lock() {my$self=shift;return 1 if$self->hasLock;my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;while(1){return$self->SUPER::lock if$self->_try_lock;last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;$self->_try_lock($self->filename)or return 0;$self->unlock;1}sub lockers() {@{shift->{MBLM_lockers}}}1;
MAIL_BOX_LOCKER_MULTI

$fatpacked{"Mail/Box/Locker/Mutt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_MUTT';
  package Mail::Box::Locker::Mutt;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use POSIX qw/sys_wait_h/;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBLM_exe}=$args->{exe}|| 'mutt_dotlock';$self}sub name() {'MUTT'}sub lockfile() {shift->filename .'.lock'}sub exe() {shift->{MBLM_exe}}sub unlock() {my$self=shift;$self->hasLock or return$self;unless(system($self->exe,'-u',$self->filename)){my$folder=$self->folder;$self->log(WARNING=>"Couldn't remove mutt-unlock $folder: $!")}$self->SUPER::unlock;$self}sub lock() {my$self=shift;my$folder=$self->folder;if($self->hasLock){$self->log(WARNING=>"Folder $folder already mutt-locked");return 1}my$filename=$self->filename;my$lockfn=$self->lockfile;my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;my$expire=$self->expires / 86400;my$exe=$self->exe;while(1){if(system($exe,'-p','-r',1,$filename)){unless(WIFEXITED($?)&& WEXITSTATUS($?)==3){$self->log(ERROR=>"Will never get a mutt-lock: $!");return 0}}else {return$self->SUPER::lock}if(-e $lockfn && -A $lockfn > $expire){if(system($exe,'-f','-u',$filename)){$self->log(ERROR=>"Failed to remove expired mutt-lock $lockfn: $!");last}else {$self->log(WARNING=>"Removed expired mutt-lock $lockfn");redo}}last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;system($self->exe,'-t',$self->filename);WIFEXITED($?)&& WEXITSTATUS($?)==3}1;
MAIL_BOX_LOCKER_MUTT

$fatpacked{"Mail/Box/Locker/NFS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_NFS';
  package Mail::Box::Locker::NFS;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use Sys::Hostname;use IO::File;use Carp;sub name() {'NFS'}my$hostname=hostname;sub _tmpfilename() {my$self=shift;$self->{MBLN_tmp}||=$self->filename .$$}sub _construct_tmpfile() {my$self=shift;my$tmpfile=$self->_tmpfilename;my$fh=IO::File->new($tmpfile,O_CREAT|O_WRONLY,0600)or return undef;$fh->close;$tmpfile}sub _try_lock($$) {my ($self,$tmpfile,$lockfile)=@_;return undef unless link$tmpfile,$lockfile;my$linkcount=(stat$tmpfile)[3];unlink$tmpfile;$linkcount==2}sub _unlock($$) {my ($self,$tmpfile,$lockfile)=@_;unlink$lockfile or warn "Couldn't remove lockfile $lockfile: $!\n";unlink$tmpfile;$self}sub lock() {my$self=shift;my$folder=$self->folder;if($self->hasLock){$self->log(WARNING=>"Folder $folder already locked over nfs");return 1}my$lockfile=$self->filename;my$tmpfile=$self->_construct_tmpfile or return;my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;my$expires=$self->expires / 86400;if(-e $lockfile && -A $lockfile > $expires){if(unlink$lockfile){$self->log(WARNING=>"Removed expired lockfile $lockfile.")}else {$self->log(ERROR=>"Unable to remove expired lockfile $lockfile: $!")}}while(1){return$self->SUPER::lock if$self->_try_lock($tmpfile,$lockfile);last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;my$tmpfile=$self->_construct_tmpfile or return 0;my$lockfile=$self->filename;my$fh=$self->_try_lock($tmpfile,$lockfile)or return 0;close$fh;$self->_unlock($tmpfile,$lockfile);$self->SUPER::unlock;1}sub unlock($) {my$self=shift;return$self unless$self->hasLock;$self->_unlock($self->_tmpfilename,$self->filename);$self->SUPER::unlock;$self}1;
MAIL_BOX_LOCKER_NFS

$fatpacked{"Mail/Box/Locker/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_LOCKER_POSIX';
  package Mail::Box::Locker::POSIX;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Locker';use strict;use warnings;use Fcntl;use IO::File;use Errno qw/EAGAIN/;my$pack_pattern=$^O =~ /bsd|darwin/i ? '@20 s @256' : 's @256';sub init($) {my ($self,$args)=@_;$args->{file}=$args->{posix_file}if$args->{posix_file};$self->SUPER::init($args)}sub name() {'POSIX'}sub _try_lock($) {my ($self,$file)=@_;my$p=pack$pack_pattern,F_WRLCK;$?=fcntl($file,F_SETLK,$p)|| ($!+0);$?==0}sub _unlock($) {my ($self,$file)=@_;my$p=pack$pack_pattern,F_UNLCK;fcntl$file,F_SETLK,$p;$self}sub lock() {my$self=shift;if($self->hasLock){my$folder=$self->folder;$self->log(WARNING=>"Folder $folder already lockf'd");return 1}my$filename=$self->filename;my$folder=$self->folder;my$file=IO::File->new($filename,'r+');unless(defined$file){$self->log(ERROR=>"Unable to open POSIX lock file $filename for $folder: $!");return 0}my$timeout=$self->timeout;my$end=$timeout eq 'NOTIMEOUT' ? -1 : $timeout;while(1){if($self->_try_lock($file)){$self->{MBLF_filehandle}=$file;return$self->SUPER::lock}unless($!==EAGAIN){$self->log(ERROR=>"Will never get a POSIX lock on $filename for $folder: $!");last}last unless --$end;sleep 1}return 0}sub isLocked() {my$self=shift;my$filename=$self->filename;my$file=IO::File->new($filename,"r");unless($file){my$folder=$self->folder;$self->log(ERROR=>"Unable to check lock file $filename for $folder: $!");return 0}$self->_try_lock($file)==0 or return 0;$self->_unlock($file);$file->close;$self->SUPER::unlock;1}sub unlock() {my$self=shift;$self->_unlock(delete$self->{MBLF_filehandle})if$self->hasLock;$self->SUPER::unlock;$self}1;
MAIL_BOX_LOCKER_POSIX

$fatpacked{"Mail/Box/MH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MH';
  package Mail::Box::MH;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Dir';use strict;use warnings;use filetest 'access';use Mail::Box::MH::Index;use Mail::Box::MH::Message;use Mail::Box::MH::Labels;use Carp;use File::Spec ();use File::Basename 'basename';use IO::Handle ();my$default_folder_dir=exists$ENV{HOME}? "$ENV{HOME}/.mh" : '.';sub init($) {my ($self,$args)=@_;$args->{folderdir}||=$default_folder_dir;$args->{lock_file}||=$args->{index_filename};$self->SUPER::init($args);my$folderdir=$self->folderdir;my$directory=$self->directory;return unless -d $directory;$self->{MBM_keep_index}=$args->{keep_index}|| 0;$self->{MBM_index}=$args->{index};$self->{MBM_index_type}=$args->{index_type}|| 'Mail::Box::MH::Index';for($args->{index_filename}){$self->{MBM_index_filename}=!defined $_ ? "$directory/.index" : File::Spec->file_name_is_absolute($_)? $_ : "$directory/$_"}$self->{MBM_labels}=$args->{labels};$self->{MBM_labels_type}=$args->{labels_type}|| 'Mail::Box::MH::Labels';for($args->{labels_filename}){$self->{MBM_labels_filename}=!defined $_ ? "$directory/.mh_sequences" : File::Spec->file_name_is_absolute($_)? $_ : "$directory/$_"}$self}sub create($@) {my ($thingy,$name,%args)=@_;my$class=ref$thingy || $thingy;my$folderdir=$args{folderdir}|| $default_folder_dir;my$directory=$class->folderToDirectory($name,$folderdir);return$class if -d $directory;if(mkdir$directory,0700){$class->log(PROGRESS=>"Created folder $name.");return$class}else {$class->log(ERROR=>"Cannot create MH folder $name: $!");return}}sub foundIn($@) {my$class=shift;my$name=@_ % 2 ? shift : undef;my%args=@_;my$folderdir=$args{folderdir}|| $default_folder_dir;my$directory=$class->folderToDirectory($name,$folderdir);return 0 unless -d $directory;return 1 if -f "$directory/1";return unless opendir DIR,$directory;for (readdir DIR){next unless m/^\d+$/;closedir DIR;return 1}closedir DIR;0}sub type() {'mh'}sub listSubFolders(@) {my ($class,%args)=@_;my$dir;if(ref$class){$dir=$class->directory;$class=ref$class}else {my$folder=$args{folder}|| '=';my$folderdir=$args{folderdir}|| $default_folder_dir;$dir=$class->folderToDirectory($folder,$folderdir)}$args{skip_empty}||=0;$args{check}||=0;return ()unless -d $dir && opendir DIR,$dir;my@dirs=grep {!/^\d+$|^\./ && -d "$dir/$_" && -r _}readdir DIR;closedir DIR;if($args{skip_empty}){my@not_empty;for my$subdir (@dirs){if(-f "$dir/$subdir/1"){push@not_empty,$subdir;next}opendir DIR,"$dir/$subdir" or next;my@entities=grep!/^\./,readdir DIR;closedir DIR;if(grep /^\d+$/,@entities){push@not_empty,$subdir;next}for (@entities){next unless -d "$dir/$subdir/$_";push@not_empty,$subdir;last}}@dirs=@not_empty}@dirs=map {m/(.*)/ && $1 ? $1 : ()}@dirs;return@dirs unless$args{check};grep {$class->foundIn("$dir/$_")}@dirs}sub openSubFolder($) {my ($self,$name)=@_;my$subdir=$self->nameOfSubFolder($name);unless(-d $subdir || mkdir$subdir,0755){warn "Cannot create subfolder $name for $self: $!\n";return}$self->SUPER::openSubFolder($name,@_)}sub topFolderWithMessages() {1}sub appendMessages(@) {my$class=shift;my%args=@_;my@messages=exists$args{message}? $args{message}: exists$args{messages}? @{$args{messages}}: return ();my$self=$class->new(@_,access=>'r')or return ();my$directory=$self->directory;return unless -d $directory;my$locker=$self->locker;unless($locker->lock){$self->log(ERROR=>"Cannot append message without lock on $self.");return}my$msgnr=$self->highestMessageNumber +1;for my$message (@messages){my$filename="$directory/$msgnr";$message->create($filename)or $self->log(ERROR=>"Unable to write message for $self to $filename: $!\n");$msgnr++}$self->labels->append(@messages);$self->index->append(@messages);$locker->unlock;$self->close(write=>'NEVER');@messages}sub highestMessageNumber() {my$self=shift;return$self->{MBM_highest_msgnr}if exists$self->{MBM_highest_msgnr};my$directory=$self->directory;opendir DIR,$directory or return;my@messages=sort {$a <=> $b}grep /^\d+$/,readdir DIR;closedir DIR;$messages[-1]}sub index() {my$self=shift;return ()unless$self->{MBM_keep_index};return$self->{MBM_index}if defined$self->{MBM_index};$self->{MBM_index}=$self->{MBM_index_type}->new (filename=>$self->{MBM_index_filename},$self->logSettings)}sub labels() {my$self=shift;return$self->{MBM_labels}if defined$self->{MBM_labels};$self->{MBM_labels}=$self->{MBM_labels_type}->new (filename=>$self->{MBM_labels_filename},$self->logSettings)}sub readMessageFilenames {my ($self,$dirname)=@_;opendir DIR,$dirname or return;my@msgnrs =sort {$a <=> $b}map {/^(\d+)$/ && -f "$dirname/$1" ? $1 : ()}readdir DIR;closedir DIR;@msgnrs}sub readMessages(@) {my ($self,%args)=@_;my$directory=$self->directory;return unless -d $directory;my$locker=$self->locker;$locker->lock or return;my@msgnrs=$self->readMessageFilenames($directory);my$index=$self->{MBM_index};unless($index){$index=$self->index;$index->read if$index}my$labels=$self->{MBM_labels};unless($labels){$labels=$self->labels;$labels->read if$labels}my$body_type=$args{body_delayed_type};my$head_type=$args{head_delayed_type};my@log=$self->logSettings;for my$msgnr (@msgnrs){my$msgfile="$directory/$msgnr";my$head;$head=$index->get($msgfile)if$index;$head ||=$head_type->new(@log);my$message=$args{message_type}->new (head=>$head ,filename=>$msgfile ,folder=>$self ,fix_header=>$self->{MB_fix_headers});my$labref=$labels ? $labels->get($msgnr): ();$message->label(seen=>1,$labref ? @$labref : ());$message->storeBody($body_type->new(@log,message=>$message));$self->storeMessage($message)}$self->{MBM_highest_msgnr}=$msgnrs[-1];$self}sub delete(@) {my$self=shift;$self->SUPER::delete(@_);my$dir=$self->directory;return 1 unless opendir DIR,$dir;IO::Handle::untaint \*DIR;unlink "$dir/$_" for readdir DIR;closedir DIR;rmdir$dir}sub writeMessages($) {my ($self,$args)=@_;my$locker=$self->locker;$self->log(ERROR=>"Cannot write folder $self without lock."),return unless$locker->lock;my$renumber=exists$args->{renumber}? $args->{renumber}: 1;my$directory=$self->directory;my@messages=@{$args->{messages}};my$writer=0;for my$message (@messages){my$filename=$message->filename;my$newfile;if($renumber ||!$filename){$newfile=$directory .'/' .++$writer}else {$newfile=$filename;$writer=basename$filename}$message->create($newfile)}my$labels=$self->labels;$labels->write(@messages)if$labels;my$index=$self->index;$index->write(@messages)if$index;$locker->unlock;if(!@messages && $self->{MB_remove_empty}){rmdir$directory}$self}1;
MAIL_BOX_MH

$fatpacked{"Mail/Box/MH/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MH_INDEX';
  package Mail::Box::MH::Index;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Mail::Message::Head::Subset;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBMI_filename}=$args->{filename}or croak "No index filename specified.";$self->{MBMI_head_wrap}=$args->{head_wrap}|| 72;$self->{MBMI_head_type}=$args->{head_type}|| 'Mail::Message::Head::Subset';$self}sub filename() {shift->{MBMI_filename}}sub write(@) {my$self=shift;my$index=$self->filename or return$self;unless(@_){unlink$index;return$self}local*INDEX;open INDEX,'>:raw',$index or return$self;my$fieldtype='Mail::Message::Field';my$written=0;for my$msg (@_){my$head=$msg->head;next if$head->isDelayed && $head->isa('Mail::Message::Head::Subset');my$filename=$msg->filename;print INDEX "X-MailBox-Filename: $filename\n" ,'X-MailBox-Size: ',(-s $filename),"\n";$head->print(\*INDEX);$written++}close INDEX;$written or unlink$index;$self}sub append(@) {my$self=shift;my$index=$self->filename or return$self;local*INDEX;open INDEX,'>>:raw',$index or return$self;my$fieldtype='Mail::Message::Field';for my$msg (@_){my$head=$msg->head;next if$head->isDelayed && $head->isa('Mail::Message::Head::Subset');my$filename=$msg->filename;print INDEX "X-MailBox-Filename: $filename\n" ,'X-MailBox-Size: ',(-s $filename),"\n";$head->print(\*INDEX)}close INDEX;$self}sub read(;$) {my$self=shift;my$filename=$self->{MBMI_filename};my$parser=Mail::Box::Parser->new (filename=>$filename ,mode=>'r')or return;my@options=($self->logSettings,wrap_length=>$self->{MBMI_head_wrap});my$type=$self->{MBMI_head_type};my$index_age=-M $filename;my%index;while(my$head=$type->new(@options)->read($parser)){my$msgfile=$head->get('x-mailbox-filename');my$size=int$head->get('x-mailbox-size');next unless -f $msgfile && -s _==$size;next if defined$index_age && -M _ < $index_age;$index{$msgfile}=$head}$parser->stop;$self->{MBMI_index}=\%index;$self}sub get($) {my ($self,$msgfile)=@_;$self->{MBMI_index}{$msgfile}}1;
MAIL_BOX_MH_INDEX

$fatpacked{"Mail/Box/MH/Labels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MH_LABELS';
  package Mail::Box::MH::Labels;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Mail::Message::Head::Subset;use File::Copy;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBML_filename}=$args->{filename}or croak "No label filename specified.";$self}sub filename() {shift->{MBML_filename}}sub get($) {my ($self,$msgnr)=@_;$self->{MBML_labels}[$msgnr]}sub read() {my$self=shift;my$seq=$self->filename;open SEQ,'<:raw',$seq or return;my@labels;local $_;while(<SEQ>){s/\s*\#.*$//;next unless length;next unless s/^\s*(\w+)\s*\:\s*//;my$label=$1;my$set=1;if($label eq 'cur'){$label='current'}elsif($label eq 'unseen'){$label='seen';$set=0}for (split /\s+/){if(/^(\d+)\-(\d+)\s*$/){push @{$labels[$_]},$label,$set foreach $1..$2}elsif(/^\d+\s*$/){push @{$labels[$_]},$label,$set}}}close SEQ;$self->{MBML_labels}=\@labels;$self}sub write(@) {my$self=shift;my$filename=$self->filename;unless(@_){unlink$filename;return$self}open my$out,'>:raw',$filename or return;$self->print($out,@_);close$out;$self}sub append(@) {my$self=shift;my$filename=$self->filename;open(my$out,'>>:raw',$filename)or return;$self->print($out,@_);close$out;$self}sub print($@) {my ($self,$out)=(shift,shift);my%labeled;for my$message (@_){my$labels=$message->labels;(my$seq=$message->filename)=~ s!.*/!!;push @{$labeled{unseen}},$seq unless$labels->{seen};for (keys %$labels){push @{$labeled{$_}},$seq if$labels->{$_}}}delete$labeled{seen};local $"=' ';for (sort keys%labeled){my@msgs=@{$labeled{$_}};$_='cur' if $_ eq 'current';print$out "$_:";while(@msgs){my$start=shift@msgs;my$end=$start;$end=shift@msgs while@msgs && $msgs[0]==$end+1;print$out ($start==$end ? " $start" : " $start-$end")}print$out "\n"}$self}1;
MAIL_BOX_MH_LABELS

$fatpacked{"Mail/Box/MH/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MH_MESSAGE';
  package Mail::Box::MH::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Dir::Message';use strict;use warnings;use File::Copy;use Carp;1;
MAIL_BOX_MH_MESSAGE

$fatpacked{"Mail/Box/Maildir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MAILDIR';
  package Mail::Box::Maildir;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Dir';use strict;use warnings;use filetest 'access';use Mail::Box::Maildir::Message;use Carp;use File::Copy 'move';use File::Basename 'basename';use Sys::Hostname 'hostname';use File::Remove 'remove';my$default_folder_dir=exists$ENV{HOME}? "$ENV{HOME}/.maildir" : '.';sub init($) {my ($self,$args)=@_;croak "No locking possible for maildir folders." if exists$args->{locker}|| (defined$args->{lock_type}&& $args->{lock_type}ne 'NONE');$args->{lock_type}='NONE';$args->{folderdir}||=$default_folder_dir;return undef unless$self->SUPER::init($args);$self->acceptMessages if$args->{accept_new};$self}sub create($@) {my ($thingy,$name,%args)=@_;my$class=ref$thingy || $thingy;my$folderdir=$args{folderdir}|| $default_folder_dir;my$directory=$class->folderToDirectory($name,$folderdir);if($class->createDirs($directory)){$class->log(PROGRESS=>"Created folder Maildir $name.");return$class}else {$class->log(ERROR=>"Cannot create Maildir folder $name.");return undef}}sub foundIn($@) {my$class=shift;my$name=@_ % 2 ? shift : undef;my%args=@_;my$folderdir=$args{folderdir}|| $default_folder_dir;my$directory=$class->folderToDirectory($name,$folderdir);-d "$directory/cur"}sub type() {'maildir'}sub listSubFolders(@) {my ($class,%args)=@_;my$dir;if(ref$class){$dir=$class->directory;$class=ref$class}else {my$folder=$args{folder}|| '=';my$folderdir=$args{folderdir}|| $default_folder_dir;$dir=$class->folderToDirectory($folder,$folderdir)}$args{skip_empty}||=0;$args{check}||=0;return ()unless -d $dir && opendir DIR,$dir;my@dirs;while(my$d=readdir DIR){next if$d =~ m/^(new|tmp|cur|\.\.?)$/;my$dir="$dir/$d";push@dirs,$d if -d $dir && -r _}closedir DIR;@dirs=grep {!$class->folderIsEmpty("$dir/$_")}@dirs if$args{skip_empty};@dirs=map {m/(.*)/ && $1}@dirs;return@dirs unless$args{check};grep {$class->foundIn("$dir/$_")}@dirs}sub openSubFolder($@) {my ($self,$name)=(shift,shift);$self->createDirs($self->nameOfSubFolder($name));$self->SUPER::openSubFolder($name,@_)}sub topFolderWithMessages() {1}my$uniq=rand 1000;sub coerce($) {my ($self,$message)=(shift,shift);my$is_native=$message->isa('Mail::Box::Maildir::Message');my$coerced=$self->SUPER::coerce($message,@_);my$basename=$is_native ? basename($message->filename): ($message->timestamp || time).'.'.hostname .'.'.$uniq++;my$dir=$self->directory;my$tmp="$dir/tmp/$basename";my$new="$dir/new/$basename";if($coerced->create($tmp)&& $coerced->create($new)){$self->log(PROGRESS=>"Added Maildir message in $new")}else {$self->log(ERROR=>"Cannot create Maildir message file $new.")}$coerced->labelsToFilename unless$is_native;$coerced}sub createDirs($) {my ($thing,$dir)=@_;$thing->log(ERROR=>"Cannot create Maildir folder directory $dir: $!"),return unless -d $dir || mkdir$dir;my$tmp="$dir/tmp";$thing->log(ERROR=>"Cannot create Maildir folder subdir $tmp: $!"),return unless -d $tmp || mkdir$tmp;my$new="$dir/new";$thing->log(ERROR=>"Cannot create Maildir folder subdir $new: $!"),return unless -d $new || mkdir$new;my$cur="$dir/cur";$thing->log(ERROR=>"Cannot create Maildir folder subdir $cur: $!"),return unless -d $cur || mkdir$cur;$thing}sub folderIsEmpty($) {my ($self,$dir)=@_;return 1 unless -d $dir;for (qw/tmp new cur/){my$subdir="$dir/$_";next unless -d $subdir;opendir DIR,$subdir or return 0;my$first=readdir DIR;closedir DIR;return 0 if defined$first}opendir DIR,$dir or return 1;while(my$entry=readdir DIR){next if$entry =~ m/^(?:tmp|cur|new|bulletin(?:time|lock)|seriallock|\..?)$/;closedir DIR;return 0}closedir DIR;1}sub delete(@) {my$self=shift;remove \1,$self->directory}sub readMessageFilenames {my ($self,$dirname)=@_;opendir DIR,$dirname or return ();my@files;if(${^TAINT}){@files=map {m/^([0-9][\w.:,=\-]+)$/ && -f "$dirname/$1" ? $1 : ()}readdir DIR}else {@files=grep /^([0-9][\w.:,=\-]+)$/ && -f "$dirname/$1",readdir DIR}closedir DIR;my%unified;m/^(\d+)/ and $unified{('0' x (10-length($1))).$_ }=$_ for@files;map "$dirname/$unified{$_}",sort keys%unified}sub readMessages(@) {my ($self,%args)=@_;my$directory=$self->directory;return unless -d $directory;my$curdir="$directory/cur";my@cur=map +[$_,1],$self->readMessageFilenames($curdir);my$newdir="$directory/new";my@new=map +[$_,0],$self->readMessageFilenames($newdir);my@log=$self->logSettings;for (@cur,@new){my ($filename,$accepted)=@$_;my$message=$args{message_type}->new (head=>$args{head_delayed_type}->new(@log),filename=>$filename ,folder=>$self ,fix_header=>$self->{MB_fix_headers},labels=>[accepted=>$accepted ]);my$body=$args{body_delayed_type}->new(@log,message=>$message);$message->storeBody($body)if$body;$self->storeMessage($message)}$self}sub acceptMessages($) {my ($self,%args)=@_;my@accept=$self->messages('!accepted');$_->accept foreach@accept;@accept}sub writeMessages($) {my ($self,$args)=@_;my$writer=0;my$directory=$self->directory;my@messages=@{$args->{messages}};my$tmpdir="$directory/tmp";die "Cannot create directory $tmpdir: $!" unless -d $tmpdir || mkdir$tmpdir;for my$message (@messages){next unless$message->isModified;my$filename=$message->filename;my$basename=basename$filename;my$newtmp="$directory/tmp/$basename";open my$new,'>',$newtmp or croak "Cannot create file $newtmp: $!";$message->write($new);close$new;unlink$filename;move$newtmp,$filename or warn "Cannot move $newtmp to $filename: $!\n"}if(!@messages && $self->{MB_remove_empty}){rmdir "$directory/cur";rmdir "$directory/tmp";rmdir "$directory/new";rmdir$directory}$self}sub appendMessages(@) {my$class=shift;my%args=@_;my@messages=exists$args{message}? $args{message}: exists$args{messages}? @{$args{messages}}: return ();my$self=$class->new(@_,access=>'a');my$directory=$self->directory;return unless -d $directory;my$tmpdir="$directory/tmp";croak "Cannot create directory $tmpdir: $!",return unless -d $tmpdir || mkdir$tmpdir;my$msgtype=$args{message_type}|| 'Mail::Box::Maildir::Message';for my$message (@messages){my$is_native=$message->isa($msgtype);my ($basename,$coerced);if($is_native){$coerced=$message;$basename=basename$message->filename}else {$coerced=$self->SUPER::coerce($message);$basename=($message->timestamp||time).'.'.hostname.'.'.$uniq++}my$dir=$self->directory;my$tmp="$dir/tmp/$basename";my$new="$dir/new/$basename";if($coerced->create($tmp)&& $coerced->create($new)){$self->log(PROGRESS=>"Appended Maildir message in $new")}else {$self->log(ERROR=>"Cannot append Maildir message in $new to folder $self.")}}$self->close;@messages}1;
MAIL_BOX_MAILDIR

$fatpacked{"Mail/Box/Maildir/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MAILDIR_MESSAGE';
  package Mail::Box::Maildir::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Dir::Message';use strict;use warnings;use File::Copy;sub filename(;$) {my$self=shift;my$oldname=$self->SUPER::filename();return$oldname unless @_;my$newname=shift;return$newname if defined$oldname && $oldname eq $newname;my ($id,$semantics,$flags)=$newname =~ m!(.*?)(?:\:([12])\,([A-Za-z]*))! ? ($1,$2,$3): ($newname,'','');my%flags;$flags{$_}++ foreach split //,$flags;$self->SUPER::label (draft=>(delete$flags{D}|| 0),flagged=>(delete$flags{F}|| 0),replied=>(delete$flags{R}|| 0),seen=>(delete$flags{S}|| 0),deleted=>(delete$flags{T}|| 0),passed=>(delete$flags{P}|| 0),unknown=>join('',sort keys%flags));if(defined$oldname &&!move$oldname,$newname){$self->log(ERROR=>"Cannot move $oldname to $newname: $!");return undef}$self->SUPER::filename($newname)}sub guessTimestamp() {my$self=shift;my$timestamp=$self->SUPER::guessTimestamp;return$timestamp if defined$timestamp;$self->filename =~ m/^(\d+)/ ? $1 : undef}sub label(@) {my$self=shift;return$self->SUPER::label unless @_;my$return=$self->SUPER::label(@_);$self->labelsToFilename;$return}sub labelsToFilename() {my$self=shift;my$labels=$self->labels;my$old=$self->filename;my ($folderdir,$set,$oldname,$oldflags)=$old =~ m!(.*)/(new|cur|tmp)/(.+?)(\:2,[^:]*)?$!;my$newflags =($labels->{draft}? 'D' : '').($labels->{flagged}? 'F' : '').($labels->{passed}? 'P' : '').($labels->{replied}? 'R' : '').($labels->{seen}? 'S' : '').($labels->{deleted}? 'T' : '').($labels->{unknown}|| '');my$newset=$labels->{accepted}? 'cur' : 'new';if($set ne $newset){my$folder=$self->folder;$folder->modified(1)if defined$folder}my$flags=$newset ne 'new' || $newflags ne '' ? ":2,$newflags" : $oldflags ? ':2,' : '';my$new=File::Spec->catfile($folderdir,$newset,$oldname.$flags);if($new ne $old){unless(move$old,$new){$self->log(ERROR=>"Cannot rename $old to $new: $!");return}$self->log(PROGRESS=>"Moved $old to $new.");$self->SUPER::filename($new)}$new}sub accept(;$) {my$self=shift;my$accept=@_ ? shift : 1;$self->label(accepted=>$accept)}1;
MAIL_BOX_MAILDIR_MESSAGE

$fatpacked{"Mail/Box/Manage/User.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MANAGE_USER';
  package Mail::Box::Manage::User;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Manager';use strict;use warnings;use Mail::Box::Collection ();sub init($) {my ($self,$args)=@_;$self->SUPER::init($args)or return ();my$identity=$self->{MBMU_id}=$args->{identity};defined$identity or die;my$top=$args->{folder_id_type}|| 'Mail::Box::Identity';my$coltype=$args->{collection_type}|| 'Mail::Box::Collection';unless(ref$top){my$name=$args->{topfolder_name};$name='=' unless defined$name;$top=$top->new (name=>$name ,manager=>$self ,location=>scalar($self->folderdir),folder_type=>$self->defaultFolderType ,collection_type=>$coltype)}$self->{MBMU_topfolder}=$top;$self->{MBMU_delim}=$args->{delimiter}|| '/';$self->{MBMU_inbox}=$args->{inbox};$self}sub identity() {shift->{MBMU_id}}sub inbox(;$) {my$self=shift;@_ ? ($self->{MBMU_inbox}=shift): $self->{MBMU_inbox}}sub topfolder() {shift->{MBMU_topfolder}}sub folder($) {my ($self,$name)=@_;my$top=$self->topfolder or return ();my@path=split$self->{MBMU_delim},$name;return ()unless shift@path eq $top->name;$top->folder(@path)}sub folderCollection($) {my ($self,$name)=@_;my$top=$self->topfolder or return ();my@path=split$self->{MBMU_delim},$name;unless(shift@path eq $top->name){$self->log(ERROR=>"Folder name $name not under top.");return ()}my$base=pop@path;($top->folder(@path),$base)}sub create($@) {my ($self,$name,%args)=@_;my ($dir,$base)=$self->folderCollection($name);unless(defined$dir){unless($args{create_supers}){$self->log(ERROR=>"Cannot create $name: higher levels missing");return undef}(my$upper=$name)=~ s!$self->{MBMU_delim}$base!! or die "$name - $base";$dir=$self->create($upper,%args,deleted=>1)}my$id=$dir->folder($base);if(!defined$id){my$idopt=$args{id_options}|| [];$id=$dir->addSubfolder($base,@$idopt,deleted=>$args{deleted})}elsif($args{deleted}){$id->deleted(1);return$id}elsif($id->deleted){$id->deleted(0)}else {$self->log(ERROR=>"Folder $name already exists");return undef}if(!defined$args{create_real}|| $args{create_real}){$self->defaultFolderType->create($id->location,%args)or return undef}$id}sub delete($) {my ($self,$name)=@_;my$id=$self->folder($name)or return ();$id->remove;$self->SUPER::delete($name)}sub rename($$@) {my ($self,$oldname,$newname,%args)=@_;my$old=$self->folder($oldname);unless(defined$old){$self->log(WARNING =>"Source for rename does not exist: $oldname to $newname");return ()}my ($newdir,$base)=$self->folderCollection($newname);unless(defined$newdir){unless($args{create_supers}){$self->log(ERROR =>"Cannot rename $oldname to $newname: higher levels missing");return ()}(my$upper=$newname)=~ s!$self->{MBMU_delim}$base!! or die "$newname - $base";$newdir=$self->create($upper,%args,deleted=>1)}my$oldlocation=$old->location;my$new=$old->rename($newdir,$base);my$newlocation=$new->location;if($oldlocation ne $newlocation){require Carp;croak("Physical folder relocation not yet implemented")}$self->log(PROGRESS=>"Renamed folder $oldname to $newname");$new}1;
MAIL_BOX_MANAGE_USER

$fatpacked{"Mail/Box/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MANAGER';
  package Mail::Box::Manager;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Mail::Box;use List::Util 'first';use Scalar::Util 'weaken';my%require_failed;my@basic_folder_types=([mbox=>'Mail::Box::Mbox' ],[mh=>'Mail::Box::MH' ],[maildir=>'Mail::Box::Maildir' ],[pop=>'Mail::Box::POP3' ],[pop3=>'Mail::Box::POP3' ],[pops=>'Mail::Box::POP3s' ],[pop3s=>'Mail::Box::POP3s' ],[imap=>'Mail::Box::IMAP4' ],[imap4=>'Mail::Box::IMAP4' ],[imaps=>'Mail::Box::IMAP4s' ],[imap4s=>'Mail::Box::IMAP4s' ]);my@managers;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);my@new_types;if(exists$args->{folder_types}){@new_types=ref$args->{folder_types}[0]? @{$args->{folder_types}}: $args->{folder_types}}my@basic_types=reverse@basic_folder_types;if(my$basic=$args->{autodetect}){my%types=map +($_=>1),ref$basic ? @$basic : $basic;@basic_types=grep$types{$_->[0]},@basic_types}$self->{MBM_folder_types}=[];$self->registerType(@$_)for@new_types,@basic_types;$self->{MBM_default_type}=$args->{default_folder_type}|| 'mbox';my$fd=$self->{MBM_folderdirs}=[];if(exists$args->{folderdir}){my@dirs=$args->{folderdir};@dirs=@{$dirs[0]}if ref$dirs[0]eq 'ARRAY';push @$fd,@dirs}if(exists$args->{folderdirs}){my@dirs=$args->{folderdirs};@dirs=@{$dirs[0]}if ref$dirs[0];push @$fd,@dirs}push @$fd,'.';$self->{MBM_folders}=[];$self->{MBM_threads}=[];push@managers,$self;weaken$managers[-1];$self}sub registerType($$@) {my ($self,$name,$class,@options)=@_;unshift @{$self->{MBM_folder_types}},[$name,$class,@options];$self}sub folderdir() {my$dirs=shift->{MBM_folderdirs}or return ();wantarray ? @$dirs : $dirs->[0]}sub folderTypes() {my$self=shift;my%uniq;$uniq{$_->[0]}++ foreach @{$self->{MBM_folder_types}};sort keys%uniq}sub defaultFolderType() {my$self=shift;my$name=$self->{MBM_default_type};return$name if$name =~ m/\:\:/;for my$def (@{$self->{MBM_folder_types}}){return$def->[1]if$def->[0]eq $name || $def->[1]eq $name}undef}sub open(@) {my$self=shift;my$name=@_ % 2 ? shift : undef;my%args=@_;$args{authentication}||='AUTO';$name=defined$args{folder}? $args{folder}: ($ENV{MAIL}|| '')unless defined$name;if($name =~ m/^(\w+)\:/ && grep $_ eq $1,$self->folderTypes){my%decoded=$self->decodeFolderURL($name);if(keys%decoded){@args{keys%decoded}=values%decoded}else {$self->log(ERROR=>"Illegal folder URL '$name'.");return}}else {$args{folder}=$name}my$type=$args{type};if(!defined$type){}elsif($type eq 'pop3' || $type eq 'pop'){my$un=$args{username}||=$ENV{USER}|| $ENV{LOGIN};my$srv=$args{server_name}||='localhost';my$port=$args{server_port}||=110;$args{folderdir}=$name="pop3://$un\@$srv:$port"}elsif($type eq 'pop3s' || $type eq 'pops'){my$un=$args{username}||=$ENV{USER}|| $ENV{LOGIN};my$srv=$args{server_name}||='localhost';my$port=$args{server_port}||=995;$args{folderdir}=$name="pop3s://$un\@$srv:$port"}elsif($type eq 'imap4' || $type eq 'imap'){my$un=$args{username}||=$ENV{USER}|| $ENV{LOGIN};my$srv=$args{server_name}||='localhost';my$port=$args{server_port}||=143;$args{folderdir}=$name="imap4://$un\@$srv:$port"}elsif($type eq 'imap4s' || $type eq 'imaps'){my$un=$args{username}||=$ENV{USER}|| $ENV{LOGIN};my$srv=$args{server_name}||='localhost';my$port=$args{server_port}||=993;$args{folderdir}=$name="imap4s://$un\@$srv:$port"}unless(defined$name && length$name){$self->log(ERROR=>"No foldername specified to open.");return undef}$args{folderdir}||=$self->{MBM_folderdirs}->[0]if$self->{MBM_folderdirs};$args{access}||='r';if($args{create}&& $args{access}!~ m/w|a/){$self->log(WARNING =>"Will never create a folder $name without having write access.");undef$args{create}}if(my$folder=$self->isOpenFolder($name)){$self->log(ERROR=>"Folder $name is already open.");return undef}my ($folder_type,$class,@defaults);if($type){for (@{$self->{MBM_folder_types}}){(my$abbrev,$class,@defaults)=@$_;if($type eq $abbrev || $type eq $class){$folder_type=$abbrev;last}}$self->log(ERROR=>"Folder type $type is unknown, using autodetect.")unless$folder_type}unless($folder_type){for (@{$self->{MBM_folder_types}}){next unless $_;(my$abbrev,$class,@defaults)=@$_;next if$require_failed{$class};eval "require $class";if($@){$require_failed{$class}++;next}if($class->foundIn($name,@defaults,%args)){$folder_type=$abbrev;last}}}unless($folder_type){if(my$type=$self->{MBM_default_type}){for (@{$self->{MBM_folder_types}}){(my$abbrev,$class,@defaults)=@$_;if($type eq $abbrev || $type eq $class){$folder_type=$abbrev;last}}}}unless($folder_type){($folder_type,$class,@defaults)=@{$self->{MBM_folder_types}[0]}}return if$require_failed{$class};eval "require $class";if($@){$self->log(ERROR=>"Failed for folder default $class: $@");$require_failed{$class}++;return ()}push@defaults,manager=>$self;my$folder=$class->new(@defaults,%args);unless(defined$folder){$self->log(WARNING=>"Folder does not exist, failed opening $folder_type folder $name.")unless$args{access}eq 'd';return}$self->log(PROGRESS=>"Opened folder $name ($folder_type).");push @{$self->{MBM_folders}},$folder;$folder}sub openFolders() {@{shift->{MBM_folders}}}sub isOpenFolder($) {my ($self,$name)=@_;first {$name eq $_->name}$self->openFolders}sub close($@) {my ($self,$folder,%options)=@_;return unless$folder;my$name=$folder->name;my@remaining=grep {$name ne $_->name}@{$self->{MBM_folders}};return if @{$self->{MBM_folders}}==@remaining;$self->{MBM_folders}=[@remaining ];$_->removeFolder($folder)foreach @{$self->{MBM_threads}};$folder->close(close_by_manager=>1,%options)unless$options{close_by_self};$self}sub closeAllFolders(@) {my ($self,@options)=@_;$_->close(@options)for$self->openFolders;$self}END {map defined $_ && $_->closeAllFolders,@managers}sub delete($@) {my ($self,$name,%args)=@_;my$recurse=delete$args{recursive};my$folder=$self->open(folder=>$name,access=>'d',%args)or return$self;$folder->delete(recursive=>$recurse)}sub appendMessage(@) {my$self=shift;my@appended=$self->appendMessages(@_);wantarray ? @appended : $appended[0]}sub appendMessages(@) {my$self=shift;my$folder;$folder=shift if!ref $_[0]|| $_[0]->isa('Mail::Box');my@messages;push@messages,shift while @_ && ref $_[0];my%options=@_;$folder ||=$options{folder};$folder=$self->isOpenFolder($folder)|| $folder unless ref$folder;if(ref$folder){unless($folder->isa('Mail::Box')){$self->log(ERROR=>"Folder $folder is not a Mail::Box; cannot add a message.\n");return ()}for (@messages){next unless $_->isa('Mail::Box::Message')&& $_->folder;$self->log(WARNING=>"Use moveMessage() or copyMessage() to move between open folders.")}return$folder->addMessages(@messages)}my ($name,$class,@gen_options,$found);for (@{$self->{MBM_folder_types}}){($name,$class,@gen_options)=@$_;next if$require_failed{$class};eval "require $class";if($@){$require_failed{$class}++;next}if($class->foundIn($folder,@gen_options,access=>'a')){$found++;last}}my$type=$self->{MBM_default_type};if(!$found && $type){for (@{$self->{MBM_folder_types}}){($name,$class,@gen_options)=@$_;if($type eq $name || $type eq $class){$found++;last}}}($name,$class,@gen_options)=@{$self->{MBM_folder_types}[0]}unless$found;$class->appendMessages (type=>$name ,messages=>\@messages ,@gen_options ,%options ,folder=>$folder)}sub copyMessage(@) {my$self=shift;my$folder;$folder=shift if!ref $_[0]|| $_[0]->isa('Mail::Box');my@messages;while(@_ && ref $_[0]){my$message=shift;$self->log(ERROR=>"Use appendMessage() to add messages which are not in a folder.")unless$message->isa('Mail::Box::Message');push@messages,$message}my%args=@_;$folder ||=$args{folder};my$share=exists$args{share}? $args{share}: $args{_delete};$folder=$self->isOpenFolder($folder)|| $folder unless ref$folder;unless(ref$folder){my@c=$self->appendMessages(@messages,%args,folder=>$folder);if($args{_delete}){$_->label(deleted=>1)for@messages}return@c}my@coerced;for my$msg (@messages){if($msg->folder eq $folder){push@coerced,$msg;next}push@coerced,$msg->copyTo($folder,share=>$args{share});$msg->label(deleted=>1)if$args{_delete}}@coerced}sub moveMessage(@) {my$self=shift;$self->copyMessage(@_,_delete=>1)}sub threads(@) {my$self=shift;my@folders;push@folders,shift while @_ && ref $_[0]&& $_[0]->isa('Mail::Box');my%args=@_;my$base='Mail::Box::Thread::Manager';my$type=$args{threader_type}|| $base;my$folders=delete$args{folder}|| delete$args{folders};push@folders ,(!$folders ? (): ref$folders eq 'ARRAY' ? @$folders : $folders);$self->log(INTERNAL=>"No folders specified.")unless@folders;my$threads;if(ref$type){$self->log(INTERNAL=>"You need to pass a $base derived")unless$type->isa($base);$threads=$type}else {eval "require $type";$self->log(INTERNAL=>"Unusable threader $type: $@")if $@;$self->log(INTERNAL=>"You need to pass a $base derived")unless$type->isa($base);$threads=$type->new(manager=>$self,%args)}$threads->includeFolder($_)foreach@folders;push @{$self->{MBM_threads}},$threads;$threads}sub toBeThreaded($@) {my$self=shift;$_->toBeThreaded(@_)foreach @{$self->{MBM_threads}}}sub toBeUnthreaded($@) {my$self=shift;$_->toBeUnthreaded(@_)foreach @{$self->{MBM_threads}}}sub decodeFolderURL($) {my ($self,$name)=@_;return unless my ($type,$username,$password,$hostname,$port,$path)=$name =~ m!^(\w+)\:             # protocol
                         (?://
                            (?:([^:@/]*)      # username
                              (?:\:([^@/]*))? # password
                             \@)?
                             ([\w.-]+)?       # hostname
                             (?:\:(\d+))?     # port number
                          )?
                          (.*)                # foldername
                        !x;$username ||=$ENV{USER}|| $ENV{LOGNAME};$password ||='';for($username,$password){s/\+/ /g;s/\%([A-Fa-f0-9]{2})/chr hex $1/ge}$hostname ||='localhost';$path ||='=';(type=>$type,folder=>$path ,username=>$username,password=>$password ,server_name=>$hostname,server_port=>$port)}1;
MAIL_BOX_MANAGER

$fatpacked{"Mail/Box/Mbox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MBOX';
  package Mail::Box::Mbox;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::File';use strict;use warnings;use filetest 'access';use Mail::Box::Mbox::Message;our$default_folder_dir=exists$ENV{HOME}? $ENV{HOME}.'/Mail' : '.';our$default_sub_extension='.d';sub init($) {my ($self,$args)=@_;$self->{MBM_sub_ext}=$args->{subfolder_extension}|| $default_sub_extension;$self->SUPER::init($args)}sub create($@) {my ($thingy,$name,%args)=@_;my$class=ref$thingy || $thingy;$args{folderdir}||=$default_folder_dir;$args{subfolder_extension}||=$default_sub_extension;$class->SUPER::create($name,%args)}sub foundIn($@) {my$class=shift;my$name=@_ % 2 ? shift : undef;my%args=@_;$name ||=$args{folder}or return;my$folderdir=$args{folderdir}|| $default_folder_dir;my$extension=$args{subfolder_extension}|| $default_sub_extension;my$filename=$class->folderToFilename($name,$folderdir,$extension);if(-d $filename){return 0 if -d File::Spec->catdir($filename,'new');local*DIR;if(opendir DIR,$filename){my@f=grep!/^\./,readdir DIR;return 0 if@f &&!grep /\D/,@f;closedir DIR}return 0 if -f "$filename/.mh_sequences";return 1}return 0 unless -f $filename;return 1 if -z $filename;open my$file,'<:raw',$filename or return 0;local $_;while(<$file>){next if /^\s*$/;$file->close;return substr($_,0,5)eq 'From '}return 1}sub delete(@) {my$self=shift;$self->SUPER::delete(@_);my$subfdir=$self->filename .$default_sub_extension;rmdir$subfdir}sub writeMessages($) {my ($self,$args)=@_;$self->SUPER::writeMessages($args)or return;if($self->{MB_remove_empty}){rmdir$self->filename .$self->{MBM_sub_ext}}$self}sub type() {'mbox'}sub listSubFolders(@) {my ($thingy,%args)=@_;my$class=ref$thingy || $thingy;my$skip_empty=$args{skip_empty}|| 0;my$check=$args{check}|| 0;my$folder=exists$args{folder}? $args{folder}: '=';my$folderdir=exists$args{folderdir}? $args{folderdir}: $default_folder_dir;my$extension=$args{subfolder_extension};my$dir;if(ref$thingy){$extension ||=$thingy->{MBM_sub_ext};$dir=$thingy->filename}else {$extension ||=$default_sub_extension;$dir=$class->folderToFilename($folder,$folderdir,$extension)}my$real=-d $dir ? $dir : "$dir$extension";opendir DIR,$real or return ();my@entries=grep!m/\.lo?ck$|^\./,readdir DIR;closedir DIR;my%folders;for (@entries){my$entry=File::Spec->catfile($real,$_);if(-f $entry){next if$args{skip_empty}&&!-s _;next if$args{check}&&!$class->foundIn($entry);$folders{$_}++}elsif(-d _){if($args{skip_empty}){opendir DIR,$entry or next;my@sub=grep!/^\./,readdir DIR;closedir DIR;next unless@sub}(my$folder=$_)=~ s/$extension$//;$folders{$folder}++}}map +(m/(.*)/ && $1),keys%folders}sub openRelatedFolder(@) {my$self=shift;$self->SUPER::openRelatedFolder(subfolder_extension=>$self->{MBM_sub_ext},@_)}sub folderToFilename($$;$) {my ($thingy,$name,$folderdir,$extension)=@_;$extension ||=ref$thingy ? $thingy->{MBM_sub_ext}: $default_sub_extension;$name =~ s#^=#$folderdir/#;my@parts=split m!/!,$name;my$real=shift@parts;$real='/' if$real eq '';if(@parts){my$file=pop@parts;$real=File::Spec->catdir($real.(-d $real ? '' : $extension),$_)foreach@parts;$real=File::Spec->catfile($real.(-d $real ? '' : $extension),$file)}$real}1;
MAIL_BOX_MBOX

$fatpacked{"Mail/Box/Mbox/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MBOX_MESSAGE';
  package Mail::Box::Mbox::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::File::Message';use strict;use warnings;sub head(;$$) {my$self=shift;return$self->SUPER::head unless @_;my ($head,$labels)=@_;$self->SUPER::head($head,$labels);$self->statusToLabels if$head &&!$head->isDelayed;$head}sub label(@) {my$self=shift;$self->loadHead;my$return=$self->SUPER::label(@_);$return}sub labels(@) {my$self=shift;$self->loadHead;$self->SUPER::labels(@_)}1;
MAIL_BOX_MBOX_MESSAGE

$fatpacked{"Mail/Box/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MESSAGE';
  package Mail::Box::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Message';use strict;use warnings;use Scalar::Util 'weaken';sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBM_body_type}=$args->{body_type};$self->{MBM_folder}=$args->{folder};weaken($self->{MBM_folder});return$self if$self->isDummy;$self}sub head(;$) {my$self=shift;return$self->SUPER::head unless @_;my$new=shift;my$old=$self->head;$self->SUPER::head($new);return unless defined$new || defined$old;my$folder=$self->folder or return$new;if(!defined$new && defined$old &&!$old->isDelayed){$folder->messageId($self->messageId,undef);$folder->toBeUnthreaded($self)}elsif(defined$new &&!$new->isDelayed){$folder->messageId($self->messageId,$self);$folder->toBeThreaded($self)}$new || $old}sub folder(;$) {my$self=shift;if(@_){$self->{MBM_folder}=shift;weaken($self->{MBM_folder});$self->modified(1)}$self->{MBM_folder}}sub seqnr(;$) {my$self=shift;@_ ? $self->{MBM_seqnr}=shift : $self->{MBM_seqnr}}sub copyTo($@) {my ($self,$folder)=(shift,shift);$folder->addMessage($self->clone(@_))}sub moveTo($@) {my ($self,$folder,%args)=@_;$args{share}=1 unless exists$args{share}|| exists$args{shallow_body};my$added=$self->copyTo($folder,%args);$self->label(deleted=>1);$added}sub readBody($$;$) {my ($self,$parser,$head,$getbodytype)=@_;unless($getbodytype){my$folder=$self->{MBM_folder};$getbodytype=sub {$folder->determineBodyType(@_)}if defined$folder}$self->SUPER::readBody($parser,$head,$getbodytype)}sub diskDelete() {shift}sub forceLoad() {my$self=shift;$self->loadBody(@_);$self}sub destruct() {require Mail::Box::Message::Destructed;Mail::Box::Message::Destructed->coerce(shift)}1;
MAIL_BOX_MESSAGE

$fatpacked{"Mail/Box/Message/Destructed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_MESSAGE_DESTRUCTED';
  package Mail::Box::Message::Destructed;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Message';use strict;use warnings;use Carp;sub new(@) {my$class=shift;$class->log(ERROR=>'You cannot instantiate a destructed message');undef}sub isDummy() {1}sub head(;$) {my$self=shift;return undef if @_ &&!defined(shift);$self->log(ERROR=>"You cannot take the head of a destructed message");undef}sub body(;$) {my$self=shift;return undef if @_ &&!defined(shift);$self->log(ERROR=>"You cannot take the body of a destructed message");undef}sub coerce($) {my ($class,$message)=@_;unless($message->isa('Mail::Box::Message')){$class->log(ERROR=>"Cannot coerce a ",ref($message)," into destruction");return ()}$message->body(undef);$message->head(undef);$message->modified(0);bless$message,$class}sub modified(;$) {my$self=shift;$self->log(ERROR=>'Do not set the modified flag on a destructed message')if @_ && $_[0];0}sub isModified() {0}sub label($;@) {my$self=shift;if(@_==1){my$label=shift;return$self->SUPER::label('deleted')if$label eq 'deleted';$self->log(ERROR=>"Destructed message has no labels except 'deleted', requested is $label");return 0}my%flags=@_;unless(keys%flags==1 && exists$flags{deleted}){$self->log(ERROR=>"Destructed message has no labels except 'deleted', trying to set @{[ keys %flags ]}");return}$self->log(ERROR=>"Destructed messages can not be undeleted")unless$flags{deleted};1}sub labels() {wantarray ? ('deleted'): +{deleted=>1}}1;
MAIL_BOX_MESSAGE_DESTRUCTED

$fatpacked{"Mail/Box/Net.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_NET';
  package Mail::Box::Net;use vars '$VERSION';$VERSION='3.007';use strict;use warnings;use base 'Mail::Box';use Mail::Box::Net::Message;use Mail::Message::Body::Lines;use Mail::Message::Body::File;use Mail::Message::Body::Delayed;use Mail::Message::Body::Multipart;use Mail::Message::Head;use Mail::Message::Head::Delayed;use Carp;use File::Copy;use File::Spec;use File::Basename;sub init($) {my ($self,$args)=@_;$args->{lock_type}||='NONE';$args->{body_type}||='Mail::Message::Body::Lines';$args->{trusted}||=0;my ($scheme,$s,$port,$u,$pwd,$f);if(my$d=$args->{folderdir}){($scheme,$u,$pwd,$s,$port,$f)=$d =~ m! ^ (\w+) \://                # scheme
                 (?: ( [^:\@/]+ )          # username
                     (?:  \: ( [^\@/]+ ))? # password
                     \@ )?
                 ( [a-zA-Z0-9.-]+ )?       # hostname
                 (?: \: ([0-9]+)  )?       # port
                 ( / .* )?                 # path
            !x;$args->{folderdir}=~ s!/$!!}$args->{folder}||=$f || '/';$self->SUPER::init($args);$self->{MBN_hostname}=$args->{server_name}|| $s;$self->{MBN_port}=$args->{server_port}|| $port;$self->{MBN_username}=$args->{username}|| $u;$self->{MBN_password}=$args->{password}|| $pwd;$self->log(WARNING=>"The term 'hostname' is confusing wrt folder. You probably need 'server_name'")if exists$args->{hostname};$self}sub create(@) {shift->notImplemented}sub organization() {'REMOTE'}sub url() {my$self=shift;my ($user,$pass,$host,$port)=@$self{qw/MBN_username MBN_password MBN_hostname MBN_port/ };my$perm='';$perm=$user if defined$user;if(defined$pass){$pass =~ s/(\W)/sprintf "%%%02X", ord $1/ge;$perm .= ':'.$pass}$perm .= '@' if length$perm;my$loc=$host;$loc .= ':'.$port if length$port;my$name=$self->name;$loc .= '/'.$name if$name ne '/';$self->type .'://' .$perm .$loc}1;
MAIL_BOX_NET

$fatpacked{"Mail/Box/Net/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_NET_MESSAGE';
  package Mail::Box::Net::Message;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Message';use strict;use warnings;use File::Copy;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->unique($args->{unique});$self}sub unique(;$) {my$self=shift;@_ ? $self->{MBNM_unique}=shift : $self->{MBNM_unique}}sub loadHead() {my$self=shift;my$head=$self->head;return$head unless$head->isDelayed;my$folder=$self->folder;$folder->lazyPermitted(1);my$parser=$self->parser or return;$self->readFromParser($parser);$folder->lazyPermitted(0);$self->log(PROGRESS=>'Loaded delayed head.');$self->head}sub loadBody() {my$self=shift;my$body=$self->body;return$body unless$body->isDelayed;my$head=$self->head;my$parser=$self->parser or return;if($head->isDelayed){$head=$self->readHead($parser);if(defined$head){$self->log(PROGRESS=>'Loaded delayed head.');$self->head($head)}else {$self->log(ERROR=>'Unable to read delayed head.');return}}else {my ($begin,$end)=$body->fileLocation;$parser->filePosition($begin)}my$newbody=$self->readBody($parser,$head);unless(defined$newbody){$self->log(ERROR=>'Unable to read delayed body.');return}$self->log(PROGRESS=>'Loaded delayed body.');$self->storeBody($newbody->contentInfoFrom($head))}1;
MAIL_BOX_NET_MESSAGE

$fatpacked{"Mail/Box/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_PARSER';
  package Mail::Box::Parser;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Carp;sub new(@) {my$class=shift;$class eq __PACKAGE__ ? $class->defaultParserType->new(@_): $class->SUPER::new(@_)}sub init(@) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MBP_mode}=$args->{mode}|| 'r';unless($self->{MBP_filename}=$args->{filename}|| ref$args->{file}){$self->log(ERROR=>"Filename or handle required to create a parser.");return}$self->start(file=>$args->{file})}sub start(@) {my$self=shift;my%args=(@_,filename=>$self->filename,mode=>$self->{MBP_mode});$self->openFile(\%args)or return;$self->takeFileInfo;$self->log(PROGRESS=>"Opened folder $args{filename} to be parsed");$self}sub stop() {my$self=shift;my$filename=$self->filename;$self->log(NOTICE=>"Close parser for file $filename");$self->closeFile}sub restart() {my$self=shift;my$filename=$self->filename;$self->closeFile;$self->openFile({filename=>$filename,mode=>$self->{MBP_mode}})or return;$self->takeFileInfo;$self->log(NOTICE=>"Restarted parser for file $filename");$self}sub fileChanged() {my$self=shift;my ($size,$mtime)=(stat$self->filename)[7,9];return 0 if!defined$size ||!defined$mtime;$size!=$self->{MBP_size}|| $mtime!=$self->{MBP_mtime}}sub filename() {shift->{MBP_filename}}sub filePosition(;$) {shift->NotImplemented}sub pushSeparator($) {shift->notImplemented}sub popSeparator($) {shift->notImplemented}sub readSeparator($) {shift->notImplemented}sub readHeader() {shift->notImplemented}sub bodyAsString() {shift->notImplemented}sub bodyAsList() {shift->notImplemented}sub bodyAsFile() {shift->notImplemented}sub bodyDelayed() {shift->notImplemented}sub lineSeparator() {shift->{MBP_linesep}}sub openFile(@) {shift->notImplemented}sub closeFile(@) {shift->notImplemented}sub takeFileInfo() {my$self=shift;@$self{qw/MBP_size MBP_mtime/ }=(stat$self->filename)[7,9]}my$parser_type;sub defaultParserType(;$) {my$class=shift;if(@_){$parser_type=shift;return$parser_type if$parser_type->isa(__PACKAGE__);confess "Parser $parser_type does not extend " .__PACKAGE__ ."\n"}return$parser_type if$parser_type;eval 'require Mail::Box::Parser::C';return$parser_type='Mail::Box::Parser::C' unless $@;require Mail::Box::Parser::Perl;$parser_type='Mail::Box::Parser::Perl'}sub DESTROY {my$self=shift;$self->stop;$self->SUPER::DESTROY}1;
MAIL_BOX_PARSER

$fatpacked{"Mail/Box/Parser/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_PARSER_PERL';
  package Mail::Box::Parser::Perl;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Box::Parser';use strict;use warnings;use Mail::Message::Field;use List::Util 'sum';use IO::File;sub init(@) {my ($self,$args)=@_;$self->SUPER::init($args)or return;$self->{MBPP_trusted}=$args->{trusted};$self->{MBPP_fix}=$args->{fix_header_errors};$self}sub pushSeparator($) {my ($self,$sep)=@_;unshift @{$self->{MBPP_separators}},$sep;$self->{MBPP_strip_gt}++ if$sep eq 'From ';$self}sub popSeparator() {my$self=shift;my$sep=shift @{$self->{MBPP_separators}};$self->{MBPP_strip_gt}-- if$sep eq 'From ';$sep}sub filePosition(;$) {my$self=shift;@_ ? $self->{MBPP_file}->seek(shift,0): $self->{MBPP_file}->tell}my$empty=qr/^\015?\012?$/;sub readHeader() {my$self=shift;my$file=$self->{MBPP_file};my@ret=($file->tell,undef);my$line=$file->getline;LINE: while(defined$line){last LINE if$line =~ $empty;my ($name,$body)=split /\s*\:\s*/,$line,2;unless(defined$body){$self->log(WARNING=>"Unexpected end of header in ".$self->filename.":\n $line");if(@ret && $self->fixHeaderErrors){$ret[-1][1].= ' '.$line;$line=$file->getline;next LINE}else {$file->seek(-length$line,1);last LINE}}$body="\n" unless length$body;while($line=$file->getline){$line =~ m!^[ \t]! ? ($body .= $line): last}$body =~ s/\015//g;push@ret,[$name,$body ]}$ret[1]=$file->tell;@ret}sub _is_good_end($) {my ($self,$where)=@_;my$sep=$self->{MBPP_separators}[0];return 1 unless defined$sep;my$file=$self->{MBPP_file};my$here=$file->tell;$file->seek($where,0)or return 0;my$line=$file->getline;$line=$file->getline while defined$line && $line =~ $empty;$file->seek($here,0);return 1 unless defined$line;substr($line,0,length$sep)eq $sep && ($sep ne 'From ' || $line =~ m/ (?:19[6-9]|20[0-2])[0-9]\b/)}sub readSeparator() {my$self=shift;my$sep=$self->{MBPP_separators}[0];return ()unless defined$sep;my$file=$self->{MBPP_file};my$start=$file->tell;my$line=$file->getline;while(defined$line && $line =~ $empty){$start=$file->tell;$line=$file->getline}return ()unless defined$line;$line =~ s/[\012\015]+$/\n/;return ($start,$line)if substr($line,0,length$sep)eq $sep;$file->seek($start,0);()}sub _read_stripped_lines(;$$) {my ($self,$exp_chars,$exp_lines)=@_;my@seps=@{$self->{MBPP_separators}};my$file=$self->{MBPP_file};my$lines=[];my$msgend;if(@seps){LINE: while(1){my$where=$file->getpos;my$line=$file->getline or last LINE;for my$sep (@seps){next if substr($line,0,length$sep)ne $sep;next if$sep eq 'From ' && $line !~ m/ 19[789][0-9]| 20[0-9][0-9]/;$file->setpos($where);$msgend=$file->tell;last LINE}push @$lines,$line}if(@$lines && $lines->[-1]=~ s/(\r?\n)\z//){pop @$lines if length($lines->[-1])==0}}else {$lines=ref$file eq 'Mail::Box::FastScalar' ? $file->getlines : [$file->getlines ]}my$bodyend=$file->tell;if($lines){if($self->{MBPP_strip_gt}){s/^\>(\>*From\s)/$1/ for @$lines}unless($self->{MBPP_trusted}){s/\015$// for @$lines}}($bodyend,$lines,$msgend)}sub _take_scalar($$) {my ($self,$begin,$end)=@_;my$file=$self->{MBPP_file};$file->seek($begin,0);my$return;$file->read($return,$end-$begin);$return =~ s/\015//g;$return}sub bodyAsString(;$$) {my ($self,$exp_chars,$exp_lines)=@_;my$file=$self->{MBPP_file};my$begin=$file->tell;if(defined$exp_chars && $exp_chars>=0){my$end=$begin + $exp_chars;if($self->_is_good_end($end)){my$body=$self->_take_scalar($begin,$end);$body =~ s/^\>(\>*From\s)/$1/gm if$self->{MBPP_strip_gt};return ($begin,$file->tell,$body)}}my ($end,$lines)=$self->_read_stripped_lines($exp_chars,$exp_lines);return ($begin,$end,join('',@$lines))}sub bodyAsList(;$$) {my ($self,$exp_chars,$exp_lines)=@_;my$file=$self->{MBPP_file};my$begin=$file->tell;my ($end,$lines)=$self->_read_stripped_lines($exp_chars,$exp_lines);($begin,$end,$lines)}sub bodyAsFile($;$$) {my ($self,$out,$exp_chars,$exp_lines)=@_;my$file=$self->{MBPP_file};my$begin=$file->tell;my ($end,$lines)=$self->_read_stripped_lines($exp_chars,$exp_lines);$out->print($_)foreach @$lines;($begin,$end,scalar @$lines)}sub bodyDelayed(;$$) {my ($self,$exp_chars,$exp_lines)=@_;my$file=$self->{MBPP_file};my$begin=$file->tell;if(defined$exp_chars){my$end=$begin + $exp_chars;if($self->_is_good_end($end)){$file->seek($end,0);return ($begin,$end,$exp_chars,$exp_lines)}}my ($end,$lines)=$self->_read_stripped_lines($exp_chars,$exp_lines);my$chars=sum(map {length}@$lines);($begin,$end,$chars,scalar @$lines)}sub openFile($) {my ($self,$args)=@_;my$mode=$args->{mode}or die "mode required";my$fh=$args->{file}|| IO::File->new($args->{filename},$mode);return unless$fh;$self->{MBPP_file}=$fh;$fh->binmode(':raw')if$fh->can('binmode')|| $fh->can('BINMODE');$self->{MBPP_separators}=[];$self}sub closeFile() {my$self=shift;delete$self->{MBPP_separators};delete$self->{MBPP_strip_gt};my$file=delete$self->{MBPP_file}or return;$file->close;$self}sub fixHeaderErrors(;$) {my$self=shift;@_ ? ($self->{MBPP_fix}=shift): $self->{MBPP_fix}}1;
MAIL_BOX_PARSER_PERL

$fatpacked{"Mail/Box/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_SEARCH';
  package Mail::Box::Search;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);my$in=$args->{in}|| 'BODY';@$self{qw/MBS_check_head MBS_check_body/ }=$in eq 'BODY' ? (0,1): $in eq 'HEAD' ? (1,0): $in eq 'MESSAGE' ? (1,1): ($self->log(ERROR=>"Search in BODY, HEAD or MESSAGE not $in."),return);$self->log(ERROR=>"Cannot search in header."),return if$self->{MBS_check_head}&&!$self->can('inHead');$self->log(ERROR=>"Cannot search in body."),return if$self->{MBS_check_body}&&!$self->can('inBody');my$deliver=$args->{deliver};$self->{MBS_deliver}=ref$deliver eq 'CODE' ? sub {$deliver->($self,$_[0])}:!defined$deliver ? undef : $deliver eq 'DELETE' ? sub {$_[0]->{part}->toplevel->label(deleted=>1)}: $self->log(ERROR=>"Don't know how to deliver results in $deliver.");my$logic=$args->{logical}|| 'REPLACE';$self->{MBS_negative}=$logic =~ s/\s*NOT\s*$//;$self->{MBS_logical}=$logic;$self->{MBS_label}=$args->{label};$self->{MBS_binaries}=$args->{binaries}|| 0;$self->{MBS_limit}=$args->{limit}|| 0;$self->{MBS_decode}=$args->{decode}|| 1;$self->{MBS_no_deleted}=not $args->{deleted};$self->{MBS_delayed}=defined$args->{delayed}? $args->{delayed}: 1;$self->{MBS_multiparts}=defined$args->{multiparts}? $args->{multiparts}: 1;$self}sub search(@) {my ($self,$object)=@_;my$label=$self->{MBS_label};my$limit=$self->{MBS_limit};my@messages =ref$object eq 'ARRAY' ? @$object : $object->isa('Mail::Box')? $object->messages : $object->isa('Mail::Message')? ($object): $object->isa('Mail::Box::Thread::Node')? $object->threadMessages : croak "Expect messages to search, not $object.";my$take=0;if($limit < 0){$take=-$limit;@messages=reverse@messages}elsif($limit > 0){$take=$limit}elsif(!defined$label &&!wantarray &&!$self->{MBS_deliver}){$take=1}my$logic=$self->{MBS_logical};my@selected;my$count=0;for my$message (@messages){next if$self->{MBS_no_deleted}&& $message->isDeleted;next unless$self->{MBS_delayed}||!$message->isDelayed;my$set=defined$label ? $message->label($label): 0;my$selected =$set && $logic eq 'OR' ? 1 :!$set && $logic eq 'AND' ? 0 : $self->{MBS_negative}?!$self->searchPart($message): $self->searchPart($message);$message->label($label=>$selected)if defined$label;if($selected){push@selected,$message;$count++;last if$take && $count==$take}}$limit < 0 ? reverse@selected : @selected}sub searchPart($) {my ($self,$part)=@_;my$matched=0;$matched=$self->inHead($part,$part->head)if$self->{MBS_check_head};return$matched unless$self->{MBS_check_body};return$matched if$matched &&!$self->{MBS_deliver};my$body=$part->body;my@bodies;if($body->isMultipart){return$matched unless$self->{MBS_multiparts};my$no_delayed=not $self->{MBS_delayed};@bodies=($body->preamble,$body->epilogue);for my$piece ($body->parts){next unless defined$piece;next if$no_delayed && $piece->isDelayed;$matched += $self->searchPart($piece);return$matched if$matched &&!$self->{MBS_deliver}}}elsif($body->isNested){return$matched unless$self->{MBS_multiparts};$matched += $self->searchPart($body->nested)}else {@bodies=($body)}for (@bodies){next unless defined $_;next if!$self->{MBS_binaries}&& $_->isBinary;my$body=$self->{MBS_decode}? $_->decoded : $_;my$inbody=$self->inBody($part,$body);$matched += $inbody}$matched}sub inHead(@) {shift->notImplemented}sub inBody(@) {shift->notImplemented}sub printMatch($) {shift->notImplemented}1;
MAIL_BOX_SEARCH

$fatpacked{"Mail/Box/Search/Grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_SEARCH_GREP';
  package Mail::Box::Search::Grep;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Search';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$args->{in}||=($args->{field}? 'HEAD' : 'BODY');my$deliver=$args->{deliver}|| $args->{details};$args->{deliver}=!defined$deliver ? $deliver : ref$deliver eq 'CODE' ? $deliver : $deliver eq 'PRINT' ? sub {$_[0]->printMatch($_[1])}: ref$deliver eq 'ARRAY' ? sub {push @$deliver,$_[1]}: $deliver;$self->SUPER::init($args);my$take=$args->{field};$self->{MBSG_field_check}=!defined$take ? sub {1}:!ref$take ? do {$take=lc$take;sub {$_[1]eq $take}}: ref$take eq 'Regexp' ? sub {$_[1]=~ $take}: ref$take eq 'CODE' ? $take : croak "Illegal field selector $take.";my$match=$args->{match}or croak "No match pattern specified.\n";$self->{MBSG_match_check}=!ref$match ? sub {index("$_[1]",$match)>= $[}: ref$match eq 'Regexp' ? sub {"$_[1]" =~ $match}: ref$match eq 'CODE' ? $match : croak "Illegal match pattern $match.";$self}sub search(@) {my ($self,$object,%args)=@_;delete$self->{MBSG_last_printed};$self->SUPER::search($object,%args)}sub inHead(@) {my ($self,$part,$head,$args)=@_;my@details=(message=>$part->toplevel,part=>$part);my ($field_check,$match_check,$deliver)=@$self{qw/MBSG_field_check MBSG_match_check MBS_deliver/ };my$matched=0;LINES: foreach my$field ($head->orderedFields){next unless$field_check->($head,$field->name)&& $match_check->($head,$field);$matched++;last LINES unless$deliver;$deliver->({@details,field=>$field})}$matched}sub inBody(@) {my ($self,$part,$body,$args)=@_;my@details=(message=>$part->toplevel,part=>$part);my ($field_check,$match_check,$deliver)=@$self{qw/MBSG_field_check MBSG_match_check MBS_deliver/ };my$matched=0;my$linenr=0;LINES: foreach my$line ($body->lines){$linenr++;next unless$match_check->($body,$line);$matched++;last LINES unless$deliver;$deliver->({@details,linenr=>$linenr,line=>$line})}$matched}sub printMatch($;$) {my$self=shift;my ($out,$match)=@_==2 ? @_ : (select,shift);$match->{field}? $self->printMatchedHead($out,$match): $self->printMatchedBody($out,$match)}sub printMatchedHead($$) {my ($self,$out,$match)=@_;my$message=$match->{message};my$msgnr=$message->seqnr;my$folder=$message->folder->name;my$lp=$self->{MBSG_last_printed}|| '';unless($lp eq "$folder $msgnr"){my$subject=$message->subject;$out->print("$folder, message $msgnr: $subject\n");$self->{MBSG_last_printed}="$folder $msgnr"}my@lines=$match->{field}->string;my$inpart=$match->{part}->isPart ? 'p ' : '  ';$out->print($inpart,join$inpart,@lines);$self}sub printMatchedBody($$) {my ($self,$out,$match)=@_;my$message=$match->{message};my$msgnr=$message->seqnr;my$folder=$message->folder->name;my$lp=$self->{MBSG_last_printed}|| '';unless($lp eq "$folder $msgnr"){my$subject=$message->subject;$out->print("$folder, message $msgnr: $subject\n");$self->{MBSG_last_printed}="$folder $msgnr"}my$inpart=$match->{part}->isPart ? 'p ' : '  ';$out->print(sprintf "$inpart %2d: %s",$match->{linenr},$match->{line});$self}1;
MAIL_BOX_SEARCH_GREP

$fatpacked{"Mail/Box/Search/SpamAssassin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_SEARCH_SPAMASSASSIN';
  package Mail::Box::Search::SpamAssassin;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Box::Search';use strict;use warnings;use Mail::SpamAssassin;use Mail::Message::Wrapper::SpamAssassin;sub init($) {my ($self,$args)=@_;$args->{in}||='MESSAGE';$args->{label}='spam' unless exists$args->{label};$self->SUPER::init($args);$self->{MBSS_rewrite_mail}=defined$args->{rewrite_mail}? $args->{rewrite_mail}: 1;$self->{MBSS_sa}=defined$args->{spamassassin}? $args->{spamassassin}: Mail::SpamAssassin->new($args->{sa_options}|| {});$self}sub assassinator() {shift->{MBSS_sa}}sub searchPart($) {my ($self,$message)=@_;my@details=(message=>$message);my$sa=Mail::Message::Wrapper::SpamAssassin->new($message)or return;my$status=$self->assassinator->check($sa);my$is_spam=$status->is_spam;$status->rewrite_mail if$self->{MBSS_rewrite_mail};if($is_spam){my$deliver=$self->{MBS_deliver};$deliver->({@details,status=>$status})if defined$deliver}$is_spam}sub inHead(@) {shift->notImplemented}sub inBody(@) {shift->notImplemented}1;
MAIL_BOX_SEARCH_SPAMASSASSIN

$fatpacked{"Mail/Box/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_TEST';
  package Mail::Box::Test;use vars '$VERSION';$VERSION='3.007';use base 'Exporter';use strict;use warnings;use File::Copy 'copy';use List::Util 'first';use IO::File;use File::Spec;use Cwd qw(getcwd);use Sys::Hostname qw(hostname);use Test::More;our@EXPORT=qw/clean_dir copy_dir unpack_mbox2mh unpack_mbox2maildir compare_lists listdir compare_message_prints reproducable_text compare_thread_dumps $folderdir $src $unixsrc $winsrc $fn $unixfn $winfn $cpy $cpyfn $raw_html_data $crlf_platform $windows/;our ($logfile,$folderdir);our ($src,$unixsrc,$winsrc);our ($fn,$unixfn,$winfn);our ($cpy,$cpyfn);our ($crlf_platform,$windows);BEGIN {$windows=$^O =~ m/mswin32/i;$crlf_platform=$windows;$folderdir=File::Spec->catdir('t','folders');$logfile=File::Spec->catfile(getcwd(),'run-log');$unixfn='mbox.src';$winfn='mbox.win';$cpyfn='mbox.cpy';$unixsrc=File::Spec->catfile($folderdir,$unixfn);$winsrc=File::Spec->catfile($folderdir,$winfn);$cpy=File::Spec->catfile($folderdir,$cpyfn);($src,$fn)=$windows ? ($winsrc,$winfn): ($unixsrc,$unixfn);require Mail::Box::Parser::Perl;Mail::Box::Parser->defaultParserType('Mail::Box::Parser::Perl')}sub clean_dir($);sub clean_dir($) {my$dir=shift;local*DIR;opendir DIR,$dir or return;my@items=map {m/(.*)/ && "$dir/$1"}grep!/^\.\.?$/,readdir DIR;for (@items){if(-d){clean_dir $_}else {unlink $_}}closedir DIR;rmdir$dir}sub copy_dir($$) {my ($orig,$dest)=@_;clean_dir($dest);mkdir$dest or die "Cannot create copy destination $dest: $!\n";opendir ORIG,$orig or die "Cannot open directory $orig: $!\n";for my$name (map {!m/^\.\.?$/ && m/(.*)/ ? $1 : ()}readdir ORIG){my$from=File::Spec->catfile($orig,$name);next if -d $from;my$to=File::Spec->catfile($dest,$name);copy($from,$to)or die "Couldn't copy $from,$to: $!\n"}close ORIG}sub unpack_mbox2mh($$) {my ($file,$dir)=@_;clean_dir($dir);mkdir$dir,0700;my$count=1;my$blank;open FILE,$file or die;open OUT,'>',File::Spec->devnull;while(<FILE>){if(/^From /){close OUT;undef$blank;open OUT,">$dir/".$count++ or die;$count++ if$count==13;next}print OUT$blank if defined$blank;if(m/^\015?\012$/){$blank=$_;next}undef$blank;print OUT}close OUT;close FILE}our@maildir_names=('8000000.localhost.23:2,' ,'90000000.localhost.213:2,' ,'110000000.localhost.12:2,' ,'110000001.l.42:2,' ,'110000002.l.42:2,' ,'110000002.l.43:2,' ,'110000004.l.43:2,' ,'110000005.l.43:2,' ,'110000006.l.43:2,' ,'110000007.l.43:2,D' ,'110000008.l.43:2,DF' ,'110000009.l.43:2,DFR' ,'110000010.l.43:2,DFRS' ,'110000011.l.43:2,DFRST' ,'110000012.l.43:2,F' ,'110000013.l.43:2,FR' ,'110000014.l.43:2,FRS' ,'110000015.l.43:2,FRST' ,'110000016.l.43:2,DR' ,'110000017.l.43:2,DRS' ,'110000018.l.43:2,DRST' ,'110000019.l.43:2,FS' ,'110000020.l.43:2,FST' ,'110000021.l.43:2,R' ,'110000022.l.43:2,RS' ,'110000023.l.43:2,RST' ,'110000024.l.43:2,S' ,'110000025.l.43:2,ST' ,'110000026.l.43:2,T' ,'110000027.l.43:2,' ,'110000028.l.43:2,' ,'110000029.l.43:2,' ,'110000030.l.43:2,' ,'110000031.l.43:2,' ,'110000032.l.43:2,' ,'110000033.l.43:2,' ,'110000034.l.43:2,' ,'110000035.l.43:2,' ,'110000036.l.43:2,' ,'110000037.l.43:2,' ,'110000038.l.43' ,'110000039.l.43' ,'110000040.l.43' ,'110000041.l.43' ,'110000042.l.43');sub unpack_mbox2maildir($$) {my ($file,$dir)=@_;clean_dir($dir);die unless@maildir_names==45;mkdir$dir or die;mkdir File::Spec->catfile($dir,'cur')or die;mkdir File::Spec->catfile($dir,'new')or die;mkdir File::Spec->catfile($dir,'tmp')or die;my$msgnr=0;open FILE,$file or die;open OUT,'>',File::Spec->devnull;my$last_empty=0;my$blank;while(<FILE>){if(m/^From /){close OUT;undef$blank;my$now=time;my$hostname=hostname;my$msgfile=File::Spec->catfile($dir ,($msgnr > 40 ? 'new' : 'cur'),$maildir_names[$msgnr++]);open OUT,">",$msgfile or die "Create $msgfile: $!\n";next}print OUT$blank if defined$blank;if(m/^\015?\012$/){$blank=$_;next}undef$blank;print OUT}close OUT;close FILE}sub compare_lists($$) {my ($first,$second)=@_;return 0 unless @$first==@$second;for(my$i=0;$i<@$first;$i++){return 0 unless$first->[$i]eq $second->[$i]}1}sub compare_message_prints($$$) {my ($first,$second,$label)=@_;if($crlf_platform){$first =~ s/Content-Length: (\d+)/Content-Length: <removed>/g;$second =~ s/Content-Length: (\d+)/Content-Length: <removed>/g}is($first,$second,$label)}sub reproducable_text($) {my$text=shift;my@lines=split /^/m,$text;for (@lines){s/((?:references|message-id|date|content-length)\: ).*/$1<removed>/i;s/boundary-\d+/boundary-<removed>/g}join '',@lines}sub compare_thread_dumps($$$) {my ($first,$second,$label)=@_;if($crlf_platform){$first =~ s/^..../    /gm;$second =~ s/^..../    /gm}is($first,$second,$label)}sub listdir($) {my$dir=shift;opendir LISTDIR,$dir or return ();my@entities=grep!/^\.\.?$/,readdir LISTDIR;closedir LISTDIR;@entities}our$raw_html_data=<<'TEXT';1;
  <HTML>
  <HEAD>
  <TITLE>My home page</TITLE>
  </HEAD>
  <BODY BGCOLOR=red>
  
  <H1>Life according to Brian</H1>
  
  This is normal text, but not in a paragraph.<P>New paragraph
  in a bad way.
  
  And this is just a continuation.  When texts get long, they must be
  auto-wrapped; and even that is working already.
  
  <H3>Silly subsection at once</H3>
  <H1>and another chapter</H1>
  <H2>again a section</H2>
  <P>Normal paragraph, which contains an <IMG
  SRC=image.gif>, some
  <I>italics with linebreak
  </I> and <TT>code</TT>
  
  <PRE>
  And now for the preformatted stuff
     it should stay as it was
        even   with   strange blanks
    and indentations
  </PRE>
  
  And back to normal text...
  <UL>
  <LI>list item 1
      <OL>
      <LI>list item 1.1
      <LI>list item 1.2
      </OL>
  <LI>list item 2
  </UL>
  </BODY>
  </HTML>
  TEXT
MAIL_BOX_TEST

$fatpacked{"Mail/Box/Thread/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_THREAD_MANAGER';
  package Mail::Box::Thread::Manager;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Carp;use Mail::Box::Thread::Node;use Mail::Message::Dummy;sub init($) {my ($self,$args)=@_;$self->{MBTM_manager}=$args->{manager}or croak "Need a manager to work with.";$self->{MBTM_thread_body}=$args->{thread_body}|| 0;$self->{MBTM_thread_type}=$args->{thread_type}||'Mail::Box::Thread::Node';$self->{MBTM_dummy_type}=$args->{dummy_type}||'Mail::Message::Dummy';for($args->{timespan}|| '3 days'){$self->{MBTM_timespan}=$_ eq 'EVER' ? 'EVER' : Mail::Box->timespan2seconds($_)}for($args->{window}|| 10){$self->{MBTM_window}=$_ eq 'ALL' ? 'ALL' : $_}$self}sub folders() {values %{shift->{MBTM_folders}}}sub includeFolder(@) {my$self=shift;for my$folder (@_){croak "Not a folder: $folder" unless ref$folder && $folder->isa('Mail::Box');my$name=$folder->name;next if exists$self->{MBTM_folders}{$name};$self->{MBTM_folders}{$name}=$folder;for my$msg ($folder->messages){$self->inThread($msg)unless$msg->head->isDelayed}}$self}sub removeFolder(@) {my$self=shift;for my$folder (@_){croak "Not a folder: $folder" unless ref$folder && $folder->isa('Mail::Box');my$name=$folder->name;next unless exists$self->{MBTM_folders}{$name};delete$self->{MBTM_folders}{$name};$_->headIsRead && $self->outThread($_)foreach$folder->messages;$self->{MBTM_cleanup_needed}=1}$self}sub thread($) {my ($self,$message)=@_;my$msgid=$message->messageId;my$timestamp=$message->timestamp;$self->_process_delayed_nodes;my$thread=$self->{MBTM_ids}{$msgid}|| return;my@missing;$thread->recurse (sub {my$node=shift;push@missing,$node->messageId if$node->isDummy;1});return$thread unless@missing;for my$folder ($self->folders){my@now_missing=$folder->scanForMessages ($msgid ,[@missing ],$timestamp - 3600 ,0);if(@now_missing!=@missing){$self->_process_delayed_nodes;last unless@now_missing;@missing=@now_missing}}$thread}sub threadStart($) {my ($self,$message)=@_;my$thread=$self->thread($message)|| return;while(my$parent=$thread->repliedTo){unless($parent->isDummy){$thread=$parent;next}for ($self->folders){my$message=$thread->message;my$timespan=$message->isDummy ? 'ALL' : $message->timestamp - $self->{MBTM_timespan};last unless $_->scanForMessages ($thread->messageId,$parent->messageId ,$timespan,$self->{MBTM_window})}$self->_process_delayed_nodes;$thread=$parent}$thread}sub all() {my$self=shift;$_->find('not-existing')for$self->folders;$self->known}sub sortedAll(@) {my$self=shift;$_->find('not-existing')for$self->folders;$self->sortedKnown(@_)}sub known() {my$self=shift->_process_delayed_nodes->_cleanup;grep {!defined $_->repliedTo}values %{$self->{MBTM_ids}}}sub sortedKnown(;$$) {my$self=shift;my$prepare=shift || sub {shift->startTimeEstimate||0};my$compare=shift || sub {(shift)<=> (shift)};my%value;push @{$value{$prepare->($_)}},$_ for$self->known;map @{$value{$_}},sort {$compare->($a,$b)}keys%value}sub _cleanup() {my$self=shift;return$self unless$self->{MBTM_cleanup_needed};for ($self->known){my$real=0;$_->recurse (sub {my$node=shift;for ($node->messages){next if $_->isDummy;$real=1;return 0}1});next if$real;$_->recurse (sub {my$node=shift;my$msgid=$node->messageId;delete$self->{MBTM_ids}{$msgid};1})}delete$self->{MBTM_cleanup_needed};$self}sub toBeThreaded($@) {my ($self,$folder)=(shift,shift);return$self unless exists$self->{MBTM_folders}{$folder->name};$self->inThread($_)foreach @_;$self}sub toBeUnthreaded($@) {my ($self,$folder)=(shift,shift);return$self unless exists$self->{MBTM_folders}{$folder->name};$self->outThread($_)foreach @_;$self}sub inThread($) {my ($self,$message)=@_;my$msgid=$message->messageId;my$node=$self->{MBTM_ids}{$msgid};if($node){$node->addMessage($message)}else {$node=Mail::Box::Thread::Node->new(message=>$message ,msgid=>$msgid,dummy_type=>$self->{MBTM_dummy_type});$self->{MBTM_ids}{$msgid}=$node}$self->{MBTM_delayed}{$msgid}=$node}sub _process_delayed_nodes() {my$self=shift;return$self unless$self->{MBTM_delayed};for my$node (values %{$self->{MBTM_delayed}}){$self->_process_delayed_message($node,$_)foreach$node->message}delete$self->{MBTM_delayed};$self}sub _process_delayed_message($$) {my ($self,$node,$message)=@_;my$msgid=$message->messageId;my$head=$message->head or return$self;my$replies;if(my$irt=$head->get('in-reply-to')){for($irt =~ m/\<(\S+\@\S+)\>/){my$msgid=$1;$replies=$self->{MBTM_ids}{$msgid}|| $self->createDummy($msgid)}}my@refs;if(my$refs=$head->get('references')){while($refs =~ s/\<(\S+\@\S+)\>//s){my$msgid=$1;push@refs,$self->{MBTM_ids}{$msgid}|| $self->createDummy($msgid)}}if($replies){$node->follows($replies,'REPLY')and $replies->followedBy($node)}if(@refs){push@refs,$node unless$refs[-1]eq $node;my$from=shift@refs;while(my$to=shift@refs){$to->follows($from,'REFERENCE')and $from->followedBy($to);$from=$to}}$self}sub outThread($) {my ($self,$message)=@_;my$msgid=$message->messageId;my$node=$self->{MBTM_ids}{$msgid}or return$message;$node->{MBTM_messages}=[grep {$_ ne $message}@{$node->{MBTM_messages}}];$self}sub createDummy($) {my ($self,$msgid)=@_;$self->{MBTM_ids}{$msgid}=$self->{MBTM_thread_type}->new (msgid=>$msgid,dummy_type=>$self->{MBTM_dummy_type})}1;
MAIL_BOX_THREAD_MANAGER

$fatpacked{"Mail/Box/Thread/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_THREAD_NODE';
  package Mail::Box::Thread::Node;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Carp;sub new(@) {my ($class,%args)=@_;(bless {},$class)->init(\%args)}sub init($) {my ($self,$args)=@_;if(my$message=$args->{message}){push @{$self->{MBTN_messages}},$message;$self->{MBTN_msgid}=$args->{msgid}|| $message->messageId}elsif(my$msgid=$args->{msgid}){$self->{MBTN_msgid}=$msgid}else {croak "Need to specify message or message-id"}$self->{MBTN_dummy_type}=$args->{dummy_type};$self}sub message() {my$self=shift;unless($self->{MBTN_messages}){return ()if wantarray;my$dummy=$self->{MBTN_dummy_type}->new (messageId=>$self->{MBTN_msgid});push @{$self->{MBTN_messages}},$dummy;return$dummy}my@messages=@{$self->{MBTN_messages}};return@messages if wantarray;return$messages[0]if@messages==1;for (@messages){return $_ unless $_->isDeleted}$messages[0]}sub addMessage($) {my ($self,$message)=@_;return$self->{MBTN_messages}=[$message ]if$self->isDummy;push @{$self->{MBTN_messages}},$message;$message}sub isDummy() {my$self=shift;!defined$self->{MBTN_messages}|| $self->{MBTN_messages}[0]->isDummy}sub messageId() {shift->{MBTN_msgid}}sub expand(;$) {my$self=shift;return$self->message->label('folded')|| 0 unless @_;my$fold=not shift;$_->label(folded=>$fold)foreach$self->message;$fold}sub folded(;$) {@_==1 ? shift->expand : shift->expand(not shift)}sub repliedTo() {my$self=shift;return wantarray ? ($self->{MBTN_parent},$self->{MBTN_quality}): $self->{MBTN_parent}}sub follows($$) {my ($self,$thread,$how)=@_;my$quality=$self->{MBTN_quality};my$msgid=$self->messageId;for(my$walker=$thread;defined$walker;$walker=$walker->repliedTo){return undef if$walker->messageId eq $msgid}my$threadid=$thread->messageId;for ($self->followUps){return undef if $_->messageId eq $threadid}if($how eq 'REPLY' ||!defined$quality){$self->{MBTN_parent}=$thread;$self->{MBTN_quality}=$how;return$self}return$self if$quality eq 'REPLY';if($how eq 'REFERENCE' || ($how eq 'GUESS' && $quality ne 'REFERENCE')){$self->{MBTN_parent}=$thread;$self->{MBTN_quality}=$how}$self}sub followedBy(@) {my$self=shift;$self->{MBTN_followUps}{$_->messageId}=$_ foreach @_;$self}sub followUps() {my$self=shift;$self->{MBTN_followUps}? values %{$self->{MBTN_followUps}}: ()}sub sortedFollowUps() {my$self=shift;my$prepare=shift || sub {shift->startTimeEstimate||0};my$compare=shift || sub {(shift)<=> (shift)};my%value=map {($prepare->($_)=>$_)}$self->followUps;map {$value{$_}}sort {$compare->($a,$b)}keys%value}sub threadToString(;$$$) {my$self=shift;my$code=shift || sub {shift->head->study('subject')};my ($first,$other)=(shift || '',shift || '');my$message=$self->message;my@follows=$self->sortedFollowUps;my@out;if($self->folded){my$text=$code->($message)|| '';chomp$text;return "    $first [" .$self->nrMessages ."] $text\n"}elsif($message->isDummy){$first .= $first ? '-*-' : ' *-';return (shift@follows)->threadToString($code,$first,"$other   ")if@follows==1;push@out,(shift@follows)->threadToString($code,$first,"$other | ")while@follows > 1}else {my$text=$code->($message)|| '';chomp$text;my$size=$message->shortSize;@out="$size$first $text\n";push@out,(shift@follows)->threadToString($code,"$other |-","$other | ")while@follows > 1}push@out,(shift@follows)->threadToString($code,"$other `-","$other   ")if@follows;join '',@out}sub startTimeEstimate() {my$self=shift;return$self->message->timestamp unless$self->isDummy;my$earliest;for ($self->followUps){my$stamp=$_->startTimeEstimate;$earliest=$stamp if!defined$earliest || (defined$stamp && $stamp < $earliest)}$earliest}sub endTimeEstimate() {my$self=shift;my$latest;$self->recurse (sub {my$node=shift;unless($node->isDummy){my$stamp=$node->message->timestamp;$latest=$stamp if!$latest || $stamp > $latest}});$latest}sub recurse($) {my ($self,$code)=@_;$code->($self)or return$self;$_->recurse($code)or last foreach$self->followUps;$self}sub totalSize() {my$self=shift;my$total=0;$self->recurse (sub {my@msgs=shift->messages;$total += $msgs[0]->size if@msgs;1});$total}sub numberOfMessages() {my$self=shift;my$total=0;$self->recurse(sub {++$total unless shift->isDummy;1});$total}sub nrMessages() {shift->numberOfMessages}sub threadMessages() {my$self=shift;my@messages;$self->recurse (sub {my$node=shift;push@messages,$node->message unless$node->isDummy;1});@messages}sub ids() {my$self=shift;my@ids;$self->recurse(sub {push@ids,shift->messageId});@ids}1;
MAIL_BOX_THREAD_NODE

$fatpacked{"Mail/Box/Tie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_TIE';
  package Mail::Box::Tie;use vars '$VERSION';$VERSION='3.007';use strict;use warnings;use Carp;sub TIEHASH(@) {my$class=(shift)."::HASH";eval "require $class";confess $@ if $@;$class->TIEHASH(@_)}sub TIEARRAY(@) {my$class=(shift)."::ARRAY";eval "require $class";confess $@ if $@;$class->TIEARRAY(@_)}1;
MAIL_BOX_TIE

$fatpacked{"Mail/Box/Tie/ARRAY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_TIE_ARRAY';
  package Mail::Box::Tie::ARRAY;use vars '$VERSION';$VERSION='3.007';use strict;use warnings;use Carp;sub TIEARRAY(@) {my ($class,$folder)=@_;croak "No folder specified to tie to." unless ref$folder && $folder->isa('Mail::Box');bless {MBT_folder=>$folder },$class}sub FETCH($) {my ($self,$index)=@_;my$msg=$self->{MBT_folder}->message($index);$msg->isDeleted ? undef : $msg}sub STORE($$) {my ($self,$index,$msg)=@_;my$folder=$self->{MBT_folder};croak "Cannot simply replace messages in a folder: use delete old, then push new." unless$index==$folder->messages;$folder->addMessages($msg);$msg}sub FETCHSIZE() {scalar shift->{MBT_folder}->messages}sub PUSH(@) {my$folder=shift->{MBT_folder};$folder->addMessages(@_);scalar$folder->messages}sub DELETE($) {shift->{MBT_folder}->message(shift)->delete}sub STORESIZE($) {my$folder=shift->{MBT_folder};my$length=shift;$folder->message($_)foreach$length..$folder->messages;$length}1;
MAIL_BOX_TIE_ARRAY

$fatpacked{"Mail/Box/Tie/HASH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_BOX_TIE_HASH';
  package Mail::Box::Tie::HASH;use vars '$VERSION';$VERSION='3.007';use strict;use warnings;use Carp;sub TIEHASH(@) {my ($class,$folder)=@_;croak "No folder specified to tie to." unless ref$folder && $folder->isa('Mail::Box');bless {MBT_folder=>$folder,MBT_type=>'HASH' },$class}sub FETCH($) {shift->{MBT_folder}->messageId(shift)}sub STORE($$) {my ($self,$key,$basicmsg)=@_;carp "Use undef as key, because the message-id of the message is used." if defined$key && $key ne 'undef';$self->{MBT_folder}->addMessages($basicmsg)}sub FIRSTKEY() {my$self=shift;my$folder=$self->{MBT_folder};$self->{MBT_each_index}=0;$self->NEXTKEY()}sub NEXTKEY($) {my$self=shift;my$folder=$self->{MBT_folder};my$nrmsgs=$folder->messages;my$msg;while(1){my$index=$self->{MBT_each_index}++;return undef if$index >= $nrmsgs;$msg=$folder->message($index);last unless$msg->isDeleted}$msg->messageId}sub EXISTS($) {my$folder=shift->{MBT_folder};my$msgid=shift;my$msg=$folder->messageId($msgid);defined$msg &&!$msg->isDeleted}sub DELETE($) {my ($self,$msgid)=@_;$self->{MBT_folder}->messageId($msgid)->delete}sub CLEAR() {my$folder=shift->{MBT_folder};$_->delete foreach$folder->messages}1;
MAIL_BOX_TIE_HASH

$fatpacked{"Mail/Cap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_CAP';
  package Mail::Cap;use vars '$VERSION';$VERSION='2.21';use strict;sub Version {our$VERSION}our$useCache=1;my@path;if($^O eq "MacOS"){@path=split /\,/,$ENV{MAILCAPS}|| "$ENV{HOME}mailcap"}else {@path=split /\:/ ,($ENV{MAILCAPS}|| (defined$ENV{HOME}? "$ENV{HOME}/.mailcap:" : '').'/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap')}sub new {my$class=shift;unshift @_,'filename' if @_ % 2;my%args=@_;my$take_all=$args{take}&& uc$args{take}eq 'ALL';my$self=bless {_count=>0},$class;$self->_process_file($args{filename})if defined$args{filename}&& -r $args{filename};if(!defined$args{filename}|| $take_all){for my$fname (@path){-r $fname or next;$self->_process_file($fname);last unless$take_all}}unless($self->{_count}){$self->{'audio/*'}=[{'view'=>"showaudio %s"}];$self->{'image/*'}=[{'view'=>"xv %s"}];$self->{'message/rfc822'}=[{'view'=>"xterm -e metamail %s"}]}$self}sub _process_file {my$self=shift;my$file=shift or return;local*MAILCAP;open MAILCAP,$file or return;$self->{_file}=$file;local $_;while(<MAILCAP>){next if /^\s*#/;next if /^\s*$/;$_ .= <MAILCAP> while s/(^|[^\\])((?:\\\\)*)\\\s*$/$1$2/;chomp;s/\0//g;s/(^|[^\\]);/$1\0/g;my ($type,$view,@parts)=split /\s*\0\s*/;$type .= "/*" if$type !~ m[/];$view =~ s/\\;/;/g;$view =~ s/\\\\/\\/g;my%field=(view=>$view);for (@parts){my($key,$val)=split /\s*\=\s*/,$_,2;if(defined$val){$val =~ s/\\;/;/g;$val =~ s/\\\\/\\/g;$field{$key}=$val}else {$field{$key}=1}}if(my$test=$field{test}){unless ($test =~ /\%/){system$test;next if $?}}unless(exists$self->{$type}){$self->{$type}=[];$self->{_count}++}push @{$self->{$type}},\%field}close MAILCAP}sub view {my$self=shift;$self->_run($self->viewCmd(@_))}sub compose {my$self=shift;$self->_run($self->composeCmd(@_))}sub edit {my$self=shift;$self->_run($self->editCmd(@_))}sub print {my$self=shift;$self->_run($self->printCmd(@_))}sub _run($) {my ($self,$cmd)=@_;defined$cmd or return 0;system$cmd;1}sub viewCmd {shift->_createCommand(view=>@_)}sub composeCmd {shift->_createCommand(compose=>@_)}sub editCmd {shift->_createCommand(edit=>@_)}sub printCmd {shift->_createCommand(print=>@_)}sub _createCommand($$$) {my ($self,$method,$type,$file)=@_;my$entry=$self->getEntry($type,$file);$entry && exists$entry->{$method}or return undef;$self->expandPercentMacros($entry->{$method},$type,$file)}sub makeName($$) {my ($self,$type,$basename)=@_;my$template=$self->nametemplate($type)or return$basename;$template =~ s/%s/$basename/g;$template}sub field($$) {my($self,$type,$field)=@_;my$entry=$self->getEntry($type);$entry->{$field}}sub description {shift->field(shift,'description')}sub textualnewlines {shift->field(shift,'textualnewlines')}sub x11_bitmap {shift->field(shift,'x11-bitmap')}sub nametemplate {shift->field(shift,'nametemplate')}sub getEntry {my($self,$origtype,$file)=@_;return$self->{_cache}{$origtype}if$useCache && exists$self->{_cache}{$origtype};my ($fulltype,@params)=split /\s*;\s*/,$origtype;my ($type,$subtype)=split m[/],$fulltype,2;$subtype ||='';my$entry;for (@{$self->{"$type/$subtype"}},@{$self->{"$type/*"}}){if(exists $_->{'test'}){my$test=$self->expandPercentMacros($_->{'test'},$origtype,$file);system$test;next if $?}$entry={%$_ };last}$self->{_cache}{$origtype}=$entry if$useCache;$entry}sub expandPercentMacros {my ($self,$text,$type,$file)=@_;defined$type or return$text;defined$file or $file="";my ($fulltype,@params)=split /\s*;\s*/,$type;($type,my$subtype)=split m[/],$fulltype,2;my%params;for (@params){my($key,$val)=split /\s*=\s*/,$_,2;$params{$key}=$val}$text =~ s/\\%/\0/g;$text =~ s/%t/$fulltype/g;$text =~ s/%s/$file/g;{local $^W=0;$text =~ s/%\{\s*(.*?)\s*\}/$params{$1}/g}$text =~ s/\0/%/g;$text}sub dumpEntry {my($hash,$prefix)=@_;defined$prefix or $prefix="";print "$prefix$_ = $hash->{$_}\n" for sort keys %$hash}sub dump {my$self=shift;for (keys %$self){next if /^_/;print "$_\n";for (@{$self->{$_}}){dumpEntry($_,"\t");print "\n"}}if(exists$self->{_cache}){print "Cached types\n";print "\t$_\n" for keys %{$self->{_cache}}}}1;
MAIL_CAP

$fatpacked{"Mail/Field.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_FIELD';
  package Mail::Field;use vars '$VERSION';$VERSION='2.21';use strict;use Carp;use Mail::Field::Generic;sub _header_pkg_name {my$header=lc shift;$header =~ s/((\b|_)\w)/\U$1/g;if(length($header)> 8){my@header=split /[-_]+/,$header;my$chars=int((7 + @header)/ @header)|| 1;$header=substr join('',map {substr $_,0,$chars}@header),0,8}else {$header =~ s/[-_]+//g}'Mail::Field::' .$header}sub _require_dir {my($class,$dir,$dir_sep)=@_;local*DIR;opendir DIR,$dir or return;my@inc;for my$f (readdir DIR){$f =~ /^([\w\-]+)/ or next;my$p=$1;my$n="$dir$dir_sep$p";if(-d $n){_require_dir("${class}::$f",$n,$dir_sep)}else {$p =~ s/-/_/go;eval "require ${class}::$p";warn $@ if $@}}closedir DIR}sub import {my$class=shift;if(@_){local $_;eval "require " ._header_pkg_name($_)|| die $@ for @_;return}my ($dir,$dir_sep);for my$f (grep defined$INC{$_},keys%INC){next if$f !~ /^Mail(\W)Field\W/i;$dir_sep=$1;($dir=$INC{$f})=~ s/(Mail\W+Field).*/$1$dir_sep/;last}_require_dir('Mail::Field',$dir,$dir_sep)}sub register {my$thing=shift;my$method=lc shift;my$class=shift || ref($thing)|| $thing;$method =~ tr/-/_/;$class=_header_pkg_name$method if$class eq "Mail::Field";croak "Re-register of $method" if Mail::Field->can($method);no strict 'refs';*{$method}=sub {shift;$class->can('stringify')or eval "require $class" or die $@;$class->_build(@_)}}sub _build {my$self=bless {},shift;@_==1 ? $self->parse(@_): $self->create(@_)}sub new {my$class=shift;my$field=lc shift;$field =~ tr/-/_/;$class->$field(@_)}sub combine {confess "Combine not implemented"}our$AUTOLOAD;sub AUTOLOAD {my$method=$AUTOLOAD;$method =~ s/.*:://;$method =~ /^[^A-Z\x00-\x1f\x80-\xff :]+$/ or croak "Undefined subroutine &$AUTOLOAD called";my$class=_header_pkg_name$method;unless(eval "require $class"){my$tag=$method;$tag =~ s/_/-/g;$tag=join '-',map {/^[b-df-hj-np-tv-z]+$|^MIME$/i ? uc($_): ucfirst(lc $_)}split /\-/,$tag;no strict;@{"${class}::ISA"}=qw(Mail::Field::Generic);*{"${class}::tag"}=sub {$tag}}Mail::Field->can($method)or $class->register($method);goto &$AUTOLOAD}sub extract {my ($class,$tag,$head)=(shift,shift,shift);my$method=lc$tag;$method =~ tr/-/_/;if(@_==0 && wantarray){my@ret;my$text;for$text ($head->get($tag)){chomp$text;push@ret,$class->$method($text)}return@ret}my$idx=shift || 0;my$text=$head->get($tag,$idx)or return undef;chomp$text;$class->$method($text)}sub create {my ($self,%arg)=@_;%$self=();$self->set(\%arg)}sub parse {my$class=ref shift;confess "parse() not implemented"}sub stringify {confess "stringify() not implemented"}sub tag {my$thing=shift;my$tag=ref($thing)|| $thing;$tag =~ s/.*:://;$tag =~ s/_/-/g;join '-',map {/^[b-df-hj-np-tv-z]+$|^MIME$/i ? uc($_): ucfirst(lc $_)}split /\-/,$tag}sub set(@) {confess "set() not implemented"}sub DESTROY {}sub text {my$self=shift;@_ ? $self->parse(@_): $self->stringify}1;
MAIL_FIELD

$fatpacked{"Mail/Field/AddrList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_FIELD_ADDRLIST';
  use strict;package Mail::Field::AddrList;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Field';use Carp;use Mail::Address;my$x=bless [];$x->register('To');$x->register('From');$x->register('Cc');$x->register('Reply-To');$x->register('Sender');sub create(@) {my ($self,%arg)=@_;$self->{AddrList}={};while(my ($e,$n)=each%arg){$self->{AddrList}{$e}=Mail::Address->new($n,$e)}$self}sub parse($) {my ($self,$string)=@_;for my$a (Mail::Address->parse($string)){my$e=$a->address;$self->{AddrList}{$e}=$a}$self}sub stringify() {my$self=shift;join(", ",map {$_->format}values %{$self->{AddrList}})}sub addresses {keys %{shift->{AddrList}}}sub addr_list {values %{shift->{AddrList}}}sub names {map {$_->name}values %{shift->{AddrList}}}sub set_address($$) {my ($self,$email,$name)=@_;$self->{AddrList}{$email}=Mail::Address->new($name,$email);$self}1;
MAIL_FIELD_ADDRLIST

$fatpacked{"Mail/Field/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_FIELD_DATE';
  package Mail::Field::Date;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Field';use strict;use Date::Format qw(time2str);use Date::Parse qw(str2time);(bless [])->register('Date');sub set() {my$self=shift;my$arg=@_==1 ? shift : {@_};for my$s (qw(Time TimeStr)){if(exists$arg->{$s}){$self->{$s}=$arg->{$s}}else {delete$self->{$s}}}$self}sub parse($) {my$self=shift;delete$self->{Time};$self->{TimeStr}=shift;$self}sub time(;$) {my$self=shift;if(@_){delete$self->{TimeStr};return$self->{Time}=shift}$self->{Time}||=str2time$self->{TimeStr}}sub stringify {my$self=shift;$self->{TimeStr}||=time2str("%a, %e %b %Y %T %z",$self->time)}sub reformat {my$self=shift;$self->time($self->time);$self->stringify}1;
MAIL_FIELD_DATE

$fatpacked{"Mail/Field/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_FIELD_GENERIC';
  package Mail::Field::Generic;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Field';use Carp;sub create {my ($self,%arg)=@_;$self->{Text}=delete$arg{Text};croak "Unknown options " .join(",",keys%arg)if%arg;$self}sub parse {my$self=shift;$self->{Text}=shift || "";$self}sub stringify {shift->{Text}}1;
MAIL_FIELD_GENERIC

$fatpacked{"Mail/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_FILTER';
  package Mail::Filter;use vars '$VERSION';$VERSION='2.21';use strict;use Carp;sub new(@) {my$class=shift;bless {filters=>[@_ ]},$class}sub add(@) {my$self=shift;push @{$self->{filters}},@_}sub _filter($) {my ($self,$mail)=@_;for my$sub (@{$self->{filters}}){my$mail =ref$sub eq 'CODE' ? $sub->($self,$mail):!ref$sub ? $self->$sub($mail): carp "Cannot call filter '$sub', ignored";ref$mail or last}$mail}sub filter {my ($self,$obj)=@_;if($obj->isa('Mail::Folder')){$self->{folder}=$obj;for my$m ($obj->message_list){my$mail=$obj->get_message($m)or next;$self->{msgnum}=$m;$self->_filter($mail)}delete$self->{folder};delete$self->{msgnum}}elsif($obj->isa('Mail::Internet')){return$self->filter($obj)}else {carp "Cannot process '$obj'";return undef}}sub folder() {shift->{folder}}sub msgnum() {shift->{msgnum}}1;
MAIL_FILTER

$fatpacked{"Mail/Header.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_HEADER';
  package Mail::Header;use vars '$VERSION';$VERSION='2.21';use strict;use Carp;my$MAIL_FROM='KEEP';my%HDR_LENGTHS=();our$FIELD_NAME='[^\x00-\x1f\x7f-\xff :]+:';sub _error {warn @_;()}sub _tidy_header {my$self=shift;my$deleted=0;for(my$i=0 ;$i < @{$self->{mail_hdr_list}};$i++){next if defined$self->{mail_hdr_list}[$i];splice @{$self->{mail_hdr_list}},$i,1;$deleted++;$i--}if($deleted){local $_;my@del;while(my ($key,$ref)=each %{$self->{mail_hdr_hash}}){push@del,$key unless @$ref=grep {ref $_ && defined $$_}@$ref}delete$self->{'mail_hdr_hash'}{$_}for@del}}my%STRUCTURE=map {(lc $_=>undef)}qw{To Cc Bcc From Date Reply-To Sender Resent-Date Resent-From Resent-Sender Resent-To Return-Path list-help list-post list-unsubscribe Mailing-List Received References Message-ID In-Reply-To Content-Length Content-Type Content-Disposition Delivered-To Lines MIME-Version Precedence Status};sub _fold_line {my($ln,$maxlen)=@_;$maxlen=20 if$maxlen < 20;my$max=int($maxlen - 5);my$min=int($maxlen * 4 / 5)- 4;$_[0]=~ s/[\r\n]+//og;$_[0]=~ s/\s*\Z/\n/so;return if $_[0]=~ /^From\s/io;if(length($_[0])> $maxlen){if($_[0]=~ /^([-\w]+)/ && exists$STRUCTURE{lc $1 }){my$x="";$x .= "$1\n " while $_[0]=~ s/^\s*
                     ( [^"]{$min,$max} [,;]
                     | [^"]{1,$max}    [,;\s]
                     | [^\s"]*(?:"[^"]*"[ \t]?[^\s"]*)+\s
                     ) //x;$x .= $_[0];$_[0]=$x;$_[0]=~ s/(\A\s+|[\t ]+\Z)//sog;$_[0]=~ s/\s+\n/\n/sog}else {$_[0]=~ s/(.{$min,$max})(\s)/$1\n$2/g;$_[0]=~ s/\s*$/\n/s}}$_[0]=~ s/\A(\S+)\n\s*(?=\S)/$1 /so}sub _tag_case {my$tag=shift;$tag =~ s/\:$//;join '-' ,map {/^[b-df-hj-np-tv-z]+$|^(?:MIME|SWE|SOAP|LDAP|ID)$/i ? uc($_): ucfirst(lc($_))}split m/\-/,$tag,-1}sub _fmt_line {my ($self,$tag,$line,$modify)=@_;$modify ||=$self->{mail_hdr_modify};my$ctag=undef;($tag)=$line =~ /^($FIELD_NAME|From )/oi unless defined$tag;if(defined$tag && $tag =~ /^From /io && $self->{mail_hdr_mail_from}ne 'KEEP'){if($self->{mail_hdr_mail_from}eq 'COERCE'){$line =~ s/^From /Mail-From: /o;$tag="Mail-From:"}elsif($self->{mail_hdr_mail_from}eq 'IGNORE'){return ()}elsif($self->{mail_hdr_mail_from}eq 'ERROR'){return _error "unadorned 'From ' ignored: <$line>"}}if(defined$tag){$tag=_tag_case($ctag=$tag);$ctag=$tag if$modify;$ctag =~ s/([^ :])$/$1:/o if defined$ctag}defined$ctag && $ctag =~ /^($FIELD_NAME|From )/oi or croak "Bad RFC822 field name '$tag'\n";if(defined$ctag && ($modify || $line !~ /^\Q$ctag\E/i)){(my$xtag=$ctag)=~ s/\s*\Z//o;$line =~ s/^(\Q$ctag\E)?\s*/$xtag /i}my$maxlen=$self->{mail_hdr_lengths}{$tag}|| $HDR_LENGTHS{$tag}|| $self->fold_length;if ($modify && defined$maxlen){_fold_line$line,$maxlen}elsif($line =~ /\r?\n\S/){return _error "Bad header continuation, skipping '$tag': ","no space after newline in '$line'\n"}$line =~ s/\n*$/\n/so;($tag,$line)}sub _insert {my ($self,$tag,$line,$where)=@_;if($where < 0){$where=@{$self->{mail_hdr_list}}+ $where + 1;$where=0 if$where < 0}elsif($where >= @{$self->{mail_hdr_list}}){$where=@{$self->{mail_hdr_list}}}my$atend=$where==@{$self->{mail_hdr_list}};splice @{$self->{mail_hdr_list}},$where,0,$line;$self->{mail_hdr_hash}{$tag}||=[];my$ref=\${$self->{mail_hdr_list}}[$where];my$def=$self->{mail_hdr_hash}{$tag};if($def && $where){if($atend){push @$def,$ref}else {my$i=0;for my$ln (@{$self->{mail_hdr_list}}){my$r=\$ln;last if$r==$ref;$i++ if$r==$def->[$i]}splice @$def,$i,0,$ref}}else {unshift @$def,$ref}}sub new {my$call=shift;my$class=ref($call)|| $call;my$arg=@_ % 2 ? shift : undef;my%opt=@_;$opt{Modify}=delete$opt{Reformat}unless exists$opt{Modify};my$self=bless {mail_hdr_list=>[],mail_hdr_hash=>{},mail_hdr_modify=>(delete$opt{Modify}|| 0),mail_hdr_foldlen=>79 ,mail_hdr_lengths=>{}},$class;$self->mail_from(uc($opt{MailFrom}|| $MAIL_FROM));$self->fold_length($opt{FoldLength})if exists$opt{FoldLength};if(!ref$arg){}elsif(ref($arg)eq 'ARRAY'){$self->extract([@$arg ])}elsif(defined fileno($arg)){$self->read($arg)}$self}sub dup {my$self=shift;my$dup=ref($self)->new;%$dup=%$self;$dup->empty;$dup->{mail_hdr_list}=[@{$self->{mail_hdr_list}}];for my$ln (@{$dup->{mail_hdr_list}}){my$tag=_tag_case +($ln =~ /^($FIELD_NAME|From )/oi)[0];push @{$dup->{mail_hdr_hash}{$tag}},\$ln}$dup}sub extract {my ($self,$lines)=@_;$self->empty;while(@$lines){my$line=shift @$lines;last if$line =~ /^\r?$/;$line =~ /^($FIELD_NAME|From )/o or next;my$tag=$1;$line .= shift @$lines while @$lines && $lines->[0]=~ /^[ \t]+/;($tag,$line)=_fmt_line$self,$tag,$line;_insert$self,$tag,$line,-1 if defined$line}$self}sub read {my ($self,$fd)=@_;$self->empty;my ($ln,$tag,$line);while(1){$ln=<$fd>;if(defined$ln && defined$line && $ln =~ /^[ \t]+/){$line .= $ln;next}if(defined$line){($tag,$line)=_fmt_line$self,$tag,$line;_insert$self,$tag,$line,-1 if defined$line;($tag,$line)=()}last if!defined$ln || $ln =~ m/^\r?$/;$ln =~ /^($FIELD_NAME|From )/o or next;($tag,$line)=($1,$ln)}$self}sub empty {my$self=shift;$self->{mail_hdr_list}=[];$self->{mail_hdr_hash}={};$self}sub header {my$self=shift;$self->extract(@_)if @_;$self->fold if$self->{mail_hdr_modify};[@{$self->{mail_hdr_list}}]}sub header_hashref {my ($self,$hashref)=@_;while(my ($key,$value)=each %$hashref){$self->add($key,$_)for ref$value ? @$value : $value}$self->fold if$self->{mail_hdr_modify};defined wantarray or return;+{map {($_=>[$self->get($_)])}keys %{$self->{mail_hdr_hash}}}}sub modify {my$self=shift;my$old=$self->{mail_hdr_modify};$self->{mail_hdr_modify}=0 + shift if @_;$old}sub mail_from {my$thing=shift;my$choice=uc shift;$choice =~ /^(IGNORE|ERROR|COERCE|KEEP)$/ or die "bad Mail-From choice: '$choice'";if(ref$thing){$thing->{mail_hdr_mail_from}=$choice}else {$MAIL_FROM=$choice}$thing}sub fold_length {my$thing=shift;my$old;if(@_==2){my$tag=_tag_case shift;my$len=shift;my$hash=ref$thing ? $thing->{mail_hdr_lengths}: \%HDR_LENGTHS;$old=$hash->{$tag};$hash->{$tag}=$len > 20 ? $len : 20}else {my$self=$thing;my$len=shift;$old=$self->{mail_hdr_foldlen};if(defined$len){$self->{mail_hdr_foldlen}=$len > 20 ? $len : 20;$self->fold if$self->{mail_hdr_modify}}}$old}sub fold {my ($self,$maxlen)=@_;while(my ($tag,$list)=each %{$self->{mail_hdr_hash}}){my$len=$maxlen || $self->{mail_hdr_lengths}{$tag}|| $HDR_LENGTHS{$tag}|| $self->fold_length;for my$ln (@$list){_fold_line $$ln,$len if defined$ln}}$self}sub unfold {my$self=shift;if(@_){my$tag=_tag_case shift;my$list=$self->{mail_hdr_hash}{$tag}or return$self;for my$ln (@$list){$$ln =~ s/\r?\n\s+/ /sog if defined$ln && defined $$ln}return$self}while(my ($tag,$list)=each %{$self->{mail_hdr_hash}}){for my$ln (@$list){$$ln =~ s/\r?\n\s+/ /sog if defined$ln && defined $$ln}}$self}sub add {my ($self,$tag,$text,$where)=@_;($tag,my$line)=_fmt_line$self,$tag,$text;defined$tag && defined$line or return undef;defined$where or $where=-1;_insert$self,$tag,$line,$where;$line =~ /^\S+\s(.*)/os;$1}sub replace {my$self=shift;my$idx=@_ % 2 ? pop @_ : 0;my ($tag,$line);TAG: while(@_){($tag,$line)=_fmt_line$self,splice(@_,0,2);defined$tag && defined$line or return undef;my$field=$self->{mail_hdr_hash}{$tag};if($field && defined$field->[$idx]){${$field->[$idx]}=$line}else {_insert$self,$tag,$line,-1}}$line =~ /^\S+\s*(.*)/os;$1}sub combine {my$self=shift;my$tag=_tag_case shift;my$with=shift || ' ';$tag =~ /^From /io && $self->{mail_hdr_mail_from}ne 'KEEP' and return _error "unadorned 'From ' ignored";my$def=$self->{mail_hdr_hash}{$tag}or return undef;return$def->[0]if @$def <= 1;my@lines=$self->get($tag);chomp@lines;my$line=(_fmt_line$self,$tag,join($with,@lines),1)[1];$self->{mail_hdr_hash}{$tag}=[\$line ];$line}sub get {my$self=shift;my$tag=_tag_case shift;my$idx=shift;my$def=$self->{mail_hdr_hash}{$tag}or return ();my$l=length$tag;$l += 1 if$tag !~ / $/o;if(defined$idx ||!wantarray){$idx ||=0;defined$def->[$idx]or return undef;my$val=${$def->[$idx]};defined$val or return undef;$val=substr$val,$l;$val =~ s/^\s+//;return$val}map {my$tmp=substr $$_,$l;$tmp =~ s/^\s+//;$tmp}@$def}sub count {my$self=shift;my$tag=_tag_case shift;my$def=$self->{mail_hdr_hash}{$tag};defined$def ? scalar(@$def): 0}sub delete {my$self=shift;my$tag=_tag_case shift;my$idx=shift;my@val;if(my$def=$self->{mail_hdr_hash}{$tag}){my$l=length$tag;$l += 2 if$tag !~ / $/;if(defined$idx){if(defined$def->[$idx]){push@val,substr ${$def->[$idx]},$l;undef ${$def->[$idx]}}}else {@val=map {my$x=substr $$_,$l;undef $$_;$x}@$def}_tidy_header($self)}@val}sub print {my$self=shift;my$fd=shift || \*STDOUT;for my$ln (@{$self->{mail_hdr_list}}){defined$ln or next;print$fd $ln or return 0}1}sub as_string {join '',grep {defined}@{shift->{mail_hdr_list}}}sub tags {keys %{shift->{mail_hdr_hash}}}sub cleanup {my$self=shift;my$deleted=0;for my$key (@_ ? @_ : keys %{$self->{mail_hdr_hash}}){my$fields=$self->{mail_hdr_hash}{$key};for my$field (@$fields){next if $$field =~ /^\S+\s+\S/s;undef $$field;$deleted++}}_tidy_header$self if$deleted;$self}1;
MAIL_HEADER

$fatpacked{"Mail/Identity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_IDENTITY';
  package Mail::Identity;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;use User::Identity;use Scalar::Util 'weaken';sub type() {"email"}sub init($) {my ($self,$args)=@_;$args->{name}||='-x-';$self->SUPER::init($args);exists$args->{$_}&& ($self->{'MI_'.$_}=delete$args->{$_})foreach qw/address charset comment domain language location organization pgp_key phrase signature username/;$self->{UII_name}=$self->phrase || $self->address if$self->{UII_name}eq '-x-';$self}sub from($) {my ($class,$other)=(shift,shift);return$other if$other->isa(__PACKAGE__);if($other->isa('Mail::Address')){return$class->new (phrase=>$other->phrase ,address=>$other->address ,comment=>$other->comment ,@_)}if($other->isa('User::Identity')){my$emails=$other->collection('emails')or next;my@roles=$emails->roles or return ();return$roles[0]}undef}sub comment($) {my$self=shift;return$self->{MI_comment}=shift if @_;return$self->{MI_comment}if defined$self->{MI_comment};my$user=$self->user or return undef;my$full=$user->fullName or return undef;$self->phrase eq $full ? undef : $full}sub charset() {my$self=shift;return$self->{MI_charset}if defined$self->{MI_charset};my$user=$self->user or return undef;$user->charset}sub language() {my$self=shift;return$self->{MI_language}if defined$self->{MI_language};my$user=$self->user or return undef;$user->language}sub domain() {my$self=shift;return$self->{MI_domain}if defined$self->{MI_domain};my$address=$self->{MI_address}or return 'localhost';$address =~ s/.*?\@// ? $address : undef}sub address() {my$self=shift;return$self->{MI_address}if defined$self->{MI_address};return$self->username .'@'.$self->domain if$self->{MI_username}|| $self->{MI_domain};my$name=$self->name;return$name if index($name,'@')>= 0;my$user=$self->user;defined$user ? $user->nickname : $name}sub location() {my$self=shift;my$location=$self->{MI_location};if(!defined$location){my$user=$self->user or return;my@locs=$user->collection('locations');$location=@locs ? $locs[0]: undef}elsif(!ref$location){my$user=$self->user or return;$location=$user->find(location=>$location)}$location}sub organization() {my$self=shift;return$self->{MI_organization}if defined$self->{MI_organization};my$location=$self->location or return;$location->organization}sub phrase() {my$self=shift;return$self->{MI_phrase}if defined$self->{MI_phrase};my$user=$self->user or return undef;my$full=$user->fullName or return undef;$full}sub username() {my$self=shift;return$self->{MI_username}if defined$self->{MI_username};if(my$address=$self->{MI_address}){$address =~ s/\@.*$//;return$address}my$user=$self->user or return;$user->nickname}1;
MAIL_IDENTITY

$fatpacked{"Mail/Internet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_INTERNET';
  package Mail::Internet;use vars '$VERSION';$VERSION='2.21';use strict;use Carp;use Mail::Header;use Mail::Util qw/mailaddress/;use Mail::Address;sub new(@) {my$call=shift;my$arg=@_ % 2 ? shift : undef;my%opt=@_;my$class=ref($call)|| $call;my$self=bless {},$class;$self->{mail_inet_head}=$opt{Header}if exists$opt{Header};$self->{mail_inet_body}=$opt{Body}if exists$opt{Body};my$head=$self->head;$head->fold_length(delete$opt{FoldLength}|| 79);$head->mail_from($opt{MailFrom})if exists$opt{MailFrom};$head->modify(exists$opt{Modify}? $opt{Modify}: 1);if(!defined$arg){}elsif(ref($arg)eq 'ARRAY'){$self->header($arg)unless exists$opt{Header};$self->body($arg)unless exists$opt{Body}}elsif(defined fileno($arg)){$self->read_header($arg)unless exists$opt{Header};$self->read_body($arg)unless exists$opt{Body}}else {croak "couldn't understand $arg to Mail::Internet constructor"}$self}sub read(@) {my$self=shift;$self->read_header(@_);$self->read_body(@_)}sub read_body($) {my ($self,$fd)=@_;$self->body([<$fd> ])}sub read_header(@) {my$head=shift->head;$head->read(@_);$head->header}sub extract($) {my ($self,$lines)=@_;$self->head->extract($lines);$self->body($lines)}sub dup() {my$self=shift;my$dup=ref($self)->new;my$body=$self->{mail_inet_body}|| [];my$head=$self->{mail_inet_head};;$dup->{mail_inet_body}=[@$body ];$dup->{mail_inet_head}=$head->dup if$head;$dup}sub body(;$@) {my$self=shift;return$self->{mail_inet_body}||=[]unless @_;$self->{mail_inet_body}=ref $_[0]eq 'ARRAY' ? $_[0]: [@_ ]}sub head {shift->{mail_inet_head}||=Mail::Header->new}sub print($) {my$self=shift;my$fd=shift || \*STDOUT;$self->print_header($fd)and print$fd "\n" and $self->print_body($fd)}sub print_header($) {shift->head->print(@_)}sub print_body($) {my$self=shift;my$fd=shift || \*STDOUT;for my$ln (@{$self->body}){print$fd $ln or return 0}1}sub as_string() {my$self=shift;$self->head->as_string ."\n" .join '',@{$self->body}}sub as_mbox_string($) {my$self=shift->dup;my$escaped=shift;$self->head->delete('Content-Length');$self->escape_from unless$escaped;$self->as_string ."\n"}sub header {shift->head->header(@_)}sub fold {shift->head->fold(@_)}sub fold_length {shift->head->fold_length(@_)}sub combine {shift->head->combine(@_)}sub add(@) {my$head=shift->head;my$ret;while(@_){my ($tag,$line)=splice @_,0,2;$ret=$head->add($tag,$line,-1)or return undef}$ret}sub replace(@) {my$head=shift->head;my$ret;while(@_){my ($tag,$line)=splice @_,0,2;$ret=$head->replace($tag,$line,0)or return undef}$ret}sub get(@) {my$head=shift->head;return map {$head->get($_)}@_ if wantarray;for my$tag (@_){my$r=$head->get($tag);return$r if defined$r}undef}sub delete(@) {my$head=shift->head;map {$head->delete($_)}@_}sub empty() {my$self=shift;%$self=();1}sub remove_sig($) {my$body=shift->body;my$nlines=shift || 10;my$start=@$body;my$i=0;while($i++ < $nlines && $start--){next if$body->[$start]!~ /^--[ ]?[\r\n]/;splice @$body,$start,$i;last}}sub sign(@) {my ($self,%arg)=@_;my ($sig,@sig);if($sig=delete$arg{File}){local*SIG;if(open(SIG,$sig)){local $_;while(<SIG>){last unless /^(--)?\s*$/}@sig=($_,<SIG>,"\n");close SIG}}elsif($sig=delete$arg{Signature}){@sig=ref($sig)? @$sig : split(/\n/,$sig)}if(@sig){$self->remove_sig;s/[\r\n]*$/\n/ for@sig;push @{$self->body},"-- \n",@sig}$self}sub tidy_body() {my$body=shift->body;shift @$body while @$body && $body->[0]=~ /^\s*$/;pop @$body while @$body && $body->[-1]=~ /^\s*$/;$body}sub reply(@) {my ($self,%arg)=@_;my$class=ref$self;my@reply;local*MAILHDR;if(open(MAILHDR,"$ENV{HOME}/.mailhdr")){@reply=<MAILHDR>;close MAILHDR}my$reply=$class->new(\@reply);my$subject=$self->get('Subject')|| "";$subject="Re: " .$subject if$subject =~ /\S+/ && $subject !~ /Re:/i;$reply->replace(Subject=>$subject);my$to=$self->get('Reply-To')|| $self->get('From')|| $self->get('Return-Path')|| "";my$sender=(Mail::Address->parse($to))[0];my$name=$sender->name;unless(defined$name){my$fr=$self->get('From');$fr=(Mail::Address->parse($fr))[0]if defined$fr;$name=$fr->name if defined$fr}my$indent=$arg{Indent}|| ">";if($indent =~ /\%/){my%hash=('%'=>'%');my@name=$name ? grep({length $_}split /[\n\s]+/,$name): '';$hash{f}=$name[0];$hash{F}=$#name ? substr($hash{f},0,1): $hash{f};$hash{l}=$#name ? $name[$#name]: "";$hash{L}=substr($hash{l},0,1)|| "";$hash{n}=$name || "";$hash{I}=join "",map {substr($_,0,1)}@name;$indent =~ s/\%(.)/defined $hash{$1} ? $hash{$1} : $1/eg}my$id=$sender->address;$reply->replace(To=>$id);my$mailaddresses=$ENV{MAILADDRESSES}|| "";my%nocc=(lc($id)=>1);$nocc{lc $_->address}=1 for Mail::Address->parse($reply->get('Bcc'),$mailaddresses);if($arg{ReplyAll}){my%cc;for my$addr (Mail::Address->parse($self->get('To'),$self->get('Cc'))){my$lc=lc$addr->address;$cc{$lc}=$addr->format unless$nocc{$lc}}my$cc=join ', ',values%cc;$reply->replace(Cc=>$cc)}my$refs=$self->get('References')|| "";my$mid=$self->get('Message-Id');$refs .= " " .$mid if defined$mid;$reply->replace(References=>$refs);my$date=$self->get('Date');my$inreply="";if(defined$mid){$inreply=$mid;my@comment;push@comment,"from $name" if defined$name;push@comment,"on $date" if defined$date;local $"=' ';$inreply .= " (@comment)" if@comment}elsif(defined$name){$inreply=$name ."'s message";$inreply .= "of " .$date if defined$date}$reply->replace('In-Reply-To'=>$inreply);my$body=$reply->body;@$body=@{$self->body};$reply->remove_sig;$reply->tidy_body;s/\A/$indent/ for @$body;unshift @{$body},(defined$name ? $name ." " : "")."<$id> writes:\n";if(defined$arg{Keep}&& ref$arg{Keep}eq 'ARRAY'){for my$keep (@{$arg{Keep}}){my$ln=$self->get($keep);$reply->replace($keep=>$ln)if defined$ln}}if(defined$arg{Exclude}&& ref$arg{Exclude}eq 'ARRAY'){$reply->delete(@{$arg{Exclude}})}$reply->head->cleanup;$reply}sub smtpsend($@) {my ($self,%opt)=@_;require Net::SMTP;require Net::Domain;my$host=$opt{Host};my$envelope=$opt{MailFrom}|| mailaddress();my$quit=1;my ($smtp,@hello);push@hello,Hello=>$opt{Hello}if defined$opt{Hello};push@hello,Port=>$opt{Port}if exists$opt{Port};push@hello,Debug=>$opt{Debug}if exists$opt{Debug};if(!defined$host){local$SIG{__DIE__};my@hosts=qw(mailhost localhost);unshift@hosts,split /\:/,$ENV{SMTPHOSTS}if defined$ENV{SMTPHOSTS};for$host (@hosts){$smtp=eval {Net::SMTP->new($host,@hello)};last if defined$smtp}}elsif(UNIVERSAL::isa($host,'Net::SMTP')|| UNIVERSAL::isa($host,'Net::SMTP::SSL')){$smtp=$host;$quit=0}else {local$SIG{__DIE__};$smtp=eval {Net::SMTP->new($host,@hello)}}defined$smtp or return ();my$head=$self->cleaned_header_dup;my@rcpt=map {ref $_ ? @$_ : $_}grep {defined}@opt{'To','Cc','Bcc'};@rcpt=map {$head->get($_)}qw(To Cc Bcc) unless@rcpt;my@addr=map {$_->address}Mail::Address->parse(@rcpt);@addr or return ();$head->delete('Bcc');my$ok=$smtp->mail($envelope)&& $smtp->to(@addr)&& $smtp->data(join("",@{$head->header},"\n",@{$self->body}));$quit && $smtp->quit;$ok ? @addr : ()}sub send($@) {my ($self,$type,@args)=@_;require Mail::Mailer;my$head=$self->cleaned_header_dup;my$mailer=Mail::Mailer->new($type,@args);$mailer->open($head->header_hashref);$self->print_body($mailer);$mailer->close}sub nntppost {my ($self,%opt)=@_;require Net::NNTP;my$groups=$self->get('Newsgroups')|| "";my@groups=split /[\s,]+/,$groups;@groups or return ();my$head=$self->cleaned_header_dup;$head->delete(qw(To Cc Bcc));my$news;my$quit=1;my$host=$opt{Host};if(ref($host)&& UNIVERSAL::isa($host,'Net::NNTP')){$news=$host;$quit=0}else {my@opt=$opt{Host};push@opt,Port=>$opt{Port}if exists$opt{Port};push@opt,Debug=>$opt{Debug}if exists$opt{Debug};$news=Net::NNTP->new(@opt)or return ()}$news->post(@{$head->header},"\n",@{$self->body});my$rc=$news->code;$news->quit if$quit;$rc==240 ? @groups : ()}sub escape_from {my$body=shift->body;scalar grep {s/\A(>*From) />$1 /o}@$body}sub unescape_from {my$body=shift->body;scalar grep {s/\A>(>*From) /$1 /o}@$body}sub cleaned_header_dup() {my$head=shift->head->dup;$head->delete('From ');$head->delete('Received');$head->replace('X-Mailer',"Perl5 Mail::Internet v".$Mail::Internet::VERSION)unless$head->count('X-Mailer');my$name=eval {local$SIG{__DIE__};(getpwuid($>))[6]}|| $ENV{NAME}||"";while($name =~ s/\([^\(\)]*\)//){1}if($name =~ /[^\w\s]/){$name =~ s/"/\"/g;$name='"' .$name .'"'}my$from=sprintf "%s <%s>",$name,mailaddress();$from =~ s/\s{2,}/ /g;for my$tag (qw(From Sender)){$head->get($tag)or $head->add($tag,$from)}$head}1;
MAIL_INTERNET

$fatpacked{"Mail/Mailer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER';
  package Mail::Mailer;use vars '$VERSION';$VERSION='2.21';use base 'IO::Handle';use strict;use POSIX qw/_exit/;use Carp;use Config;sub is_exe($);sub Version {our$VERSION}our@Mailers=(sendmail=>'/usr/lib/sendmail;/usr/sbin/sendmail;/usr/ucblib/sendmail' ,smtp=>undef ,smtps=>undef ,qmail=>'/usr/sbin/qmail-inject;/var/qmail/bin/qmail-inject' ,testfile=>undef);push@Mailers,map {split /\:/,$_,2}split /$Config{path_sep}/,$ENV{PERL_MAILERS}if$ENV{PERL_MAILERS};our%Mailers=@Mailers;our$MailerType;our$MailerBinary;$Mailers{sendmail}='sendmail' if $^O eq 'os2' &&!is_exe$Mailers{sendmail};if($^O =~ m/MacOS|VMS|MSWin|os2|NetWare/i){$MailerType='smtp';$MailerBinary=$Mailers{$MailerType}}else {for(my$i=0 ;$i < @Mailers ;$i += 2){$MailerType=$Mailers[$i];if(my$binary=is_exe$Mailers{$MailerType}){$MailerBinary=$binary;last}}}sub import {shift;@_ or return;my$type=shift;my$exe=shift || $Mailers{$type};is_exe$exe or carp "Cannot locate '$exe'";$MailerType=$type;$Mailers{$MailerType}=$exe}sub to_array($) {my ($self,$thing)=@_;ref$thing ? @$thing : $thing}sub is_exe($) {my$exe=shift || '';for my$cmd (split /\;/,$exe){$cmd =~ s/^\s+//;my$name=($cmd =~ /^(\S+)/)[0];return$cmd if -x $name &&!-d $name && $name =~ m![\\/]!;if(defined$ENV{PATH}){for my$dir (split /$Config{path_sep}/,$ENV{PATH}){return "$dir/$cmd" if -x "$dir/$name" &&!-d "$dir/$name"}}}0}sub new($@) {my ($class,$type,@args)=@_;unless($type){$MailerType or croak "No MailerType specified";warn "No real MTA found, using '$MailerType'" if$MailerType eq 'testfile';$type=$MailerType}my$exe=$Mailers{$type};if(defined$exe){$exe=is_exe$exe if defined$type;$exe ||=$MailerBinary or croak "No mailer type specified (and no default available), thus can not find executable program."}$class="Mail::Mailer::$type";eval "require $class" or die $@;my$glob=$class->SUPER::new;%{*$glob}=(Exe=>$exe,Args=>[@args ]);$glob}sub open($) {my ($self,$hdrs)=@_;my$exe=*$self->{Exe};my$args=*$self->{Args};my@to=$self->who_to($hdrs);my$sender=$self->who_sender($hdrs);$self->close;if(defined$exe){my$child=open$self,'|-';defined$child or die "Failed to send: $!";if($child==0){unless($self->exec($exe,$args,\@to,$sender)){warn $!;_exit(1)}}}else {$self->exec(undef,$args,\@to)or die $!}$self->set_headers($hdrs);$self}sub _cleanup_hdrs($) {for my$h (values %{(shift)}){for (ref$h ? @$h : $h){s/\n\s*/ /g;s/\s+$//}}}sub exec($$$$) {my($self,$exe,$args,$to,$sender)=@_;my@exe=split /\s+/,$exe;exec@exe,@$args,@$to}sub can_cc {1}sub who_to($) {my($self,$hdrs)=@_;my@to=$self->to_array($hdrs->{To});unless($self->can_cc){push@to,$self->to_array($hdrs->{Cc})if$hdrs->{Cc};push@to,$self->to_array($hdrs->{Bcc})if$hdrs->{Bcc}}@to}sub who_sender($) {my ($self,$hdrs)=@_;($self->to_array($hdrs->{Sender}|| $hdrs->{From}))[0]}sub epilogue {}sub close(@) {my$self=shift;fileno$self or return;$self->epilogue;CORE::close$self}sub DESTROY {shift->close}1;
MAIL_MAILER

$fatpacked{"Mail/Mailer/qmail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_QMAIL';
  package Mail::Mailer::qmail;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer::rfc822';use strict;sub exec($$$$) {my($self,$exe,$args,$to,$sender)=@_;my$address=defined$sender && $sender =~ m/\<(.*?)\>/ ? $1 : $sender;exec($exe,(defined$address ? "-f$address" : ()));die "ERROR: cannot run $exe: $!"}1;
MAIL_MAILER_QMAIL

$fatpacked{"Mail/Mailer/rfc822.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_RFC822';
  package Mail::Mailer::rfc822;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer';use strict;sub set_headers {my ($self,$hdrs)=@_;local $\="";for (keys %$hdrs){next unless m/^[A-Z]/;for my$h ($self->to_array($hdrs->{$_})){$h =~ s/\n+\Z//;print$self "$_: $h\n"}}print$self "\n"}1;
MAIL_MAILER_RFC822

$fatpacked{"Mail/Mailer/sendmail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_SENDMAIL';
  package Mail::Mailer::sendmail;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer::rfc822';use strict;sub exec($$$$) {my($self,$exe,$args,$to,$sender)=@_;exec($exe,'-t',@$args)}1;
MAIL_MAILER_SENDMAIL

$fatpacked{"Mail/Mailer/smtp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_SMTP';
  package Mail::Mailer::smtp;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer::rfc822';use strict;use Net::SMTP;use Mail::Util qw(mailaddress);use Carp;sub can_cc {0}sub exec {my ($self,$exe,$args,$to)=@_;my%opt=@$args;my$host=$opt{Server}|| undef;$opt{Debug}||=0;my$smtp=Net::SMTP->new($host,%opt)or return undef;if($opt{StartTLS}){$Net::SMTP::VERSION >= 1.28 or die "StartTLS requires Net::SMTP 1.28";$smtp->starttls or return undef}if($opt{Auth}){$smtp->auth(@{$opt{Auth}})or return undef}${*$self}{sock}=$smtp;$smtp->mail($opt{From}|| mailaddress());$smtp->to($_)for @$to;$smtp->data;untie *$self if tied *$self;tie *$self,'Mail::Mailer::smtp::pipe',$self;$self}sub set_headers($) {my ($self,$hdrs)=@_;$self->SUPER::set_headers ({From=>"<" .mailaddress().">" ,%$hdrs ,'X-Mailer'=>"Mail::Mailer[v$Mail::Mailer::VERSION] Net::SMTP[v$Net::SMTP::VERSION]" })}sub epilogue() {my$self=shift;my$sock=${*$self}{sock};my$ok=$sock->dataend;$sock->quit;delete ${*$self}{sock};untie *$self;$ok}sub close(@) {my ($self,@to)=@_;my$sock=${*$self}{sock};$sock && fileno$sock or return 1;my$ok=$self->epilogue;$sock && fileno$sock or return$ok;close$sock or croak 'Cannot destroy socket filehandle';$ok}package Mail::Mailer::smtp::pipe;use vars '$VERSION';$VERSION='2.21';sub TIEHANDLE {my ($class,$self)=@_;my$sock=${*$self}{sock};bless \$sock,$class}sub PRINT {my$self=shift;my$sock=$$self;$sock->datasend(@_)}1;
MAIL_MAILER_SMTP

$fatpacked{"Mail/Mailer/smtps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_SMTPS';
  package Mail::Mailer::smtps;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer::rfc822';use strict;use Net::SMTP::SSL;use Mail::Util qw(mailaddress);use Carp;sub can_cc {0}sub exec {my ($self,$exe,$args,$to)=@_;my%opt=@$args;my$host=$opt{Server}|| undef;$opt{Debug}||=0;$opt{Port}||=465;my$smtp=Net::SMTP::SSL->new($host,%opt)or return undef;if($opt{Auth}){$smtp->auth(@{$opt{Auth}})or return undef}${*$self}{sock}=$smtp;$smtp->mail($opt{From}|| mailaddress);$smtp->to($_)for @$to;$smtp->data;untie *$self if tied *$self;tie *$self,'Mail::Mailer::smtps::pipe',$self;$self}sub set_headers($) {my ($self,$hdrs)=@_;$self->SUPER::set_headers ({From=>"<" .mailaddress().">" ,%$hdrs ,'X-Mailer'=>"Mail::Mailer[v$Mail::Mailer::VERSION] " ." Net::SMTP[v$Net::SMTP::VERSION]" ." Net::SMTP::SSL[v$Net::SMTP::SSL::VERSION]" })}sub epilogue() {my$self=shift;my$sock=${*$self}{sock};my$ok=$sock->dataend;$sock->quit;delete ${*$self}{sock};untie *$self;$ok}sub close(@) {my ($self,@to)=@_;my$sock=${*$self}{sock};$sock && fileno$sock or return 1;my$ok=$self->epilogue;$sock && fileno$sock or return$ok;close$sock or croak 'Cannot destroy socket filehandle';$ok}package Mail::Mailer::smtps::pipe;use vars '$VERSION';$VERSION='2.21';sub TIEHANDLE {my ($class,$self)=@_;my$sock=${*$self}{sock};bless \$sock,$class}sub PRINT {my$self=shift;my$sock=$$self;$sock->datasend(@_)}1;
MAIL_MAILER_SMTPS

$fatpacked{"Mail/Mailer/testfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MAILER_TESTFILE';
  package Mail::Mailer::testfile;use vars '$VERSION';$VERSION='2.21';use base 'Mail::Mailer::rfc822';use strict;use Mail::Util qw/mailaddress/;my$num=0;sub can_cc() {0}sub exec($$$) {my ($self,$exe,$args,$to)=@_;my$outfn=$Mail::Mailer::testfile::config{outfile}|| 'mailer.testfile';open F,'>>',$outfn or die "Cannot append message to testfile $outfn: $!";print F "\n===\ntest ",++$num," ",(scalar localtime),"\nfrom: " .mailaddress(),"\nto: " .join(' ',@{$to}),"\n\n";close F;untie *$self if tied *$self;tie *$self,'Mail::Mailer::testfile::pipe',$self;$self}sub close {1}package Mail::Mailer::testfile::pipe;use vars '$VERSION';$VERSION='2.21';sub TIEHANDLE {my ($class,$self)=@_;bless \$self,$class}sub PRINT {my$self=shift;open F,'>>',$Mail::Mailer::testfile::config{outfile}|| 'mailer.testfile';print F @_;close F}1;
MAIL_MAILER_TESTFILE

$fatpacked{"Mail/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Mail::Message::Part ();use Mail::Message::Head::Complete ();use Mail::Message::Construct ();use Mail::Message::Body::Lines ();use Mail::Message::Body::Multipart ();use Mail::Message::Body::Nested ();use Carp;use Scalar::Util qw(weaken blessed);BEGIN {unless($ENV{HARNESS_ACTIVE}){eval {require Mail::Box};my$v=$Mail::Box::VERSION || 3;$v >= 3 or die "You need to upgrade the Mail::Box module"}}our$crlf_platform=$^O =~ m/win32/i;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MM_modified}=$args->{modified}|| 0;$self->{MM_trusted}=$args->{trusted}|| 0;my$head;if(defined($head=$args->{head})){$self->head($head)}elsif(my$msgid=$args->{messageId}|| $args->{messageID}){$self->takeMessageId($msgid)}if(my$body=$args->{body}){$self->{MM_body}=$body;$body->message($self)}$self->{MM_body_type}=$args->{body_type}if defined$args->{body_type};$self->{MM_head_type}=$args->{head_type}if defined$args->{head_type};$self->{MM_field_type}=$args->{field_type}if defined$args->{field_type};my$labels=$args->{labels}|| [];my@labels=ref$labels eq 'ARRAY' ? @$labels : %$labels;push@labels,deleted=>$args->{deleted}if exists$args->{deleted};$self->{MM_labels}={@labels };$self}sub clone(@) {my ($self,%args)=@_;my ($head,$body)=($self->head,$self->body);$head=$head->clone unless$args{shallow}|| $args{shallow_head};$body=$body->clone unless$args{shallow}|| $args{shallow_body};my$clone=Mail::Message->new (head=>$head ,body=>$body ,$self->logSettings);my$labels=$self->labels;my%labels=%$labels;delete$labels{deleted};$clone->{MM_labels}=\%labels;$clone->{MM_cloned}=$self;weaken($clone->{MM_cloned});$clone}sub messageId() {$_[0]->{MM_message_id}|| $_[0]->takeMessageId}sub messageID() {shift->messageId}sub container() {undef}sub isPart() {0}sub partNumber() {my$self=shift;my$cont=$self->container;$cont ? $cont->partNumber : undef}sub toplevel() {shift}sub isDummy() {0}sub print(;$) {my$self=shift;my$out=shift || select;$self->head->print($out);my$body=$self->body;$body->print($out)if$body;$self}sub write(;$) {my$self=shift;my$out=shift || select;$self->head->print($out);$self->body->print($out);$self}my$default_mailer;sub send(@) {my$self=shift;require Mail::Transport::Send;my$mailer;$default_mailer=$mailer=shift if ref $_[0]&& $_[0]->isa('Mail::Transport::Send');my%args=@_;if(!$args{via}&& defined$default_mailer){$mailer=$default_mailer}else {my$via=delete$args{via}|| 'sendmail';$default_mailer=$mailer=Mail::Transport->new(via=>$via,%args)}$mailer->send($self,%args)}sub size() {my$self=shift;$self->head->size + $self->body->size}sub head(;$) {my$self=shift;return$self->{MM_head}unless @_;my$head=shift;unless(defined$head){delete$self->{MM_head};return undef}$self->log(INTERNAL=>"wrong type of head ($head) for message $self")unless ref$head && $head->isa('Mail::Message::Head');$head->message($self);if(my$old=$self->{MM_head}){$self->{MM_modified}++ unless$old->isDelayed}$self->{MM_head}=$head;$self->takeMessageId unless$head->isDelayed;$head}sub get($) {my$self=shift;my$field=$self->head->get(shift)|| return undef;$field->body}sub study($) {my$head=shift->head or return;scalar$head->study(@_)}sub from() {my@from=shift->head->get('From')or return ();map $_->addresses,@from}sub sender() {my$self=shift;my$sender=$self->head->get('Sender')|| $self->head->get('From')|| return ();($sender->addresses)[0]}sub to() {map $_->addresses,shift->head->get('To')}sub cc() {map $_->addresses,shift->head->get('Cc')}sub bcc() {map $_->addresses,shift->head->get('Bcc')}sub destinations() {my$self=shift;my%to=map +(lc($_->address)=>$_),$self->to,$self->cc,$self->bcc;values%to}sub subject() {my$subject=shift->get('subject');defined$subject ? $subject : ''}sub guessTimestamp() {shift->head->guessTimestamp}sub timestamp() {my$head=shift->head;$head->recvstamp || $head->timestamp}sub nrLines() {my$self=shift;$self->head->nrLines + $self->body->nrLines}sub body(;$@) {my$self=shift;return$self->{MM_body}unless @_;my$head=$self->head;$head->removeContentInfo if defined$head;my ($rawbody,%args)=@_;unless(defined$rawbody){my$body=delete$self->{MM_body};$body->message(undef)if defined$body;return$body}ref$rawbody && $rawbody->isa('Mail::Message::Body')or $self->log(INTERNAL=>"wrong type of body for message $rawbody");my$body=$self->isPart ? $rawbody : $rawbody->encoded;$body->contentInfoTo($self->head);my$oldbody=$self->{MM_body};return$body if defined$oldbody && $body==$oldbody;$body->message($self);$body->modified(1)if defined$oldbody;$self->{MM_body}=$body}sub decoded(@) {my$body=shift->body->load;$body ? $body->decoded(@_): undef}sub encode(@) {my$body=shift->body->load;$body ? $body->encode(@_): undef}sub isMultipart() {shift->head->isMultipart}sub isNested() {shift->body->isNested}sub contentType() {my$head=shift->head;my$ct=(defined$head ? $head->get('Content-Type',0): undef)|| '';$ct =~ s/\s*\;.*//;length$ct ? $ct : 'text/plain'}sub parts(;$) {my$self=shift;my$what=shift || 'ACTIVE';my$body=$self->body;my$recurse=$what eq 'RECURSE' || ref$what;my@parts =$body->isNested ? $body->nested->parts($what): $body->isMultipart ? $body->parts($recurse ? 'RECURSE' : ()): $self;ref$what eq 'CODE' ? (grep$what->($_),@parts): $what eq 'ACTIVE' ? (grep!$_->isDeleted,@parts): $what eq 'DELETED' ? (grep $_->isDeleted,@parts): $what eq 'ALL' ? @parts : $recurse ? @parts : confess "Select parts via $what?"}sub modified(;$) {my$self=shift;return$self->isModified unless @_;my$flag=shift;$self->{MM_modified}=$flag;my$head=$self->head;$head->modified($flag)if$head;my$body=$self->body;$body->modified($flag)if$body;$flag}sub isModified() {my$self=shift;return 1 if$self->{MM_modified};my$head=$self->head;if($head && $head->isModified){$self->{MM_modified}++;return 1}my$body=$self->body;if($body && $body->isModified){$self->{MM_modified}++;return 1}0}sub label($;$@) {my$self=shift;return$self->{MM_labels}{$_[0]}unless @_ > 1;my$return=$_[1];my%labels=@_;@{$self->{MM_labels}}{keys%labels}=values%labels;$return}sub labels() {my$self=shift;wantarray ? keys %{$self->{MM_labels}}: $self->{MM_labels}}sub isDeleted() {shift->label('deleted')}sub delete() {my$self=shift;my$old=$self->label('deleted');$old || $self->label(deleted=>time)}sub deleted(;$) {my$self=shift;@_ ? $self->label(deleted=>shift): $self->label('deleted')}sub labelsToStatus() {my$self=shift;my$head=$self->head;my$labels=$self->labels;my$status=$head->get('status')|| '';my$newstatus =$labels->{seen}? 'RO' : $labels->{old}? 'O' : '';$head->set(Status=>$newstatus)if$newstatus ne $status;my$xstatus=$head->get('x-status')|| '';my$newxstatus =($labels->{replied}? 'A' : '').($labels->{flagged}? 'F' : '');$head->set('X-Status'=>$newxstatus)if$newxstatus ne $xstatus;$self}sub statusToLabels() {my$self=shift;my$head=$self->head;if(my$status=$head->get('status')){$status=$status->foldedBody;$self->label (seen=>(index($status,'R')>= 0),old=>(index($status,'O')>= 0))}if(my$xstatus=$head->get('x-status')){$xstatus=$xstatus->foldedBody;$self->label (replied=>(index($xstatus,'A')>= 0),flagged=>(index($xstatus,'F')>= 0))}$self}my$mail_internet_converter;my$mime_entity_converter;my$email_simple_converter;sub coerce($@) {my ($class,$message)=@_;blessed$message or die "coercion starts with some object";return$message if ref$message eq $class;if($message->isa(__PACKAGE__)){$message->head->modified(1);$message->body->modified(1);return bless$message,$class}if($message->isa('MIME::Entity')){unless($mime_entity_converter){eval {require Mail::Message::Convert::MimeEntity};confess "Install MIME::Entity" if $@;$mime_entity_converter=Mail::Message::Convert::MimeEntity->new}$message=$mime_entity_converter->from($message)or return}elsif($message->isa('Mail::Internet')){unless($mail_internet_converter){eval {require Mail::Message::Convert::MailInternet};confess "Install Mail::Internet" if $@;$mail_internet_converter=Mail::Message::Convert::MailInternet->new}$message=$mail_internet_converter->from($message)or return}elsif($message->isa('Email::Simple')){unless($email_simple_converter){eval {require Mail::Message::Convert::EmailSimple};confess "Install Email::Simple" if $@;$email_simple_converter=Mail::Message::Convert::EmailSimple->new}$message=$email_simple_converter->from($message)or return}elsif($message->isa('Email::Abstract')){return$class->coerce($message->object)}else {$class->log(INTERNAL=>"Cannot coerce a ".ref($message)." object into a ".__PACKAGE__." object")}$message->{MM_modified}||=0;bless$message,$class}sub clonedFrom() {shift->{MM_cloned}}sub isParsed() {not shift->isDelayed}sub headIsRead() {not shift->head->isDelayed}sub readFromParser($;$) {my ($self,$parser,$bodytype)=@_;my$head=$self->readHead($parser)|| Mail::Message::Head::Complete->new (message=>$self ,field_type=>$self->{MM_field_type},$self->logSettings);my$body=$self->readBody($parser,$head,$bodytype)or return;$self->head($head);$self->storeBody($body);$self}sub readHead($;$) {my ($self,$parser)=(shift,shift);my$headtype=shift || $self->{MM_head_type}|| 'Mail::Message::Head::Complete';$headtype->new (message=>$self ,field_type=>$self->{MM_field_type},$self->logSettings)->read($parser)}my$mpbody='Mail::Message::Body::Multipart';my$nbody='Mail::Message::Body::Nested';my$lbody='Mail::Message::Body::Lines';sub readBody($$;$$) {my ($self,$parser,$head,$getbodytype)=@_;my$bodytype =!$getbodytype ? ($self->{MM_body_type}|| $lbody): ref$getbodytype ? $getbodytype->($self,$head): $getbodytype;my$body;if($bodytype->isDelayed){$body=$bodytype->new (message=>$self ,charset=>'us-ascii' ,$self->logSettings)}else {my$ct=$head->get('Content-Type',0);my$type=defined$ct ? lc($ct->body): 'text/plain';if(substr($type,0,10)eq 'multipart/' &&!$bodytype->isMultipart){$bodytype=$mpbody}elsif($type eq 'message/rfc822' &&!$bodytype->isNested){$bodytype=$nbody}$body=$bodytype->new (message=>$self ,checked=>$self->{MM_trusted},charset=>'us-ascii' ,$self->logSettings);$body->contentInfoFrom($head)}my$lines=$head->get('Lines');my$size=$head->guessBodySize;$body->read ($parser,$head,$getbodytype,,$size,(defined$lines ? $lines : undef))}sub storeBody($) {my ($self,$body)=@_;$self->{MM_body}=$body;$body->message($self);$body}sub isDelayed() {my$body=shift->body;!$body || $body->isDelayed}sub takeMessageId(;$) {my$self=shift;my$msgid=(@_ ? shift : $self->get('Message-ID'))|| '';if($msgid =~ m/\<([^>]*)\>/s){$msgid=$1;$msgid =~ s/\s//gs}$msgid=$self->head->createMessageId unless length$msgid;$self->{MM_message_id}=$msgid}sub shortSize(;$) {my$self=shift;my$size=shift;$size=$self->head->guessBodySize unless defined$size;!defined$size ? '?' : $size < 1_000 ? sprintf "%3d ",$size : $size < 10_000 ? sprintf "%3.1fK",$size/1024 : $size < 1_000_000 ? sprintf "%3.0fK",$size/1024 : $size < 10_000_000 ? sprintf "%3.1fM",$size/(1024*1024): sprintf "%3.0fM",$size/(1024*1024)}sub shortString() {my$self=shift;sprintf "%4s %-30.30s",$self->shortSize,$self->subject}sub destruct() {$_[0]=undef}1;
MAIL_MESSAGE

$fatpacked{"Mail/Message/Body.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY';
  package Mail::Message::Body;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Mail::Message::Field;use Mail::Message::Body::Lines;use Mail::Message::Body::File;use Carp;use Scalar::Util qw/weaken refaddr/;use File::Basename qw/basename/;use MIME::Types;my$mime_types=MIME::Types->new;my$mime_plain=$mime_types->type('text/plain');use overload bool=>sub {1},'""'=>'string_unless_carp' ,'@{}'=>'lines' ,'=='=>sub {ref $_[1]&& refaddr $_[0]==refaddr $_[1]},'!='=>sub {ref $_[1]&& refaddr $_[0]!=refaddr $_[1]};my$body_count=0;sub new(@) {my$class=shift;return$class->SUPER::new(@_)unless$class eq __PACKAGE__;my%args=@_;exists$args{file}? Mail::Message::Body::File->new(@_): Mail::Message::Body::Lines->new(@_)}sub _data_from_filename(@) {shift->notImplemented}sub _data_from_filehandle(@) {shift->notImplemented}sub _data_from_glob(@) {shift->notImplemented}sub _data_from_lines(@) {shift->notImplemented}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMB_modified}=$args->{modified}|| 0;my$filename=$args->{filename};my$mime=$args->{mime_type};if(defined(my$file=$args->{file})){if(!ref$file){$self->_data_from_filename($file)or return;$filename ||=$file;$mime ||=$mime_types->mimeTypeOf($filename)|| (-T $file ? 'text/plain' : 'application/octet-stream')}elsif(ref$file eq 'GLOB'){$self->_data_from_glob($file)or return}elsif($file->isa('IO::Handle')){$self->_data_from_filehandle($file)or return}else {croak "message body: illegal datatype `".ref($file)."' for file option"}}elsif(defined(my$data=$args->{data})){if(!ref$data){my@lines=split /^/,$data;$self->_data_from_lines(\@lines)}elsif(ref$data eq 'ARRAY'){$self->_data_from_lines($data)or return}else {croak "message body: illegal datatype `".ref($data)."' for data option"}}elsif(!$self->isMultipart &&!$self->isNested){$self->_data_from_lines([])or return}my ($transfer,$disp,$charset,$descr,$cid)=@$args{qw/transfer_encoding disposition charset description content_id/ };if(defined$filename){$disp //= Mail::Message::Field->new ('Content-Disposition'=>(-T $filename ? 'inline' : 'attachment'),filename=>basename($filename));$mime //= $mime_types->mimeTypeOf($filename)}if(ref$mime && $mime->isa('MIME::Type')){$mime=$mime->type}if(defined(my$based=$args->{based_on})){$mime=$based->type unless defined$mime;$transfer=$based->transferEncoding unless defined$transfer;$disp=$based->disposition unless defined$disp;$descr=$based->description unless defined$descr;$cid=$based->contentId unless defined$cid;$self->{MMB_checked}=defined$args->{checked}? $args->{checked}: $based->checked}else {$transfer=$args->{transfer_encoding};$self->{MMB_checked}=$args->{checked}|| 0}$mime ||='text/plain';$mime=$self->type($mime);$mime->attribute(charset=>($charset || 'PERL'))if$mime =~ m!^text/!i &&!$mime->attribute('charset');$self->transferEncoding($transfer)if defined$transfer;$self->disposition($disp)if defined$disp;$self->description($descr)if defined$descr;$self->contentId($cid)if defined$cid;$self->type($mime);$self->{MMB_eol}=$args->{eol}|| 'NATIVE';$self->message($args->{message})if defined$args->{message};$self->{MMB_seqnr}=$body_count++;$self}sub clone() {shift->notImplemented}sub decoded(@) {my$self=shift;$self->encode(charset=>'PERL',transfer_encoding=>'none',@_)}sub eol(;$) {my$self=shift;return$self->{MMB_eol}unless @_;my$eol=shift;if($eol eq 'NATIVE'){$eol=$^O =~ m/^win/i ? 'CRLF' : $^O =~ m/^mac/i ? 'CR' : 'LF'}return$self if$eol eq $self->{MMB_eol}&& $self->checked;my$lines=$self->lines;if(@$lines){$lines->[-1].= "\n";if($eol eq 'CR'){s/[\015\012]+$/\015/ for @$lines}elsif($eol eq 'LF'){s/[\015\012]+$/\012/ for @$lines}elsif($eol eq 'CRLF'){s/[\015\012]+$/\015\012/ for @$lines}else {$self->log(WARNING=>"Unknown line terminator $eol ignored");return$self->eol('NATIVE')}}(ref$self)->new(based_on=>$self,eol=>$eol,data=>$lines)}sub message(;$) {my$self=shift;if(@_){if($self->{MMB_message}=shift){weaken$self->{MMB_message}}}$self->{MMB_message}}sub isDelayed() {0}sub isMultipart() {0}sub isNested() {0}sub partNumberOf($) {shift->log(ERROR=>'part number needs multi-part or nested');'ERROR'}sub type(;$) {my$self=shift;return$self->{MMB_type}if!@_ && defined$self->{MMB_type};delete$self->{MMB_mime};my$type=defined $_[0]? shift : 'text/plain';$self->{MMB_type}=ref$type ? $type->clone : Mail::Message::Field->new('Content-Type'=>$type)}sub mimeType() {my$self=shift;return$self->{MMB_mime}if exists$self->{MMB_mime};my$field=$self->{MMB_type};my$body=defined$field ? $field->body : '';return$self->{MMB_mime}=$mime_plain unless length$body;$self->{MMB_mime}=$mime_types->type($body)|| MIME::Type->new(type=>$body)}sub charset() {shift->type->attribute('charset')}sub transferEncoding(;$) {my$self=shift;return$self->{MMB_transfer}if!@_ && defined$self->{MMB_transfer};my$set=defined $_[0]? shift : 'none';$self->{MMB_transfer}=ref$set ? $set->clone : Mail::Message::Field->new('Content-Transfer-Encoding'=>$set)}sub description(;$) {my$self=shift;return$self->{MMB_description}if!@_ && $self->{MMB_description};my$disp=defined $_[0]? shift : 'none';$self->{MMB_description}=ref$disp ? $disp->clone : Mail::Message::Field->new('Content-Description'=>$disp)}sub disposition(;$) {my$self=shift;return$self->{MMB_disposition}if!@_ && $self->{MMB_disposition};my$disp=defined $_[0]? shift : 'none';$self->{MMB_disposition}=ref$disp ? $disp->clone : Mail::Message::Field->new('Content-Disposition'=>$disp)}sub contentId(;$) {my$self=shift;return$self->{MMB_id}if!@_ && $self->{MMB_id};my$cid=defined $_[0]? shift : 'none';$self->{MMB_id}=ref$cid ? $cid->clone : Mail::Message::Field->new('Content-ID'=>$cid)}sub checked(;$) {my$self=shift;@_ ? ($self->{MMB_checked}=shift): $self->{MMB_checked}}sub nrLines(@) {shift->notImplemented}sub size(@) {shift->notImplemented}sub string() {shift->notImplemented}sub string_unless_carp() {my$self=shift;return$self->string unless (caller)[0]eq 'Carp';(my$class=ref$self)=~ s/^Mail::Message/MM/;"$class object"}sub lines() {shift->notImplemented}sub file(;$) {shift->notImplemented}sub print(;$) {shift->notImplemented}sub printEscapedFrom($) {shift->notImplemented}sub write(@) {my ($self,%args)=@_;my$filename=$args{filename};die "No filename for write() body" unless defined$filename;open OUT,'>',$filename or return;$self->print(\*OUT);close OUT or return undef;$self}sub endsOnNewline() {shift->notImplemented}sub stripTrailingNewline() {shift->notImplemented}sub read(@) {shift->notImplemented}sub contentInfoTo($) {my ($self,$head)=@_;return unless defined$head;my$lines=$self->nrLines;my$size=$self->size;$size += $lines if$Mail::Message::crlf_platform;$head->set($self->type);$head->set($self->transferEncoding);$head->set($self->disposition);$head->set($self->description);$head->set($self->contentId);$self}sub contentInfoFrom($) {my ($self,$head)=@_;$self->type($head->get('Content-Type',0));my ($te,$disp,$desc,$cid)=map {my$x=$head->get("Content-$_")|| '';s/^\s+//,s/\s+$// for$x;length$x ? $x : undef}qw/Transfer-Encoding Disposition Description ID/;$self->transferEncoding($te);$self->disposition($disp);$self->description($desc);$self->contentId($cid);delete$self->{MMB_mime};$self}sub modified(;$) {my$self=shift;return$self->isModified unless @_;$self->{MMB_modified}=shift}sub isModified() {shift->{MMB_modified}}sub fileLocation(;@) {my$self=shift;return @$self{qw/MMB_begin MMB_end/ }unless @_;@$self{qw/MMB_begin MMB_end/ }=@_}sub moveLocation($) {my ($self,$dist)=@_;$self->{MMB_begin}-= $dist;$self->{MMB_end}-= $dist;$self}sub load() {shift}my@in_encode=qw/check encode encoded eol isBinary isText unify dispositionFilename/;my%in_module=map {($_=>'encode')}@in_encode;sub AUTOLOAD(@) {my$self=shift;our$AUTOLOAD;(my$call=$AUTOLOAD)=~ s/.*\:\://g;my$mod=$in_module{$call}|| 'construct';if($mod eq 'encode'){require Mail::Message::Body::Encode}else {require Mail::Message::Body::Construct}no strict 'refs';return$self->$call(@_)if$self->can($call);confess "Method $call() is not defined for a ",ref$self}1;
MAIL_MESSAGE_BODY

$fatpacked{"Mail/Message/Body/Construct.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_CONSTRUCT';
  package Mail::Message::Body;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Carp;use Mail::Message::Body::String;use Mail::Message::Body::Lines;sub foreachLine($) {my ($self,$code)=@_;my$changes=0;my@result;for ($self->lines){my$becomes=$code->();if(defined$becomes){push@result,$becomes;$changes++ if$becomes ne $_}else {$changes++}}$changes or return$self;ref($self)->new (based_on=>$self ,data=>\@result)}sub concatenate(@) {my$self=shift;return$self if @_==1;my@unified;for (@_){next unless defined $_;push@unified ,!ref $_ ? $_ : ref $_ eq 'ARRAY' ? @$_ : $_->isa('Mail::Message')? $_->body->decoded : $_->isa('Mail::Message::Body')? $_->decoded : carp "Cannot concatenate element ".$_}ref($self)->new (based_on=>$self ,mime_type=>'text/plain' ,data=>join('',@unified))}sub attach(@) {my$self=shift;my@parts;push@parts,shift while @_ && ref $_[0];return$self unless@parts;unshift@parts,($self->isNested ? $self->nested : $self->isMultipart ? $self->parts : $self);return$parts[0]if@parts==1;Mail::Message::Body::Multipart->new(parts=>\@parts,@_)}sub stripSignature($@) {my ($self,%args)=@_;return$self if$self->mimeType->isBinary;my$pattern=!defined$args{pattern}? qr/^--\s?$/ :!ref$args{pattern}? qr/^\Q${args{pattern}}/ : $args{pattern};my$lines=$self->lines;my$stop=defined$args{max_lines}? @$lines - $args{max_lines}: exists$args{max_lines}? 0 : @$lines-10;$stop=0 if$stop < 0;my ($sigstart,$found);if(ref$pattern eq 'CODE'){for($sigstart=$#$lines;$sigstart >= $stop;$sigstart--){next unless$pattern->($lines->[$sigstart]);$found=1;last}}else {for($sigstart=$#$lines;$sigstart >= $stop;$sigstart--){next unless$lines->[$sigstart]=~ $pattern;$found=1;last}}return$self unless$found;my$bodytype=$args{result_type}|| ref$self;my$stripped=$bodytype->new (based_on=>$self ,data=>[@$lines[0..$sigstart-1]]);return$stripped unless wantarray;my$sig=$bodytype->new (based_on=>$self ,data=>[@$lines[$sigstart..$#$lines]]);($stripped,$sig)}1;
MAIL_MESSAGE_BODY_CONSTRUCT

$fatpacked{"Mail/Message/Body/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_DELAYED';
  package Mail::Message::Body::Delayed;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;use Object::Realize::Later becomes=>'Mail::Message::Body',realize=>'load',warn_realization=>0,believe_caller=>1;use Carp;use Scalar::Util 'weaken';use overload '""'=>'string_unless_carp' ,bool=>sub {1},'@{}'=>sub {shift->load->lines};sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMB_seqnr}=-1;$self->{MMBD_message}=$args->{message}or $self->log(INTERNAL=>"A message must be specified to a delayed body.");weaken($self->{MMBD_message});$self}sub message() {shift->{MMBD_message}}sub modified(;$) {return 0 if @_==1 ||!$_[1];shift->forceRealize(shift)}sub isModified() {0}sub isDelayed() {1}sub isMultipart() {shift->message->head->isMultipart}sub guessSize() {shift->{MMBD_size}}sub nrLines() {my ($self)=@_;defined$self->{MMBD_lines}? $self->{MMBD_lines}: $_[0]->forceRealize->nrLines}sub string_unless_carp() {my$self=shift;return$self->load->string if (caller)[0]ne 'Carp';(my$class=ref$self)=~ s/^Mail::Message/MM/g;"$class object"}sub read($$;$@) {my ($self,$parser,$head,$bodytype)=splice @_,0,4;$self->{MMBD_parser}=$parser;@$self{qw/MMBD_begin MMBD_end MMBD_size MMBD_lines/ }=$parser->bodyDelayed(@_);$self}sub fileLocation(;@) {my$self=shift;return @$self{qw/MMBD_begin MMBD_end/ }unless @_;@$self{qw/MMBD_begin MMBD_end/ }=@_}sub moveLocation($) {my ($self,$dist)=@_;$self->{MMBD_begin}-= $dist;$self->{MMBD_end}-= $dist;$self}sub load() {$_[0]=$_[0]->message->loadBody}1;
MAIL_MESSAGE_BODY_DELAYED

$fatpacked{"Mail/Message/Body/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_ENCODE';
  package Mail::Message::Body;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Carp;use MIME::Types ();use File::Basename 'basename';use Encode 'find_encoding';use Mail::Message::Field ();use Mail::Message::Field::Full ();use Encode::Alias;define_alias(qr/^unicode-?1-?1-?utf-?([78])$/i=>'"UTF-$1"');my$mime_types;sub encode(@) {my ($self,%args)=@_;my$type_from=$self->type;my$type_to=$args{mime_type}|| $type_from->clone->study;$type_to=Mail::Message::Field::Full->new('Content-Type'=>$type_to)unless ref$type_to;my$transfer=$args{transfer_encoding}|| $self->transferEncoding->clone;$transfer=Mail::Message::Field->new('Content-Transfer-Encoding' =>$transfer)unless ref$transfer;my$trans_was=lc$self->transferEncoding;my$trans_to=lc$transfer;my ($char_was,$char_to,$from,$to);if($type_from =~ m!^text/!i){$char_was=$type_from->attribute('charset')|| 'us-ascii';$char_to=$type_to->attribute('charset');if(my$charset=delete$args{charset}){if(!$char_to || $char_to ne $charset){$char_to=$charset;$type_to->attribute(charset=>$char_to)}}elsif(!$char_to){$char_to='utf8';$type_to->attribute(charset=>$char_to)}if($char_was ne 'PERL'){$from=find_encoding$char_was or $self->log(WARNING=>"Charset `$char_was' is not known.")}if($char_to ne 'PERL'){$to=find_encoding$char_to or $self->log(WARNING=>"Charset `$char_to' is not known.")}if($trans_to ne 'none' && $char_to eq 'PERL'){$self->log(WARNING=>"Transfer-Encoding `$trans_to' requires " ."explicit charset, defaulted to utf8");$char_to='utf8'}}if($trans_was eq $trans_to){return$self if!$from &&!$to;if($from && $to && $from->name eq $to->name){$self->charset($char_to)if$char_was ne $char_to;return$self}}my$bodytype=$args{result_type}|| ref$self;my$decoded;if($trans_was eq 'none'){$decoded=$self}elsif(my$decoder=$self->getTransferEncHandler($trans_was)){$decoded=$decoder->decode($self,result_type=>$bodytype)}else {$self->log(WARNING=>"No decoder defined for transfer encoding $trans_was.");return$self}my$new_data =$to && $char_was eq 'PERL' ? $to->encode($decoded->string): $from && $char_to eq 'PERL' ? $from->decode($decoded->string): $to && $from && $from->name ne $to->name ? $to->encode($from->decode($decoded->string)): undef;my$recoded=$new_data ? $bodytype->new(based_on=>$decoded ,data=>$new_data,mime_type=>$type_to,checked=>1): $decoded;my$trans;if($trans_to ne 'none'){$trans=$self->getTransferEncHandler($trans_to)or $self->log(WARNING=>"No encoder defined for transfer encoding `$trans_to'.")}my$encoded=defined$trans ? $trans->encode($recoded,result_type=>$bodytype): $recoded;$encoded}sub check() {my$self=shift;return$self if$self->checked;my$eol=$self->eol;my$encoding=$self->transferEncoding->body;return$self->eol($eol)if$encoding eq 'none';my$encoder=$self->getTransferEncHandler($encoding);my$checked =$encoder ? $encoder->check($self)->eol($eol): $self->eol($eol);$checked->checked(1);$checked}sub encoded() {my$self=shift;$mime_types ||=MIME::Types->new;my$mime=$mime_types->type($self->type->body);my$charset=$self->charset || '';my$enc_was=$self->transferEncoding;my$enc=$enc_was;$enc=defined$mime ? $mime->encoding : 'base64' if$enc eq 'none';my$new_charset =(!$mime || $mime !~ m!^text/!i)? '' : (!$charset || $charset eq 'PERL')? 'utf-8' : $charset;($enc_was ne 'none' && $charset eq $new_charset)? $self->check : $self->encode(transfer_encoding=>$enc,charset=>$new_charset)}sub unify($) {my ($self,$body)=@_;return$self if$self==$body;my$mime=$self->type;my$transfer=$self->transferEncoding;my$encoded=$body->encode (mime_type=>$mime ,transfer_encoding=>$transfer);my$newmime=$encoded->type;return unless$newmime eq $mime;return unless$transfer eq $encoded->transferEncoding;$encoded}sub isBinary() {my$self=shift;$mime_types ||=MIME::Types->new(only_complete=>1);my$type=$self->type or return 1;my$mime=$mime_types->type($type->body)or return 1;$mime->isBinary}sub isText() {not shift->isBinary}sub dispositionFilename(;$) {my$self=shift;my$raw;my$field;if($field=$self->disposition){$field=$field->study if$field->can('study');$raw=$field->attribute('filename')|| $field->attribute('file')|| $field->attribute('name')}if(!defined$raw && ($field=$self->type)){$field=$field->study if$field->can('study');$raw=$field->attribute('filename')|| $field->attribute('file')|| $field->attribute('name')}my$base;if(!defined$raw ||!length$raw){}elsif(index($raw,'?')>= 0){eval 'require Mail::Message::Field::Full';$base=Mail::Message::Field::Full->decode($raw)}else {$base=$raw}return$base unless @_;my$dir=shift;my$filename='';if(defined$base){$filename=basename$base;for($filename){s/\s+/ /g;s/ $//;s/^ //;s/[^\w .-]//g}}my ($filebase,$ext)=length$filename && $filename =~ m/(.*)\.([^.]+)/ ? ($1,$2): (part=>($self->mimeType->extensions)[0]|| 'raw');my$fn=File::Spec->catfile($dir,"$filebase.$ext");for(my$unique=1;-e $fn;$unique++){$fn=File::Spec->catfile($dir,"$filebase-$unique.$ext")}$fn}my%transfer_encoder_classes=(base64=>'Mail::Message::TransferEnc::Base64' ,binary=>'Mail::Message::TransferEnc::Binary' ,'8bit'=>'Mail::Message::TransferEnc::EightBit' ,'quoted-printable'=>'Mail::Message::TransferEnc::QuotedPrint' ,'7bit'=>'Mail::Message::TransferEnc::SevenBit');my%transfer_encoders;sub getTransferEncHandler($) {my ($self,$type)=@_;return$transfer_encoders{$type}if exists$transfer_encoders{$type};my$class=$transfer_encoder_classes{$type};return unless$class;eval "require $class";confess "Cannot load $class: $@\n" if $@;$transfer_encoders{$type}=$class->new}sub addTransferEncHandler($$) {my ($this,$name,$what)=@_;my$class;if(ref$what){$transfer_encoders{$name}=$what;$class=ref$what}else {delete$transfer_encoders{$name};$class=$what}$transfer_encoder_classes{$name}=$class;$this}1;
MAIL_MESSAGE_BODY_ENCODE

$fatpacked{"Mail/Message/Body/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_FILE';
  package Mail::Message::Body::File;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Body';use strict;use warnings;use Mail::Box::Parser;use Mail::Message;use Carp;use File::Temp qw/tempfile/;use File::Copy qw/copy/;sub _data_from_filename(@) {my ($self,$filename)=@_;local $_;local (*IN,*OUT);unless(open IN,'<:raw',$filename){$self->log(ERROR=>"Unable to read file $filename for message body file: $!");return}my$file=$self->tempFilename;unless(open OUT,'>:raw',$file){$self->log(ERROR=>"Cannot write to temporary body file $file: $!");return}my$nrlines=0;while(<IN>){print OUT;$nrlines++}close OUT;close IN;$self->{MMBF_nrlines}=$nrlines;$self}sub _data_from_filehandle(@) {my ($self,$fh)=@_;my$file=$self->tempFilename;my$nrlines=0;local*OUT;unless(open OUT,'>:raw',$file){$self->log(ERROR=>"Cannot write to temporary body file $file: $!");return}while(my$l=$fh->getline){print OUT$l;$nrlines++}close OUT;$self->{MMBF_nrlines}=$nrlines;$self}sub _data_from_glob(@) {my ($self,$fh)=@_;my$file=$self->tempFilename;my$nrlines=0;local $_;local*OUT;unless(open OUT,'>:raw',$file){$self->log(ERROR=>"Cannot write to temporary body file $file: $!");return}while(<$fh>){print OUT;$nrlines++}close OUT;$self->{MMBF_nrlines}=$nrlines;$self}sub _data_from_lines(@) {my ($self,$lines)=@_;my$file=$self->tempFilename;local*OUT;unless(open OUT,'>:raw',$file){$self->log(ERROR=>"Cannot write to $file: $!");return}print OUT @$lines;close OUT;$self->{MMBF_nrlines}=@$lines;$self}sub clone() {my$self=shift;my$clone=ref($self)->new(based_on=>$self);copy($self->tempFilename,$clone->tempFilename)or return;$clone->{MMBF_nrlines}=$self->{MMBF_nrlines};$clone->{MMBF_size}=$self->{MMBF_size};$self}sub nrLines() {my$self=shift;return$self->{MMBF_nrlines}if defined$self->{MMBF_nrlines};my$file=$self->tempFilename;my$nrlines=0;local $_;local*IN;open IN,'<:raw',$file or die "Cannot read from $file: $!\n";$nrlines++ while <IN>;close IN;$self->{MMBF_nrlines}=$nrlines}sub size() {my$self=shift;return$self->{MMBF_size}if exists$self->{MMBF_size};my$size=eval {-s $self->tempFilename};$size -= $self->nrLines if$Mail::Message::crlf_platform;$self->{MMBF_size}=$size}sub string() {my$self=shift;my$file=$self->tempFilename;local*IN;open IN,'<:raw',$file or die "Cannot read from $file: $!\n";my$return=join '',<IN>;close IN;$return}sub lines() {my$self=shift;my$file=$self->tempFilename;local*IN;open IN,'<:raw',$file or die "Cannot read from $file: $!\n";my@r=<IN>;close IN;$self->{MMBF_nrlines}=@r;wantarray ? @r: \@r}sub file() {open my$tmp,'<:raw',shift->tempFilename;$tmp}sub print(;$) {my$self=shift;my$fh=shift || select;my$file=$self->tempFilename;local $_;local*IN;open IN,'<:raw',$file or croak "Cannot read from $file: $!\n";if(ref$fh eq 'GLOB'){print$fh $_ while <IN>}else {$fh->print($_)while <IN>}close IN;$self}sub read($$;$@) {my ($self,$parser,$head,$bodytype)=splice @_,0,4;my$file=$self->tempFilename;local*OUT;open OUT,'>:raw',$file or die "Cannot write to $file: $!.\n";(my$begin,my$end,$self->{MMBF_nrlines})=$parser->bodyAsFile(\*OUT,@_);close OUT;$self->fileLocation($begin,$end);$self}sub endsOnNewline() {shift->size==0}sub tempFilename(;$) {my$self=shift;@_ ? ($self->{MMBF_filename}=shift): $self->{MMBF_filename}? $self->{MMBF_filename}: ($self->{MMBF_filename}=(tempfile)[1])}sub DESTROY {unlink shift->tempFilename}1;
MAIL_MESSAGE_BODY_FILE

$fatpacked{"Mail/Message/Body/Lines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_LINES';
  package Mail::Message::Body::Lines;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Body';use strict;use warnings;use Mail::Box::Parser;use IO::Lines;use Carp;sub _data_from_filename(@) {my ($self,$filename)=@_;local*IN;unless(open IN,'<',$filename){$self->log(ERROR=>"Unable to read file $filename for message body lines: $!");return}$self->{MMBL_array}=[<IN> ];close IN;$self}sub _data_from_filehandle(@) {my ($self,$fh)=@_;$self->{MMBL_array}=ref$fh eq 'Mail::Box::FastScalar' ? $fh->getlines : [$fh->getlines ];$self}sub _data_from_glob(@) {my ($self,$fh)=@_;$self->{MMBL_array}=[<$fh> ];$self}sub _data_from_lines(@) {my ($self,$lines)=@_;$lines=[split /^/,$lines->[0]]if @$lines==1;$self->{MMBL_array}=$lines;$self}sub clone() {my$self=shift;ref($self)->new(data=>[$self->lines ],based_on=>$self)}sub nrLines() {scalar @{shift->{MMBL_array}}}sub size() {my$self=shift;return$self->{MMBL_size}if exists$self->{MMBL_size};my$size=0;$size += length $_ foreach @{$self->{MMBL_array}};$self->{MMBL_size}=$size}sub string() {join '',@{shift->{MMBL_array}}}sub lines() {wantarray ? @{shift->{MMBL_array}}: shift->{MMBL_array}}sub file() {IO::Lines->new(shift->{MMBL_array})}sub print(;$) {my$self=shift;my$fh=shift || select;if(ref$fh eq 'GLOB'){print$fh @{$self->{MMBL_array}}}else {$fh->print(@{$self->{MMBL_array}})}$self}sub read($$;$@) {my ($self,$parser,$head,$bodytype)=splice @_,0,4;my ($begin,$end,$lines)=$parser->bodyAsList(@_);$lines or return undef;$self->fileLocation($begin,$end);$self->{MMBL_array}=$lines;$self}sub endsOnNewline() {my$last=shift->{MMBL_array}[-1];!defined$last || $last =~ m/\n$/}1;
MAIL_MESSAGE_BODY_LINES

$fatpacked{"Mail/Message/Body/Multipart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_MULTIPART';
  package Mail::Message::Body::Multipart;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Body';use strict;use warnings;use Mail::Message::Body::Lines;use Mail::Message::Part;use Mail::Box::FastScalar;use Carp;sub init($) {my ($self,$args)=@_;my$based=$args->{based_on};$args->{mime_type}||=defined$based ? $based->type : 'multipart/mixed';$self->SUPER::init($args);my@parts;if($args->{parts}){for my$raw (@{$args->{parts}}){next unless defined$raw;my$cooked=Mail::Message::Part->coerce($raw,$self);$self->log(ERROR=>'Data not convertible to a message (type is ' ,ref$raw,")\n"),next unless defined$cooked;push@parts,$cooked}}my$preamble=$args->{preamble};$preamble=Mail::Message::Body->new(data=>$preamble)if defined$preamble &&!ref$preamble;my$epilogue=$args->{epilogue};$epilogue=Mail::Message::Body->new(data=>$epilogue)if defined$epilogue &&!ref$epilogue;if($based){$self->boundary($args->{boundary}|| $based->boundary);$self->{MMBM_preamble}=defined$preamble ? $preamble : $based->preamble;$self->{MMBM_parts}=@parts ? \@parts :!$args->{parts}&& $based->isMultipart ? [$based->parts('ACTIVE')]: [];$self->{MMBM_epilogue}=defined$epilogue ? $epilogue : $based->epilogue}else {$self->boundary($args->{boundary}||$self->type->attribute('boundary'));$self->{MMBM_preamble}=$preamble;$self->{MMBM_parts}=\@parts;$self->{MMBM_epilogue}=$epilogue}$self}sub isMultipart() {1}sub isBinary() {0}sub clone() {my$self=shift;my$preamble=$self->preamble;my$epilogue=$self->epilogue;my$body=ref($self)->new ($self->logSettings ,based_on=>$self ,preamble=>($preamble ? $preamble->clone : undef),epilogue=>($epilogue ? $epilogue->clone : undef),parts=>[map {$_->clone}$self->parts('ACTIVE')])}sub nrLines() {my$self=shift;my$nr=1;if(my$preamble=$self->preamble){$nr += $preamble->nrLines;$nr++ if$preamble->endsOnNewline}for my$part ($self->parts('ACTIVE')){$nr += 1 + $part->nrLines;$nr++ if$part->body->endsOnNewline}if(my$epilogue=$self->epilogue){$nr += $epilogue->nrLines}$nr}sub size() {my$self=shift;my$bbytes=length($self->boundary)+4;my$bytes=$bbytes +2;if(my$preamble=$self->preamble){$bytes += $preamble->size}else {$bytes -= 1}$bytes += $bbytes + $_->size foreach$self->parts('ACTIVE');if(my$epilogue=$self->epilogue){$bytes += $epilogue->size}$bytes}sub string() {join '',shift->lines}sub lines() {my$self=shift;my$boundary=$self->boundary;my@lines;my$preamble=$self->preamble;push@lines,$preamble->lines if$preamble;for my$part ($self->parts('ACTIVE')){if(!@lines){}elsif($lines[-1]=~ m/\n$/){push@lines,"\n"}else {$lines[-1].= "\n"}push@lines,"--$boundary\n",$part->lines}if(!@lines){}elsif($lines[-1]=~ m/\n$/){push@lines,"\n"}else {$lines[-1].= "\n"}push@lines,"--$boundary--";if(my$epilogue=$self->epilogue){$lines[-1].= "\n";push@lines,$epilogue->lines}wantarray ? @lines : \@lines}sub file() {my$self=shift;my$text;my$dump=Mail::Box::FastScalar->new(\$text);$self->print($dump);$dump->seek(0,0);$dump}sub print(;$) {my$self=shift;my$out=shift || select;my$boundary=$self->boundary;my$count=0;if(my$preamble=$self->preamble){$preamble->print($out);$count++}if(ref$out eq 'GLOB'){for my$part ($self->parts('ACTIVE')){print$out "\n" if$count++;print$out "--$boundary\n";$part->print($out)}print$out "\n" if$count++;print$out "--$boundary--"}else {for my$part ($self->parts('ACTIVE')){$out->print("\n")if$count++;$out->print("--$boundary\n");$part->print($out)}$out->print("\n")if$count++;$out->print("--$boundary--")}if(my$epilogue=$self->epilogue){$out->print("\n");$epilogue->print($out)}$self}sub foreachLine($) {my ($self,$code)=@_;$self->log(ERROR=>"You cannot use foreachLine on a multipart");confess}sub check() {my$self=shift;$self->foreachComponent(sub {$_[1]->check})}sub encode(@) {my ($self,%args)=@_;$self->foreachComponent(sub {$_[1]->encode(%args)})}sub encoded() {my$self=shift;$self->foreachComponent(sub {$_[1]->encoded})}sub read($$$$) {my ($self,$parser,$head,$bodytype)=@_;my$boundary=$self->boundary;$parser->pushSeparator("--$boundary");my@msgopts=$self->logSettings;my$te;$te=lc $1 if +($head->get('Content-Transfer-Encoding')|| '')=~ m/(\w+)/;my@sloppyopts=(mime_type=>'text/plain' ,transfer_encoding=>$te);my$headtype=ref$head;my$begin=$parser->filePosition;my$preamble=Mail::Message::Body::Lines->new(@msgopts,@sloppyopts)->read($parser,$head);$preamble->nrLines or undef$preamble;$self->{MMBM_preamble}=$preamble if defined$preamble;my@parts;while(my$sep=$parser->readSeparator){last if$sep eq "--$boundary--\n";my$part=Mail::Message::Part->new (@msgopts ,container=>$self);last unless$part->readFromParser($parser,$bodytype);push@parts,$part if$part->head->names || $part->body->size}$self->{MMBM_parts}=\@parts;$parser->popSeparator;my$epilogue=Mail::Message::Body::Lines->new(@msgopts,@sloppyopts)->read($parser,$head);my$end=defined$epilogue ? ($epilogue->fileLocation)[1]: @parts ? ($parts[-1]->body->fileLocation)[1]: defined$preamble ? ($preamble->fileLocation)[1]: $begin;$self->fileLocation($begin,$end);$epilogue->nrLines or undef$epilogue;$self->{MMBM_epilogue}=$epilogue if defined$epilogue;$self}sub foreachComponent($) {my ($self,$code)=@_;my$changes=0;my$new_preamble;if(my$preamble=$self->preamble){$new_preamble=$code->($self,$preamble);$changes++ unless$preamble==$new_preamble}my$new_epilogue;if(my$epilogue=$self->epilogue){$new_epilogue=$code->($self,$epilogue);$changes++ unless$epilogue==$new_epilogue}my@new_bodies;for my$part ($self->parts('ACTIVE')){my$part_body=$part->body;my$new_body=$code->($self,$part_body);$changes++ if$new_body!=$part_body;push@new_bodies,[$part,$new_body]}return$self unless$changes;my@new_parts;for (@new_bodies){my ($part,$body)=@$_;my$new_part=Mail::Message::Part->new (head=>$part->head->clone,container=>undef);$new_part->body($body);push@new_parts,$new_part}my$constructed=(ref$self)->new (preamble=>$new_preamble ,parts=>\@new_parts ,epilogue=>$new_epilogue ,based_on=>$self);$_->container($constructed)foreach@new_parts;$constructed}sub attach(@) {my$self=shift;my$new=ref($self)->new (based_on=>$self ,parts=>[$self->parts,@_])}sub stripSignature(@) {my$self=shift;my@allparts=$self->parts;my@parts=grep {!$_->body->mimeType->isSignature}@allparts;@allparts==@parts ? $self : (ref$self)->new(based_on=>$self,parts=>\@parts)}sub preamble() {shift->{MMBM_preamble}}sub epilogue() {shift->{MMBM_epilogue}}sub parts(;$) {my$self=shift;return @{$self->{MMBM_parts}}unless @_;my$what=shift;my@parts=@{$self->{MMBM_parts}};$what eq 'RECURSE' ? (map {$_->parts('RECURSE')}@parts): $what eq 'ALL' ? @parts : $what eq 'DELETED' ? (grep {$_->isDeleted}@parts): $what eq 'ACTIVE' ? (grep {not $_->isDeleted}@parts): ref$what eq 'CODE'? (grep {$what->($_)}@parts): ($self->log(ERROR=>"Unknown criterium $what to select parts."),return ())}sub part($) {shift->{MMBM_parts}[shift]}sub partNumberOf($) {my ($self,$part)=@_;my@parts=$self->parts('ACTIVE');my$msg=$self->message;unless($msg){$self->log(ERROR=>'multipart is not connected');return 'ERROR'}my$base=$msg->isa('Mail::Message::Part')? $msg->partNumber.'.' : '';for my$partnr (0..@parts){return$base.($partnr+1)if$parts[$partnr]==$part}$self->log(ERROR=>'multipart is not found or not active');'ERROR'}sub boundary(;$) {my$self=shift;my$mime=$self->type;unless(@_){my$boundary=$mime->attribute('boundary');return$boundary if defined$boundary}my$boundary=@_ && defined $_[0]? (shift): "boundary-".int rand(1000000);$self->type->attribute(boundary=>$boundary)}sub endsOnNewline() {1}sub toplevel() {my$msg=shift->message;$msg ? $msg->toplevel : undef}1;
MAIL_MESSAGE_BODY_MULTIPART

$fatpacked{"Mail/Message/Body/Nested.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_NESTED';
  package Mail::Message::Body::Nested;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Body';use strict;use warnings;use Mail::Message::Body::Lines;use Mail::Message::Part;use Carp;sub init($) {my ($self,$args)=@_;$args->{mime_type}||='message/rfc822';$self->SUPER::init($args);my$nested;if(my$raw=$args->{nested}){$nested=Mail::Message::Part->coerce($raw,$self);croak 'Data not convertible to a message (type is ',ref$raw,")\n" unless defined$nested}$self->{MMBN_nested}=$nested;$self}sub isNested() {1}sub isBinary() {shift->nested->body->isBinary}sub clone() {my$self=shift;ref($self)->new ($self->logSettings ,based_on=>$self ,nested=>$self->nested->clone)}sub nrLines() {shift->nested->nrLines}sub size() {shift->nested->size}sub string() {my$nested=shift->nested;defined$nested ? $nested->string : ''}sub lines() {my$nested=shift->nested;defined$nested ? ($nested->lines): ()}sub file() {my$nested=shift->nested;defined$nested ? $nested->file : undef}sub print(;$) {my$self=shift;$self->nested->print(shift || select)}sub partNumberOf($) {my ($self,$part)=@_;$self->message->partNumber}sub foreachLine($) {my ($self,$code)=@_;$self->log(ERROR=>"You cannot use foreachLine on a nested");confess}sub check() {shift->forNested(sub {$_[1]->check})}sub encode(@) {my ($self,%args)=@_;$self->forNested(sub {$_[1]->encode(%args)})}sub encoded() {shift->forNested(sub {$_[1]->encoded})}sub read($$$$) {my ($self,$parser,$head,$bodytype)=@_;my$nest=Mail::Message::Part->new(container=>undef);$nest->readFromParser($parser,$bodytype)or return;$nest->container($self);$self->{MMBN_nested}=$nest;$self}sub fileLocation() {my$nested=shift->nested;(($nested->head->fileLocation)[0],($nested->body->fileLocation)[1])}sub endsOnNewline() {shift->nested->body->endsOnNewline}sub moveLocation($) {my$self=shift;my$nested=$self->nested;my$dist=shift or return$self;$nested->head->moveLocation($dist);$nested->body->moveLocation($dist);$self}sub nested() {shift->{MMBN_nested}}sub forNested($) {my ($self,$code)=@_;my$nested=$self->nested;my$body=$nested->body;my$new_body=$code->($self,$body)or return;return$self if$new_body==$body;my$new_nested=Mail::Message::Part->new (head=>$nested->head->clone ,container=>undef);$new_nested->body($new_body);my$created=(ref$self)->new (based_on=>$self ,nested=>$new_nested);$new_nested->container($created);$created}sub toplevel() {my$msg=shift->message;$msg ? $msg->toplevel : undef}1;
MAIL_MESSAGE_BODY_NESTED

$fatpacked{"Mail/Message/Body/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_BODY_STRING';
  package Mail::Message::Body::String;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Body';use strict;use warnings;use Carp;use Mail::Box::FastScalar;sub _data_from_filename(@) {my ($self,$filename)=@_;delete$self->{MMBS_nrlines};local*IN;unless(open IN,'<',$filename){$self->log(ERROR=>"Unable to read file $filename for message body scalar: $!");return}my@lines=<IN>;close IN;$self->{MMBS_nrlines}=@lines;$self->{MMBS_scalar}=join '',@lines;$self}sub _data_from_filehandle(@) {my ($self,$fh)=@_;if(ref$fh eq 'Mail::Box::FastScalar'){my$lines=$fh->getlines;$self->{MMBS_nrlines}=@$lines;$self->{MMBS_scalar}=join '',@$lines}else {my@lines=$fh->getlines;$self->{MMBS_nrlines}=@lines;$self->{MMBS_scalar}=join '',@lines}$self}sub _data_from_glob(@) {my ($self,$fh)=@_;my@lines=<$fh>;$self->{MMBS_nrlines}=@lines;$self->{MMBS_scalar}=join '',@lines;$self}sub _data_from_lines(@) {my ($self,$lines)=@_;$self->{MMBS_nrlines}=@$lines unless @$lines==1;$self->{MMBS_scalar}=@$lines==1 ? shift @$lines : join('',@$lines);$self}sub clone() {my$self=shift;ref($self)->new(data=>$self->string,based_on=>$self)}sub nrLines() {my$self=shift;return$self->{MMBS_nrlines}if defined$self->{MMBS_nrlines};my$lines=$self->{MMBS_scalar}=~ tr/\n/\n/;$lines++ if$self->{MMBS_scalar}!~ m/\n\z/;$self->{MMBS_nrlines}=$lines}sub size() {length shift->{MMBS_scalar}}sub string() {shift->{MMBS_scalar}}sub lines() {my@lines=split /^/,shift->{MMBS_scalar};wantarray ? @lines : \@lines}sub file() {Mail::Box::FastScalar->new(\shift->{MMBS_scalar})}sub print(;$) {my$self=shift;my$fh=shift || select;if(ref$fh eq 'GLOB'){print$fh $self->{MMBS_scalar}}else {$fh->print($self->{MMBS_scalar})}$self}sub read($$;$@) {my ($self,$parser,$head,$bodytype)=splice @_,0,4;delete$self->{MMBS_nrlines};(my$begin,my$end,$self->{MMBS_scalar})=$parser->bodyAsString(@_);$self->fileLocation($begin,$end);$self}sub endsOnNewline() {shift->{MMBS_scalar}=~ m/\A\z|\n\z/}1;
MAIL_MESSAGE_BODY_STRING

$fatpacked{"Mail/Message/Construct.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;our%locations=(bounce=>'Bounce' ,build=>'Build',buildFromBody=>'Build' ,forward=>'Forward',forwardNo=>'Forward',forwardInline=>'Forward',forwardAttach=>'Forward',forwardEncapsulate=>'Forward',forwardSubject=>'Forward',forwardPrelude=>'Forward',forwardPostlude=>'Forward' ,read=>'Read' ,rebuild=>'Rebuild' ,reply=>'Reply',replySubject=>'Reply',replyPrelude=>'Reply' ,string=>'Text',lines=>'Text',file=>'Text',printStructure=>'Text');sub AUTOLOAD(@) {my$self=shift;our$AUTOLOAD;(my$call=$AUTOLOAD)=~ s/.*\:\://g;if(my$mod=$locations{$call}){eval "require Mail::Message::Construct::$mod";die $@ if $@;return$self->$call(@_)}our@ISA;$call="${ISA[0]}::$call";$self->$call(@_)}1;
MAIL_MESSAGE_CONSTRUCT

$fatpacked{"Mail/Message/Construct/Bounce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_BOUNCE';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Message::Head::Complete;use Mail::Message::Field;use Carp qw/croak/;sub bounce(@) {my$self=shift;my$bounce=$self->clone;my$head=$bounce->head;if(@_==1 && ref $_[0]&& $_[0]->isa('Mail::Message::Head::ResentGroup')){$head->addResentGroup(shift);return$bounce}my@rgs=$head->resentGroups;my$rg=$rgs[0];if(defined$rg){$rg->delete;while(@_){my$field=shift;ref$field ? $rg->set($field): $rg->set($field,shift)}}elsif(@_){$rg=Mail::Message::Head::ResentGroup->new(@_)}else {$self->log(ERROR=>"Method bounce requires To, Cc, or Bcc");return undef}$rg->set(Date=>Mail::Message::Field->toDate)unless defined$rg->date;unless(defined$rg->messageId){my$msgid=$head->createMessageId;$rg->set('Message-ID'=>"<$msgid>")}$head->addResentGroup($rg);$self->label(passed=>1);$bounce}1;
MAIL_MESSAGE_CONSTRUCT_BOUNCE

$fatpacked{"Mail/Message/Construct/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_BUILD';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Message::Head::Complete ();use Mail::Message::Body::Lines ();use Mail::Message::Body::Multipart ();use Mail::Message::Body::Nested ();use Mail::Message::Field ();use Mail::Address ();sub build(@) {my$class=shift;if($class->isa('Mail::Box::Message')){$class->log(ERROR =>"Only build() Mail::Message's; they are not in a folder yet");return undef}my@parts =!ref $_[0]? (): $_[0]->isa('Mail::Message')? shift : $_[0]->isa('Mail::Message::Body')? shift : ();my ($head,@headerlines);my ($type,$transfenc,$dispose,$descr,$cid);while(@_){my$key=shift;if(ref$key && $key->isa('Mail::Message::Field')){my$name=$key->name;if($name eq 'content-type'){$type=$key}elsif($name eq 'content-transfer-encoding'){$transfenc=$key}elsif($name eq 'content-disposition'){$dispose=$key}elsif($name eq 'content-description'){$descr=$key}elsif($name eq 'content-id'){$cid=$key}else {push@headerlines,$key}next}my$value=shift;next unless defined$value;my@data;if($key eq 'head'){$head=$value}elsif($key eq 'data'){@data=Mail::Message::Body->new(data=>$value)}elsif($key eq 'file' || $key eq 'files'){@data=map Mail::Message::Body->new(file=>$_),ref$value eq 'ARRAY' ? @$value : $value}elsif($key eq 'attach'){for my$c (ref$value eq 'ARRAY' ? @$value : $value){defined$c or next;push@data,ref$c && $c->isa('Mail::Message')? Mail::Message::Body::Nested->new(nested=>$c): $c}}elsif($key =~ m/^content\-(type|transfer\-encoding|disposition|description|id)$/i){my$k=lc $1;my$field=Mail::Message::Field->new($key,$value);if($k eq 'type'){$type=$field}elsif($k eq 'disposition'){$dispose=$field}elsif($k eq 'description'){$descr=$field}elsif($k eq 'id'){$cid=$field}else {$transfenc=$field}}elsif($key =~ m/^[A-Z]/){push@headerlines,$key,$value}else {$class->log(WARNING=>"Skipped unknown key '$key' in build")}push@parts,grep defined,@data}my$body =@parts==0 ? Mail::Message::Body::Lines->new(): @parts==1 ? $parts[0]: Mail::Message::Body::Multipart->new(parts=>\@parts);$body->type($type)if defined$type;$body->disposition($dispose)if defined$dispose;$body->description($descr)if defined$descr;$body->contentId($cid)if defined$cid;$body->transferEncoding($transfenc)if defined$transfenc;$class->buildFromBody($body,$head,@headerlines)}sub buildFromBody(@) {my ($class,$body)=(shift,shift);my@log=$body->logSettings;my$head;if(ref $_[0]&& $_[0]->isa('Mail::Message::Head')){$head=shift}else {shift unless defined $_[0];$head=Mail::Message::Head::Complete->new(@log)}while(@_){if(ref $_[0]){$head->add(shift)}else {$head->add(shift,shift)}}my$message=$class->new (head=>$head ,@log);$message->body($body);$head->add('Message-Id'=>'<'.$message->messageId.'>')unless defined$head->get('message-id');$head->add(Date=>Mail::Message::Field->toDate)unless defined$head->get('Date');$head->add('MIME-Version'=>'1.0')unless defined$head->get('MIME-Version');$message}1;
MAIL_MESSAGE_CONSTRUCT_BUILD

$fatpacked{"Mail/Message/Construct/Forward.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_FORWARD';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Message::Body::Multipart;use Mail::Message::Body::Nested;use Scalar::Util 'blessed';sub forward(@) {my$self=shift;my%args=@_;return$self->forwardNo(@_)if exists$args{body};my$include=$args{include}|| 'INLINE';return$self->forwardInline(@_)if$include eq 'INLINE';my$preamble=$args{preamble};push @_,preamble=>Mail::Message::Body->new(data=>$preamble)if defined$preamble &&!ref$preamble;return$self->forwardAttach(@_)if$include eq 'ATTACH';return$self->forwardEncapsulate(@_)if$include eq 'ENCAPSULATE';$self->log(ERROR=>'Cannot include forward source as $include.');undef}sub forwardNo(@) {my ($self,%args)=@_;my$body=$args{body};$self->log(INTERNAL=>"No body supplied for forwardNo()")unless defined$body;my$mainhead=$self->toplevel->head;my$from=$args{From};unless(defined$from){my@from=$self->to;$from=\@from if@from}my$to=$args{To};$self->log(ERROR=>"No address to create forwarded to."),return unless$to;my$srcsub=$args{Subject};my$subject =!defined$srcsub ? $self->forwardSubject($self->subject): ref$srcsub ? $srcsub->($self->subject): $srcsub;my$msgid=$args{'Message-ID'}|| $mainhead->createMessageId;$msgid="<$msgid>" if$msgid && $msgid !~ /^\s*\<.*\>\s*$/;my$origid='<'.$self->messageId.'>';my$refs=$mainhead->get('references');my$forward=Mail::Message->buildFromBody ($body ,From=>($from || '(undisclosed)'),To=>$to ,Subject=>$subject ,References=>($refs ? "$refs $origid" : $origid));my$newhead=$forward->head;$newhead->set(Cc=>$args{Cc})if$args{Cc};$newhead->set(Bcc=>$args{Bcc})if$args{Bcc};$newhead->set(Date=>$args{Date})if$args{Date};$self->label(passed=>1);$self->log(PROGRESS=>"Forward created from $origid");$forward}sub forwardInline(@) {my ($self,%args)=@_;my$body=$self->body;while(1){if($body->isMultipart && $body->parts==1){$body=$body->part(0)->body}elsif($body->isNested){$body=$body->nested->body}else {last}}my$prelude=exists$args{prelude}? $args{prelude}: $self->forwardPrelude;$prelude=Mail::Message::Body->new(data=>$prelude)if defined$prelude &&!blessed$prelude;my$postlude=exists$args{postlude}? $args{postlude}: $self->forwardPostlude;if($body->isMultipart || $body->isBinary){$args{preamble}||=$prelude->concatenate ($prelude ,($args{is_attached}|| "[The forwarded message is attached]\n"),$postlude);return$self->forwardAttach(%args)}$body=$body->decoded;my$strip=(!exists$args{strip_signature}|| $args{strip_signature})&&!$body->isNested;$body=$body->stripSignature (pattern=>$args{strip_signature},max_lines=>$args{max_signature})if$strip;if(defined(my$quote=$args{quote})){my$quoting=ref$quote ? $quote : sub {$quote .$_};$body=$body->foreachLine($quoting)}my$signature=$args{signature};$signature=$signature->body if defined$signature && $signature->isa('Mail::Message');my$composed=$body->concatenate ($prelude,$body,$postlude ,(defined$signature ? "-- \n" : undef),$signature);$self->forwardNo(%args,body=>$composed)}sub forwardAttach(@) {my ($self,%args)=@_;my$body=$self->body;my$strip=!exists$args{strip_signature}|| $args{strip_signature};if($body->isMultipart){$body=$body->stripSignature if$strip;$body=$body->part(0)->body if$body->parts==1}my$preamble=$args{preamble};$self->log(ERROR=>'Method forwardAttach requires a preamble'),return unless ref$preamble;my@parts=($preamble,$body);push@parts,$args{signature}if defined$args{signature};my$multi=Mail::Message::Body::Multipart->new(parts=>\@parts);$self->forwardNo(%args,body=>$multi)}sub forwardEncapsulate(@) {my ($self,%args)=@_;my$preamble=$args{preamble};$self->log(ERROR=>'Method forwardEncapsulate requires a preamble'),return unless ref$preamble;my$nested=Mail::Message::Body::Nested->new(nested=>$self->clone);my@parts=($preamble,$nested);push@parts,$args{signature}if defined$args{signature};my$multi=Mail::Message::Body::Multipart->new(parts=>\@parts);$self->forwardNo(%args,body=>$multi)}sub forwardSubject($) {my ($self,$subject)=@_;defined$subject && length$subject ? "Forw: $subject" : "Forwarded"}sub forwardPrelude() {my$head=shift->head;my@lines="---- BEGIN forwarded message\n";my$from=$head->get('from');my$to=$head->get('to');my$cc=$head->get('cc');my$date=$head->get('date');push@lines,$from->string if defined$from;push@lines,$to->string if defined$to;push@lines,$cc->string if defined$cc;push@lines,$date->string if defined$date;push@lines,"\n";\@lines}sub forwardPostlude() {my$self=shift;my@lines=("---- END forwarded message\n");\@lines}1;
MAIL_MESSAGE_CONSTRUCT_FORWARD

$fatpacked{"Mail/Message/Construct/Read.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_READ';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Box::FastScalar;sub read($@) {my ($class,$from,%args)=@_;my ($filename,$file);my$ref=ref$from;if(!$ref){$filename='scalar';$file=Mail::Box::FastScalar->new(\$from)}elsif($ref eq 'SCALAR'){$filename='ref scalar';$file=Mail::Box::FastScalar->new($from)}elsif($ref eq 'ARRAY'){$filename='array of lines';my$buffer=join '',@$from;$file=Mail::Box::FastScalar->new(\$buffer)}elsif($ref eq 'GLOB'){$filename='file (GLOB)';local $/;my$buffer=<$from>;$file=Mail::Box::FastScalar->new(\$buffer)}elsif($ref && $from->isa('IO::Handle')){$filename='file ('.ref($from).')';my$buffer=join '',$from->getlines;$file=Mail::Box::FastScalar->new(\$buffer)}else {$class->log(ERROR=>"Cannot read from $from");return undef}my$strip_status=exists$args{strip_status_fields}? delete$args{strip_status_fields}: 1;require Mail::Box::Parser::Perl;my$parser=Mail::Box::Parser::Perl->new (%args ,filename=>$filename ,file=>$file ,trusted=>1);my$self=$class->new(%args);$self->readFromParser($parser,$args{body_type});$self->addReport($parser);$parser->stop;my$head=$self->head;$head->set('Message-ID'=>'<'.$self->messageId.'>')unless$head->get('Message-ID');$head->delete('Status','X-Status')if$strip_status;$self}1;
MAIL_MESSAGE_CONSTRUCT_READ

$fatpacked{"Mail/Message/Construct/Rebuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_REBUILD';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Message::Head::Complete;use Mail::Message::Body::Lines;use Mail::Message::Body::Multipart;use Mail::Address;use Scalar::Util 'blessed';use List::Util 'first';use Mail::Box::FastScalar;my@default_rules=qw/replaceDeletedParts descendMultiparts descendNested flattenMultiparts flattenEmptyMultiparts/;sub rebuild(@) {my ($self,%args)=@_;my@rules=$args{rules}? @{$args{rules}}: @default_rules;unshift@rules,@{$args{extra_rules}}if$args{extra_rules};unshift@rules,@{$args{extraRules}}if$args{extraRules};for my$rule (@rules){next if ref$rule;unless($self->can($rule)){$self->log(ERROR=>"No rebuild rule '$rule' defined.\n");return 1}}my$rebuild=$self->recursiveRebuildPart($self,rules=>\@rules)or return;if($rebuild->isa('Mail::Message::Part')){my$clone=Mail::Message->new(head=>$self->head->clone);$clone->body($rebuild->body);$rebuild=$clone}$args{keep_message_id}or $rebuild->takeMessageId;$rebuild}sub flattenNesting($@) {my ($self,$part)=@_;$part->isNested ? $part->body->nested : $part}sub flattenMultiparts($@) {my ($self,$part)=@_;return$part unless$part->isMultipart;my@active=$part->parts('ACTIVE');@active==1 ? $active[0]: $part}sub removeEmptyMultiparts($@) {my ($self,$part)=@_;$part->isMultipart && $part->body->parts==0 ? undef : $part}sub flattenEmptyMultiparts($@) {my ($self,$part)=@_;$part->isMultipart && $part->parts('ACTIVE')==0 or return$part;my$body=$part->body;my$preamble=$body->preamble || Mail::Message::Body::Lines->new(data=>'');my$epilogue=$body->epilogue;my$newbody=$preamble->concatenate($preamble,<<NO_PARTS,$epilogue);my$rebuild=Mail::Message::Part->new (head=>$part->head->clone ,container=>undef);$rebuild->body($newbody);$rebuild}sub removeEmptyBodies($@) {my ($self,$part)=@_;$part->body->lines==0 ? undef : $part}sub descendMultiparts($@) {my ($self,$part,%args)=@_;return$part unless$part->isMultipart;my$body=$part->body;my$changed=0;my@newparts;for my$part ($body->parts){my$new=$self->recursiveRebuildPart($part,%args);if(!defined$new){$changed++}elsif($new==$part){push@newparts,$part}else {push@newparts,$new;$changed++}}$changed or return$part;my$newbody=ref($body)->new (based_on=>$body ,parts=>\@newparts);my$rebuild=ref($part)->new (head=>$part->head->clone ,container=>undef);$rebuild->body($newbody);$rebuild}sub descendNested($@) {my ($self,$part,%args)=@_;$part->isNested or return$part;my$body=$part->body;my$srcnested=$body->nested;my$newnested=$self->recursiveRebuildPart($srcnested,%args);defined$newnested or return undef;return$part if$newnested==$srcnested;my$newbody=ref($body)->new(based_on=>$body,nested=>$newnested);my$rebuild=ref($part)->new(head=>$part->head->clone ,container=>undef);$rebuild->body($newbody);$rebuild}sub removeDeletedParts($@) {my ($self,$part)=@_;$part->isDeleted ? undef : $part}sub replaceDeletedParts($@) {my ($self,$part)=@_;($part->isNested && $part->body->nested->isDeleted)|| $part->isDeleted or return$part;my$structure='';my$output=Mail::Box::FastScalar->new(\$structure,'  ');$part->printStructure($output);my$dispfn=$part->body->dispositionFilename || '';Mail::Message::Part->build (data=>"Removed content:\n\n$structure\n$dispfn")}sub removeHtmlAlternativeToText($@) {my ($self,$part,%args)=@_;$part->body->mimeType eq 'text/html' or return$part;my$container=$part->container;return$part unless defined$container && $container->mimeType eq 'multipart/alternative';for my$subpart ($container->parts){return undef if$subpart->body->mimeType eq 'text/plain'}$part}sub removeExtraAlternativeText($@) {my ($self,$part,%args)=@_;my$container=$part->container;$container && $container->mimeType eq 'multipart/alternative' or return$part;my$last=($container->parts)[-1];$last && $part==$last ? $part : undef}my$has_hft;sub textAlternativeForHtml($@) {my ($self,$part,%args)=@_;my$hft='Mail::Message::Convert::HtmlFormatText';unless(defined$has_hft){eval "require Mail::Message::Convert::HtmlFormatText";$has_hft=$hft->can('format')}return$part unless$has_hft && $part->body->mimeType eq 'text/html';my$container=$part->container;my$in_alt=defined$container && $container->mimeType eq 'multipart/alternative';return$part if$in_alt && first {$_->body->mimeType eq 'text/plain'}$container->parts;my$html_body=$part->body;my$plain_body=$hft->new->format($html_body);my$plain_part=Mail::Message::Part->new(container=>undef);$plain_part->body($plain_body);return$container->attach($plain_part)if$in_alt;my$html_part=Mail::Message::Part->new(container=>undef);$html_part->body($html_body);my$mp=Mail::Message::Body::Multipart->new (mime_type=>'multipart/alternative' ,parts=>[$plain_part,$html_part ]);my$newpart=ref($part)->new (head=>$part->head->clone ,container=>undef);$newpart->body($mp);$newpart}sub recursiveRebuildPart($@) {my ($self,$part,%args)=@_;RULES: foreach my$rule (@{$args{rules}}){my$rebuild=$self->$rule($part,%args)or return undef;if($part!=$rebuild){$part=$rebuild;redo RULES}}$part}1;
    * PLEASE NOTE:
    * This multipart did not contain any parts (anymore)
    * and was therefore flattened.
  
  NO_PARTS
MAIL_MESSAGE_CONSTRUCT_REBUILD

$fatpacked{"Mail/Message/Construct/Reply.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_REPLY';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Mail::Message::Body::Multipart;use Mail::Address;use Scalar::Util 'blessed';sub reply(@) {my ($self,%args)=@_;my$body=$args{body};my$strip=!exists$args{strip_signature}|| $args{strip_signature};my$include=$args{include}|| 'INLINE';if($include eq 'NO'){$body=Mail::Message::Body->new (data=>["\n[The original message is not included]\n\n"])unless defined$body}elsif($include eq 'INLINE' || $include eq 'ATTACH'){unless(defined$body){$body=$self->body;$body=$body->part(0)->body if$body->isMultipart && $body->parts==1;$body=$body->nested->body if$body->isNested;$body =$strip &&!$body->isMultipart &&!$body->isBinary ? $body->decoded->stripSignature (pattern=>$args{strip_signature},max_lines=>$args{max_signature}): $body->decoded}if($include eq 'INLINE' && $body->isMultipart){$include='ATTACH'}elsif($include eq 'INLINE' && $body->isBinary){$include='ATTACH';$body=Mail::Message::Body::Multipart->new(parts=>[$body])}if($include eq 'INLINE'){my$quote =defined$args{quote}? $args{quote}: exists$args{quote}? undef : '> ';if(defined$quote){my$quoting=ref$quote ? $quote : sub {$quote .$_};$body=$body->foreachLine($quoting)}}}else {$self->log(ERROR=>"Cannot include reply source as $include.");return}my$mainhead=$self->toplevel->head;my$from=delete$args{From};unless(defined$from){my@from=$self->to;$from=\@from if@from}my$to=delete$args{To}|| $mainhead->get('reply-to')|| $mainhead->get('from');defined$to or return;my$cc=delete$args{Cc};if(!defined$cc && $args{group_reply}){my@cc=$self->cc;$cc=[$self->cc ]if@cc}my$srcsub=delete$args{Subject};my$subject =!defined$srcsub ? $self->replySubject($self->subject): ref$srcsub ? $srcsub->($self->subject): $srcsub;my$msgid=delete$args{'Message-ID'};$msgid="<$msgid>" if$msgid && $msgid !~ /^\s*\<.*\>\s*$/;my$origid='<'.$self->messageId.'>';my$refs=$mainhead->get('references');my$prelude =defined$args{prelude}? $args{prelude}: exists$args{prelude}? undef : [$self->replyPrelude($to)];$prelude=Mail::Message::Body->new(data=>$prelude)if defined$prelude &&!blessed$prelude;my$postlude=$args{postlude};$postlude=Mail::Message::Body->new(data=>$postlude)if defined$postlude &&!blessed$postlude;my$total;if($include eq 'NO'){$total=$body}elsif($include eq 'INLINE'){my$signature=$args{signature};$signature=$signature->body if defined$signature && $signature->isa('Mail::Message');$total=$body->concatenate ($prelude,$body,$postlude ,(defined$signature ? "-- \n" : undef),$signature)}if($include eq 'ATTACH'){my$intro=$prelude->concatenate ($prelude ,["\n","[Your message is attached]\n" ],$postlude);$total=Mail::Message::Body::Multipart->new (parts=>[$intro,$body,$args{signature}])}my$msgtype=$args{message_type}|| 'Mail::Message';my$reply=$msgtype->buildFromBody ($total ,From=>$from || 'Undisclosed senders:;' ,To=>$to ,Subject=>$subject ,'In-Reply-To'=>$origid ,References=>($refs ? "$refs $origid" : $origid));my$newhead=$reply->head;$newhead->set(Cc=>$cc)if$cc;$newhead->set(Bcc=>delete$args{Bcc})if$args{Bcc};$newhead->add($_=>$args{$_})for sort grep /^[A-Z]/,keys%args;$self->log(PROGRESS=>'Reply created from '.$origid);$self->label(replied=>1);$reply}sub replySubject($) {my ($thing,$subject)=@_;$subject='your mail' unless defined$subject && length$subject;my@subject=split /\:/,$subject;my$re_count=1;while(@subject){last if$subject[0]=~ /[A-QS-Za-qs-z][A-DF-Za-df-z]/;for(shift@subject){while(/\bRe(?:\[\s*(\d+)\s*\]|\b)/g){$re_count += defined $1 ? $1 : 1}}}if(@subject){for($subject[-1]){$re_count++ while s/\s*\(\s*(re|forw)\W*\)\s*$//i}}my$text=(join ':',@subject)|| 'your mail';for($text){s/^\s+//;s/\s+$//}$re_count==1 ? "Re: $text" : "Re[$re_count]: $text"}sub replyPrelude($) {my ($self,$who)=@_;$who=$who->[0]if ref$who eq 'ARRAY';my$user =!defined$who ? undef :!ref$who ? (Mail::Address->parse($who))[0]: $who->isa('Mail::Message::Field')? ($who->addresses)[0]: $who;my$from =ref$user && $user->isa('Mail::Address')? ($user->name || $user->address || $user->format): 'someone';my$time=gmtime$self->timestamp;"On $time, $from wrote:\n"}1;
MAIL_MESSAGE_CONSTRUCT_REPLY

$fatpacked{"Mail/Message/Construct/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONSTRUCT_TEXT';
  package Mail::Message;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use IO::Lines;sub string() {my$self=shift;$self->head->string .$self->body->string}sub lines() {my$self=shift;my@lines;my$file=IO::Lines->new(\@lines);$self->print($file);wantarray ? @lines : \@lines}sub file() {my$self=shift;my@lines;my$file=IO::Lines->new(\@lines);$self->print($file);$file->seek(0,0);$file}sub printStructure(;$$) {my$self=shift;my$indent =@_==2 ? pop : defined $_[0]&&!ref $_[0]? shift : '';my$fh=@_ ? shift : select;my$buffer;open$fh,'>:raw',\$buffer unless defined$fh;my$subject=$self->get('Subject')|| '';$subject=": $subject" if length$subject;my$type=$self->get('Content-Type',0)|| '';my$size=$self->size;my$deleted=$self->label('deleted')? ', deleted' : '';my$text="$indent$type$subject ($size bytes$deleted)\n";ref$fh eq 'GLOB' ? (print$fh $text): $fh->print($text);my$body=$self->body;my@parts =$body->isNested ? ($body->nested): $body->isMultipart ? $body->parts : ();$_->printStructure($fh,$indent.'   ')for@parts;$buffer}1;
MAIL_MESSAGE_CONSTRUCT_TEXT

$fatpacked{"Mail/Message/Convert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT';
  package Mail::Message::Convert;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMC_fields}=$args->{fields}|| qr#^(Resent\-)?(To|From|Cc|Bcc|Subject|Date)\b#i;$self}sub selectedFields($) {my ($self,$head)=@_;$head->grepNames($self->{MMC_fields})}1;
MAIL_MESSAGE_CONVERT

$fatpacked{"Mail/Message/Convert/EmailSimple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_EMAILSIMPLE';
  package Mail::Message::Convert::EmailSimple;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Mail::Internet;use Mail::Header;use Mail::Message;use Mail::Message::Head::Complete;use Mail::Message::Body::Lines;use Email::Simple;use Carp;sub export($@) {my ($thing,$message)=(shift,shift);croak "Export message must be a Mail::Message, but is a ".ref($message)."." unless$message->isa('Mail::Message');Email::Simple->new($message->string)}sub from($@) {my ($thing,$email)=(shift,shift);croak "Converting from Email::Simple but got a ".ref($email).'.' unless$email->isa('Email::Simple');my$message=Mail::Message->read($email->as_string)}1;
MAIL_MESSAGE_CONVERT_EMAILSIMPLE

$fatpacked{"Mail/Message/Convert/Html.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_HTML';
  package Mail::Message::Convert::Html;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);my$produce=$args->{produce}|| 'HTML';$self->{MMCH_tail}=$produce eq 'HTML' ? '>' : $produce eq 'XHTML' ? ' />' : carp "Produce XHTML or HTML, not $produce.";$self}sub textToHtml(@) {my$self=shift;my@lines=@_;for (@lines){s/\&/&amp;/gs;s/\</&lt;/gs;s/\>/&gt;/gs;s/\"/&quot;/gs}wantarray ? @lines : join('',@lines)}sub fieldToHtml($;$) {my ($self,$field,$subject)=@_;'<strong>'.$self->textToHtml($field->wellformedName).': </strong>' .$self->fieldContentsToHtml($field,$subject)}sub headToHtmlTable($;$) {my ($self,$head)=(shift,shift);my$tp=@_ ? ' '.shift : '';my$subject;if($self->{MMHC_mailto_subject}){my$s=$head->get('subject');use Mail::Message::Construct;$subject=Mail::Message::Construct->replySubject($s)if defined$subject}my@lines="<table $tp>\n";for my$f ($self->selectedFields($head)){my$name_html=$self->textToHtml($f->wellformedName);my$cont_html=$self->fieldContentsToHtml($f,$subject);push@lines,qq(<tr><th valign="top" align="left">$name_html:</th>\n) ,qq(    <td valign="top">$cont_html</td></tr>\n)}push@lines,"</table>\n";wantarray ? @lines : join('',@lines)}sub headToHtmlHead($@) {my ($self,$head)=(shift,shift);my%meta;while(@_){my$k=shift;$meta{lc$k}=shift}my$title=delete$meta{title}|| $head->get('subject')|| '<no subject>';my@lines=("<head>\n" ,"<title>".$self->textToHtml($title)."</title>\n");my$author=delete$meta{author};unless(defined$author){my$from=$head->get('from');my@addr=defined$from ? $from->addresses : ();$author=@addr ? $addr[0]->format : undef}push@lines,'<meta name="Author" content="' .$self->textToHtml($author)."\"$self->{MMCH_tail}\n" if defined$author;for my$f (map {lc}keys%meta){next if$meta{$f}eq '';push@lines,'<meta name="'.ucfirst lc$self->textToHtml($f).'" content="'.$self->textToHtml($meta{$f})."\"$self->{MMCH_tail}\n"}for my$f ($self->selectedFields($head)){next if exists$meta{$f->name};push@lines,'<meta name="' .$self->textToHtml($f->wellformedName).'" content="' .$self->textToHtml($f->content)."\"$self->{MMCH_tail}\n"}push@lines,"</head>\n";wantarray ? @lines : join('',@lines)}my$atom=qr/[^()<>@,;:\\".\[\]\s[:cntrl:]]+/;my$email_address=qr/(($atom(?:\.$atom)*)\@($atom(?:\.$atom)+))/o;sub fieldContentsToHtml($;$) {my ($self,$field)=(shift,shift);my$subject=defined $_[0]? '?subject='.$self->textToHtml(shift): '';my ($body,$comment)=($self->textToHtml($field->body),$field->comment);$body =~ s#$email_address#<a href="mailto:$1$subject">$1</a>#gx if$field->name =~ m/^(resent-)?(to|from|cc|bcc|reply\-to)$/;$body .($comment ? '; '.$self->textToHtml($comment): '')}1;
MAIL_MESSAGE_CONVERT_HTML

$fatpacked{"Mail/Message/Convert/HtmlFormatPS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_HTMLFORMATPS';
  package Mail::Message::Convert::HtmlFormatPS;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Mail::Message::Body::String;use HTML::TreeBuilder;use HTML::FormatPS;sub init($) {my ($self,$args)=@_;my@formopts=map {($_=>delete$args->{$_})}grep m/^[A-Z]/,keys %$args;$self->SUPER::init($args);$self->{MMCH_formatter}=HTML::FormatPS->new(@formopts);$self}sub format($) {my ($self,$body)=@_;my$dec=$body->encode(transfer_encoding=>'none');my$tree=HTML::TreeBuilder->new_from_file($dec->file);(ref$body)->new (based_on=>$body ,mime_type=>'application/postscript' ,data=>[$self->{MMCH_formatter}->format($tree)])}1;
MAIL_MESSAGE_CONVERT_HTMLFORMATPS

$fatpacked{"Mail/Message/Convert/HtmlFormatText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_HTMLFORMATTEXT';
  package Mail::Message::Convert::HtmlFormatText;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Mail::Message::Body::String;use HTML::TreeBuilder;use HTML::FormatText;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMCH_formatter}=HTML::FormatText->new (leftmargin=>(defined$args->{leftmargin}? $args->{leftmargin}: 3),rightmargin=>(defined$args->{rightmargin}? $args->{rightmargin}: 72));$self}sub format($) {my ($self,$body)=@_;my$dec=$body->encode(transfer_encoding=>'none');my$tree=HTML::TreeBuilder->new_from_file($dec->file);(ref$body)->new (based_on=>$body ,mime_type=>'text/plain' ,charset=>'iso-8859-1' ,data=>[$self->{MMCH_formatter}->format($tree)])}1;
MAIL_MESSAGE_CONVERT_HTMLFORMATTEXT

$fatpacked{"Mail/Message/Convert/MailInternet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_MAILINTERNET';
  package Mail::Message::Convert::MailInternet;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Mail::Internet;use Mail::Header;use Mail::Message;use Mail::Message::Head::Complete;use Mail::Message::Body::Lines;use Carp;sub export($@) {my ($thing,$message)=(shift,shift);croak "Export message must be a Mail::Message, but is a ".ref($message)."." unless$message->isa('Mail::Message');my$mi_head=Mail::Header->new;my$head=$message->head;for my$field ($head->orderedFields){$mi_head->add($field->Name,scalar$field->foldedBody)}Mail::Internet->new (Header=>$mi_head ,Body=>[$message->body->lines ],@_)}my@pref_order=qw/From To Cc Subject Date In-Reply-To References Content-Type/;sub from($@) {my ($thing,$mi)=(shift,shift);croak "Converting from Mail::Internet but got a ".ref($mi).'.' unless$mi->isa('Mail::Internet');my$head=Mail::Message::Head::Complete->new;my$body=Mail::Message::Body::Lines->new(data=>[@{$mi->body}]);my$mi_head=$mi->head;my%tags=map {lc $_=>ucfirst $_}$mi_head->tags;my@tags;for (@pref_order){push@tags,$_ if delete$tags{lc $_}}push@tags,sort values%tags;for my$name (@tags){$head->add($name,$_)foreach$mi_head->get($name)}Mail::Message->new(head=>$head,body=>$body,@_)}1;
MAIL_MESSAGE_CONVERT_MAILINTERNET

$fatpacked{"Mail/Message/Convert/MimeEntity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_MIMEENTITY';
  package Mail::Message::Convert::MimeEntity;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use MIME::Entity;use MIME::Parser;use Mail::Message;sub export($$;$) {my ($self,$message,$parser)=@_;return ()unless defined$message;$self->log(ERROR=>"Export message must be a Mail::Message, but is a ".ref($message)."."),return unless$message->isa('Mail::Message');$parser ||=MIME::Parser->new;$parser->parse($message->file)}sub from($) {my ($self,$mime_ent)=@_;return ()unless defined$mime_ent;$self->log(ERROR=>'Converting from MIME::Entity but got a '.ref($mime_ent).'.'),return unless$mime_ent->isa('MIME::Entity');Mail::Message->read($mime_ent->as_string)}1;
MAIL_MESSAGE_CONVERT_MIMEENTITY

$fatpacked{"Mail/Message/Convert/TextAutoformat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_CONVERT_TEXTAUTOFORMAT';
  package Mail::Message::Convert::TextAutoformat;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Convert';use strict;use warnings;use Mail::Message::Body::String;use Text::Autoformat;sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMCA_options}=$args->{autoformat}|| {all=>1};$self}sub autoformatBody($) {my ($self,$body)=@_;ref($body)->new (based_on=>$body ,data=>autoformat($body->string,$self->{MMCA_options}))}1;
MAIL_MESSAGE_CONVERT_TEXTAUTOFORMAT

$fatpacked{"Mail/Message/Dummy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_DUMMY';
  package Mail::Message::Dummy;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Message';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;@$args{qw/modified trusted/ }=(0,1);$self->SUPER::init($args);$self->log(ERROR=>"Message-Id is required for a dummy.")unless exists$args->{messageId};$self}sub isDummy() {1}sub head() {shift->log(ERROR=>"You cannot take the head of a dummy message");()}sub body() {shift->log(ERROR=>"You cannot take the body of a dummy message");()}1;
MAIL_MESSAGE_DUMMY

$fatpacked{"Mail/Message/Field.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD';
  package Mail::Message::Field;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Carp;use Mail::Address;use Date::Format 'strftime';use IO::Handle;our%_structured;my$default_wrap_length=78;use overload qq("")=>sub {$_[0]->unfoldedBody},'0+'=>sub {$_[0]->toInt || 0},bool=>sub {1},cmp=>sub {$_[0]->unfoldedBody cmp "$_[1]"},'<=>'=>sub {$_[2]? $_[1]<=> $_[0]->toInt : $_[0]->toInt <=> $_[1]},fallback=>1;sub new(@) {my$class=shift;if($class eq __PACKAGE__){require Mail::Message::Field::Fast;return Mail::Message::Field::Fast->new(@_)}$class->SUPER::new(@_)}sub length {length shift->folded}BEGIN {%_structured=map {(lc($_)=>1)}qw/To Cc Bcc From Date Reply-To Sender Resent-Date Resent-From Resent-Sender Resent-To Return-Path List-Help List-Post List-Unsubscribe Mailing-List Received References Message-ID In-Reply-To Content-Type Content-Disposition Content-ID Delivered-To MIME-Version Precedence Status/}sub isStructured(;$) {my$name=ref $_[0]? shift->name : $_[1];exists$_structured{lc$name}}sub print(;$) {my$self=shift;my$fh=shift || select;$fh->print(scalar$self->folded)}sub toString(;$) {shift->string(@_)}sub string(;$) {my$self=shift;return$self->folded unless @_;my$wrap=shift || $default_wrap_length;my$name=$self->Name;my@lines=$self->fold($name,$self->unfoldedBody,$wrap);$lines[0]=$name .':' .$lines[0];wantarray ? @lines : join('',@lines)}sub toDisclose() {shift->name !~ m!^(?: (?:x-)?status
                        |   (?:resent-)?bcc
                        |   Content-Length
                        |   x-spam-
                        ) $!x}sub nrLines() {my@l=shift->foldedBody;scalar@l}*size=\&length;my%wf_lookup =qw/mime MIME ldap LDAP soap SOAP swe SWE bcc Bcc cc Cc id ID/;sub wellformedName(;$) {my$thing=shift;my$name=@_ ? shift : $thing->name;join '-',map {$wf_lookup{lc $_}|| (/[aeiouyAEIOUY]/ ? ucfirst lc : uc)}split /\-/,$name,-1}sub folded {shift->notImplemented}sub body() {my$self=shift;my$body=$self->unfoldedBody;return$body unless$self->isStructured;my ($first)=$body =~ m/^((?:"[^"]*"|'[^']*'|[^;])*)/;$first =~ s/\s+$//;$first}sub foldedBody {shift->notImplemented}sub unfoldedBody {shift->notImplemented}sub stripCFWS($) {my$thing=shift;my$string=@_ ? shift : $thing->foldedBody;my$r='';my$in_dquotes=0;my$open_paren=0;my@s=split m/([()"])/,$string;while(@s){my$s=shift@s;if(CORE::length($r)&& substr($r,-1)eq "\\"){$r .= $s}elsif($s eq '"'){$in_dquotes=not $in_dquotes;$r .= $s}elsif($s eq '(' &&!$in_dquotes){$open_paren++}elsif($s eq ')' &&!$in_dquotes){$open_paren--}elsif($open_paren){}else {$r .= $s}}for($r){s/\s+/ /gs;s/\s+$//;s/^\s+//}$r}sub comment(;$) {my$self=shift;return undef unless$self->isStructured;my$body=$self->unfoldedBody;if(@_){my$comment=shift;$body =~ s/\s*\;.*//;$body .= "; $comment" if defined$comment && CORE::length($comment);$self->unfoldedBody($body);return$comment}$body =~ s/.*?\;\s*// ? $body : ''}sub content() {shift->unfoldedBody}sub attribute($;$) {my ($self,$attr)=(shift,shift);my$body=$self->unfoldedBody;unless(@_){if($body =~ m/\b$attr\s*\=\s*
                        ( "( (?> [^\\"]+|\\. )* )"
                        | ([^";\s]*)
                        )/xi){(my$val=$+)=~ s/\\(.)/$1/g;return$val}return undef}my$value=shift;unless(defined$value){for($body){s/\b$attr\s*=\s*"(?>[^\\"]|\\.)*"//i or s/\b$attr\s*=\s*[;\s]*//i}$self->unfoldedBody($body);return undef}(my$quoted=$value)=~ s/(["\\])/\\$1/g;for($body){s/\b$attr\s*=\s*"(?>[^\\"]|\\.){0,1000}"/$attr="$quoted"/i or s/\b$attr\s*=\s*[^;\s]*/$attr="$quoted"/i or do {$_ .= qq(; $attr="$quoted")}}$self->unfoldedBody($body);$value}sub attributes() {my$self=shift;my$body=$self->unfoldedBody;my@attrs;while($body =~ m/\b(\w+)\s*\=\s*
                         ( "( (?: [^"]|\\" )* )"
                         | '( (?: [^']|\\' )* )'
                         | ([^;\s]*)
                         )
                      /xig){push@attrs,$1=>$+}@attrs}sub toInt() {my$self=shift;return $1 if$self->body =~ m/^\s*(\d+)\s*$/;$self->log(WARNING=>"Field content is not numerical: ".$self->toString);return undef}my@weekday=qw/Sun Mon Tue Wed Thu Fri Sat Sun/;my@month=qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;sub toDate(@) {my$class=shift;my@time=@_==0 ? localtime(): @_==1 ? localtime(shift): @_;my$format="$weekday[$time[6]], %d $month[$time[4]] %Y %H:%M:%S %z";my$time=strftime$format,@time;$time =~ s/ (\%z|[A-Za-z ]+)$/_tz_offset($1)/e;$time}sub _tz_offset($) {my$zone=shift;require Time::Zone;my$diff=$zone eq '%z' ? Time::Zone::tz_local_offset(): Time::Zone::tz_offset($zone);my$minutes=int((abs($diff)+0.01)/ 60);my$hours=int(($minutes+0.01)/ 60);$minutes -= $hours * 60;sprintf(($diff < 0 ? " -%02d%02d" : " +%02d%02d"),$hours,$minutes)}sub addresses() {Mail::Address->parse(shift->unfoldedBody)}sub study() {my$self=shift;require Mail::Message::Field::Full;Mail::Message::Field::Full->new(scalar$self->folded)}sub dateToTimestamp($) {my$string=$_[0]->stripCFWS($_[1]);$string =~ s/(\d\d)\s*\:\s*(\d\d)\s*\:\s*(\d\d)/$1:$2:$3/;require Date::Parse;Date::Parse::str2time($string,'GMT')}sub consume($;$) {my$self=shift;my ($name,$body)=defined $_[1]? @_ : split(/\s*\:\s*/,(shift),2);Mail::Reporter->log(WARNING=>"Illegal character in field name $name")if$name =~ m/[^\041-\071\073-\176]/;if(ref$body){my$flat=$self->stringifyData($body)or return ();$body=$self->fold($name,$flat)}elsif($body !~ s/\n+$/\n/g){$body=$self->fold($name,$body)}else {$body =~ s/[\012\015]+/\n/g;$body =~ s/^[ \t]*/ /;$self->log(NOTICE=>"Empty field: $name")if$body eq " \n"}($name,$body)}sub stringifyData($) {my ($self,$arg)=(shift,shift);my@addr;for my$obj (ref$arg eq 'ARRAY' ? @$arg : ($arg)){next unless defined$obj;if(!ref$obj){push@addr,$obj;next}if($obj->isa('Mail::Address')){push@addr,$obj->format;next}if($obj->isa('Mail::Identity')|| $obj->isa('User::Identity')){require Mail::Message::Field::Address;push@addr,Mail::Message::Field::Address->coerce($obj)->string}elsif($obj->isa('User::Identity::Collection::Emails')){my@roles=$obj->roles or next;require Mail::Message::Field::AddrGroup;my$group=Mail::Message::Field::AddrGroup->coerce($obj);push@addr,$group->string if$group}else {push@addr,"$obj"}}@addr ? join(', ',@addr): undef}sub setWrapLength(;$) {my$self=shift;$self->foldedBody(scalar$self->fold($self->Name,$self->unfoldedBody,@_))if @_;$self}sub defaultWrapLength(;$) {my$self=shift;@_ ? ($default_wrap_length=shift): $default_wrap_length}sub fold($$;$) {my$thing=shift;my$name=shift;my$line=shift;my$wrap=shift || $default_wrap_length;defined$line or $line='';$line =~ s/\n\s/ /gms;return " \n" unless CORE::length($line);my@folded;while(1){my$max=$wrap - (@folded ? 1 : CORE::length($name)+ 2);my$min=$max >> 2;last if CORE::length($line)< $max;$line =~ s/^ ( .{$min,$max}   # $max to 30 chars
                          [;,]            # followed at a ; or ,
                         )[ \t]           # and then a WSP
                      //x || $line =~ s/^ ( .{$min,$max} ) # $max to 30 chars
                         [ \t]            # followed by a WSP
                      //x || $line =~ s/^ ( .{$max,}? )    # longer, but minimal chars
                         [ \t]            # followed by a WSP
                      //x || $line =~ s/^ (.*) //x;push@folded," $1\n"}push@folded," $line\n" if CORE::length($line);wantarray ? @folded : join('',@folded)}sub unfold($) {my$string=$_[1];for($string){s/\r?\n\s?/ /gs;s/^ +//;s/ +$//}$string}1;
MAIL_MESSAGE_FIELD

$fatpacked{"Mail/Message/Field/AddrGroup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_ADDRGROUP';
  package Mail::Message::Field::AddrGroup;use vars '$VERSION';$VERSION='3.008';use base 'User::Identity::Collection::Emails';use strict;use warnings;use overload '""'=>'string';sub string() {my$self=shift;my$name=$self->name;my@addr=sort map $_->string,$self->addresses;local $"=', ';length$name ? "$name: @addr;" : @addr ? "@addr" : ''}sub coerce($@) {my ($class,$addr,%args)=@_;return ()unless defined$addr;if(ref$addr){return$addr if$addr->isa($class);return bless$addr,$class if$addr->isa('User::Identity::Collection::Emails')}$class->log(ERROR=>"Cannot coerce a ".(ref($addr)|'string')." into a $class");()}sub addAddress(@) {my$self=shift;my$addr =@_ > 1 ? Mail::Message::Field::Address->new(@_):!$_[0]? return (): Mail::Message::Field::Address->coerce(shift);$self->addRole($addr);$addr}sub addresses() {shift->roles}1;
MAIL_MESSAGE_FIELD_ADDRGROUP

$fatpacked{"Mail/Message/Field/Address.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_ADDRESS';
  package Mail::Message::Field::Address;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Identity';use strict;use warnings;use Mail::Message::Field::Addresses;use Mail::Message::Field::Full;my$format='Mail::Message::Field::Full';use overload '""'=>'string' ,bool=>sub {1},cmp=>sub {lc($_[0]->address)eq lc($_[1])};sub coerce($@) {my ($class,$addr,%args)=@_;return ()unless defined$addr;ref$addr or return$class->parse($addr);$addr->isa($class)and return$addr;my$from=$class->from($addr,%args);Mail::Reporter->log(ERROR=>"Cannot coerce a ".ref($addr)." into a $class"),return ()unless defined$from;bless$from,$class}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMFA_encoding}=delete$args->{encoding};$self}sub parse($) {my$self=shift;my$parsed=Mail::Message::Field::Addresses->new('To'=>shift);defined$parsed ? ($parsed->addresses)[0]: ()}sub encoding() {shift->{MMFA_encoding}}sub string() {my$self=shift;my@opts=(charset=>$self->charset,encoding=>$self->encoding);my@parts;my$name=$self->phrase;push@parts,$format->createPhrase($name,@opts)if defined$name;my$address=$self->address;push@parts,@parts ? '<'.$address.'>' : $address;my$comment=$self->comment;push@parts,$format->createComment($comment,@opts)if defined$comment;join ' ',@parts}1;
MAIL_MESSAGE_FIELD_ADDRESS

$fatpacked{"Mail/Message/Field/Addresses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_ADDRESSES';
  package Mail::Message::Field::Addresses;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Structured';use strict;use warnings;use Mail::Message::Field::AddrGroup;use Mail::Message::Field::Address;use List::Util 'first';my$address_list={groups=>1,multi=>1};my$mailbox_list={multi=>1};my$mailbox={};my%accepted=(from=>$mailbox_list ,sender=>$mailbox);sub init($) {my ($self,$args)=@_;$self->{MMFF_groups}=[];(my$def=lc$args->{name})=~ s/^resent\-//;$self->{MMFF_defaults}=$accepted{$def}|| $address_list;my ($body,@body);if($body=$args->{body}){@body=ref$body eq 'ARRAY' ? @$body : ($body);return ()unless@body}if(@body > 1 || ref$body[0]){$self->addAddress($_)foreach@body;delete$args->{body}}$self->SUPER::init($args)or return;$self}sub addAddress(@) {my$self=shift;my$email=@_ && ref $_[0]? shift : undef;my%args=@_;my$group=delete$args{group}|| '';$email=Mail::Message::Field::Address->new(%args)unless defined$email;my$set=$self->group($group)|| $self->addGroup(name=>$group);$set->addAddress($email);$email}sub addGroup(@) {my$self=shift;my$group=@_==1 ? shift : Mail::Message::Field::AddrGroup->new(@_);push @{$self->{MMFF_groups}},$group;$group}sub group($) {my ($self,$name)=@_;$name='' unless defined$name;first {lc($_->name)eq lc($name)}$self->groups}sub groups() {@{shift->{MMFF_groups}}}sub groupNames() {map {$_->name}shift->groups}sub addresses() {map {$_->addresses}shift->groups}sub addAttribute($;@) {my$self=shift;$self->log(ERROR=>'No attributes for address fields.');$self}sub parse($) {my ($self,$string)=@_;my ($group,$email)=('',undef);$string =~ s/\s+/ /gs;while(1){(my$comment,$string)=$self->consumeComment($string);if($string =~ s/^\s*\;//s){$group='';next}if($string =~ s/^\s*\,//s){next}(my$email,$string)=$self->consumeAddress($string);if(defined$email){($comment,$string)=$self->consumeComment($string);$email->comment($comment)if defined$comment}else {my$real_phrase=$string =~ m/^\s*\"/;(my$phrase,$string)=$self->consumePhrase($string);if(defined$phrase){($comment,$string)=$self->consumeComment($string);if($string =~ s/^\s*\://s){$group=$phrase;$self->addGroup(name=>$group)unless$self->group($group);next}}my$angle;if($string =~ s/^\s*\<([^>]*)\>//s){$angle=$1}elsif($real_phrase){$self->log(ERROR=>"Ignore unrelated phrase `$1'")if$string =~ s/^\s*\"(.*?)\r?\n//;next}elsif(defined$phrase){($angle=$phrase)=~ s/\s+/./g;undef$phrase}($comment,$string)=$self->consumeComment($string);return 1 unless defined$angle;$angle =~ s/^\@.*?\://;($email,$angle)=$self->consumeAddress($angle ,phrase=>$phrase,comment=>$comment)}$self->addAddress($email,group=>$group)if defined$email;return 1 if$string =~ m/^\s*$/s}$self->log(WARNING=>'Illegal part in address field '.$self->Name.": $string\n");0}sub produceBody() {my@groups=sort {$a->name cmp $b->name}shift->groups;@groups or return '';@groups > 1 or return$groups[0]->string;my$plain =$groups[0]->name eq '' && $groups[0]->addresses ? (shift@groups)->string.',' : '';join ' ',$plain,map({$_->string}@groups)}sub consumeAddress($@) {my ($self,$string,@options)=@_;my ($local,$shorter,$loccomment)=$self->consumeDotAtom($string);$local =~ s/\s//g if defined$local;return (undef,$string)unless defined$local && $shorter =~ s/^\s*\@//;(my$domain,$shorter,my$domcomment)=$self->consumeDomain($shorter);return (undef,$string)unless defined$domain;my$email=Mail::Message::Field::Address ->new(username=>$local,domain=>$domain,@options);($email,$shorter)}sub consumeDomain($) {my ($self,$string)=@_;return ($self->stripCFWS($1),$string)if$string =~ s/\s*(\[(?:[^[]\\]*|\\.)*\])//;my ($atom,$rest,$comment)=$self->consumeDotAtom($string);$atom =~ s/\s//g if defined$atom;($atom,$rest,$comment)}1;
MAIL_MESSAGE_FIELD_ADDRESSES

$fatpacked{"Mail/Message/Field/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_ATTRIBUTE';
  package Mail::Message::Field::Attribute;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Encode ();use Carp;use Carp 'cluck';use overload '""'=>sub {shift->value},cmp=>sub {my ($self,$other)=@_;UNIVERSAL::isa($other,'Mail::Message::Field')? (lc($_[0])->name cmp lc($_[1]->name)|| $_[0]->value cmp $_[1]->value): $_[0]->value cmp $_[1]},fallback=>1;sub new($$@) {my ($class,$attr)=(shift,shift);my$value=@_ % 2==1 ? shift : undef;$class->SUPER::new(attr=>$attr,value=>$value,@_)}sub init($$) {my ($self,$args)=@_;$self->SUPER::init($args);my ($attr,$value,$cont)=@$args{qw/attr value use_continuations/ };my$name=($attr =~ m/^(.*?)(?:\*\d+)?\*?\s*\=\s*/ ? $1 : $attr);$self->log(WARNING=>"Illegal character in parameter name '$name'.")if$name !~ m/^[!#-'*+\-.0-9A-Z^-~]+$/;$self->{MMFF_name}=$name;$self->{MMFF_usecont}=defined$cont ? $cont : 1;$self->{MMFF_charset}=$args->{charset}if defined$args->{charset};$self->{MMFF_language}=$args->{language}if defined$args->{language};$self->value(defined$value ? "$value" : '');$self->addComponent($attr)if$attr ne $name;$self}sub name() {shift->{MMFF_name}}sub value(;$) {my$self=shift;if(@_){delete$self->{MMFF_cont};return$self->{MMFF_value}=shift}exists$self->{MMFF_value}? $self->{MMFF_value}: $self->decode}sub addComponent($) {my ($self,$component)=@_;delete$self->{MMFF_value};my ($name,$value)=split /\=/,$component,2;if(substr($name,-1)eq '*' && $value =~ m/^([^']*)\'([^']*)\'/){$self->{MMFF_charset}=length $1 ? $1 : undef;$self->{MMFF_language}=length $2 ? $2 : undef}if($name =~ m/\*([0-9]+)\*?$/){$self->{MMFF_cont}[$1]=$component}else {$self->{MMFF_cont}=[$component ]}$component}sub charset() {shift->{MMFF_charset}}sub language() {shift->{MMFF_language}}sub string() {my$self=shift;my$cont=$self->{MMFF_cont}|| $self->encode;return @$cont if wantarray;return []unless @$cont;local $"="; ";"; @$cont"}sub encode() {my$self=shift;my$value=$self->{MMFF_value};my@lines;my ($pre,$encoded);my$charset=$self->{MMFF_charset}|| '';my$lang=$self->{MMFF_language}|| '';my$name=$self->{MMFF_name};my$cont=$self->{MMFF_usecont};if($charset || $lang){$pre="$name*0*=$charset'$lang'";$value=Encode::encode($charset,$value,0);$encoded=1}elsif(grep m/[^\x20-\x7E]/,$value){$pre="$name*0*=''";$encoded=1}else {$pre="$name*0=";$value =~ s/"/\\"/g;$encoded=0}if($encoded){my@c=split //,$value;while(@c){my$c=shift@c;$c='%'.sprintf "%02X",ord$c unless$c =~ m/[a-zA-Z0-9]/;if($cont && length($pre)+ length($c)> 76){push@lines,$pre;$pre=$name .'*' .@lines .'*=' .$c}else {$pre .= $c}}push@lines,$pre}elsif($cont){while(1){push@lines,$pre.'"'.substr($value,0,75-length($pre),'').'"';last unless length$value;$pre=$name .'*' .@lines .'='}}else {push@lines,$pre .$value}$lines[0]=~ s/\*0// if@lines==1;$self->{MMFF_cont}=\@lines}sub decode() {my$self=shift;my$value='';for my$cont (@{$self->{MMFF_cont}}){unless(defined$cont){$value .= "[continuation missing]";next}(my$name,local $_)=split /\=/,$cont,2;if(substr($name,-1)eq '*'){s/^[^']*\'[^']*\'//;s/\%([a-fA-F0-9]{2})/chr hex $1/ge}elsif(s/^\"(.*)\"$/$1/){s/\\\"/"/g}elsif(s/^\'(.*)\'$/$1/){s/\\\'/'/g}$value .= $_}my$charset=$self->{MMFF_charset};$value=Encode::decode($charset,$value,0)if$charset;$self->{MMFF_value}=$value}sub mergeComponent($) {my ($self,$comp)=@_;my$cont=$self->{MMFF_cont}or croak "ERROR: Too late to merge: value already changed.";defined $_ && $self->addComponent($_)foreach @{$comp->{MMFF_cont}};$self}1;
MAIL_MESSAGE_FIELD_ATTRIBUTE

$fatpacked{"Mail/Message/Field/AuthResults.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_AUTHRESULTS';
  package Mail::Message::Field::AuthResults;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Structured';use warnings;use strict;use URI;sub init($) {my ($self,$args)=@_;$self->{MMFA_server}=delete$args->{server};$self->{MMFA_version}=delete$args->{version};$self->{MMFA_results}=[];$self->addResult($_)for @{delete$args->{results}|| []};$self->SUPER::init($args)}sub parse($) {my ($self,$string)=@_;$string =~ s/\r?\n/ /g;(undef,$string)=$self->consumeComment($string);$self->{MMFA_server}=$string =~ s/^\s*([.\w-]*\w)// ? $1 : 'unknown';(undef,$string)=$self->consumeComment($string);$self->{MMFA_version}=$string =~ s/^\s*([0-9]+)// ? $1 : 1;(undef,$string)=$self->consumeComment($string);$string =~ s/^.*?\;/;/;my@results;while($string =~ s/^\s*\;//){(undef,$string)=$self->consumeComment($string);if($string =~ s/^\s*none//){(undef,$string)=$self->consumeComment($string);next}my%result;push@results,\%result;$string =~ s/^\s*([\w-]*\w)// or next;$result{method}=$1;(undef,$string)=$self->consumeComment($string);if($string =~ s!^\s*/!!){(undef,$string)=$self->consumeComment($string);$result{method_version}=$1 if$string =~ s/^\s*([0-9]+)//}(undef,$string)=$self->consumeComment($string);if($string =~ s/^\s*\=//){(undef,$string)=$self->consumeComment($string);$result{result}=$1 if$string =~ s/^\s*(\w+)//}(my$comment,$string)=$self->consumeComment($string);if($comment){$result{comment}=$comment;(undef,$string)=$self->consumeComment($string)}if($string =~ s/\s*reason//){(undef,$string)=$self->consumeComment($string);if($string =~ s/\s*\=//){(undef,$string)=$self->consumeComment($string);$result{reason}=$1 if$string =~ s/^\"([^"]*)\"// || $string =~ s/^\'([^']*)\'// || $string =~ s/^(\w+)//}}while($string =~ /\S/){(undef,$string)=$self->consumeComment($string);last if$string =~ /^\s*\;/;my$ptype=$string =~ s/^\s*([\w-]+)// ? $1 : last;(undef,$string)=$self->consumeComment($string);my ($property,$value);if($string =~ s/^\s*\.//){(undef,$string)=$self->consumeComment($string);$property=$string =~ s/^\s*([\w-]+)// ? $1 : last;(undef,$string)=$self->consumeComment($string);if($string =~ s/^\s*\=//){(undef,$string)=$self->consumeComment($string);$string =~ s/^\s+//;$string =~ s/^\"([^"]*)\"// || $string =~ s/^\'([^']*)\'// || $string =~ s/^([\w@.-]+)// or last;$value=$1}}if(defined$value){$result{"$ptype.$property"}=$value}else {$string =~ s/^.*?\;/;/g}}}$self->addResult($_)for@results;$self}sub produceBody() {my$self=shift;my$source=$self->server;my$version=$self->version;$source .= " $version" if$version!=1;my@results;for my$r ($self->results){my$method=$r->{method};$method .= "/$r->{method_version}" if$r->{method_version}!=1;my$result="$method=$r->{result}";$result .= ' ' .$self->createComment($r->{comment})if defined$r->{comment};if(my$reason=$r->{reason}){$reason =~ s/"/\\"/g;$result .= qq{ reason="$reason"}}for my$prop (sort keys %$r){index($prop,'.')> -1 or next;my$value=$r->{$prop};$value =~ s/"/\\"/g;$result .= qq{ $prop="$value"}}push@results,$result}push@results,'none' unless@results;join '; ',$source,@results}sub addAttribute($;@) {my$self=shift;$self->log(ERROR=>'No attributes for Authentication-Results.');$self}sub server() {shift->{MMFA_server}}sub version() {shift->{MMFA_version}}sub results() {@{shift->{MMFA_results}}}sub addResult($) {my$self=shift;my$r=@_==1 ? shift : {@_};$r->{method}&& $r->{result}or return ();$r->{method_version}||=1;push @{$self->{MMFA_results}},$r;delete$self->{MMFF_body};$r}1;
MAIL_MESSAGE_FIELD_AUTHRESULTS

$fatpacked{"Mail/Message/Field/DKIM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_DKIM';
  package Mail::Message::Field::DKIM;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Structured';use warnings;use strict;use URI;sub init($) {my ($self,$args)=@_;$self->{MMFD_tags}={v=>1,a=>'rsa-sha256' };$self->SUPER::init($args)}sub parse($) {my ($self,$string)=@_;my$tags=$self->{MMFD_tags};for (split /\;/,$string){m/^\s*([a-z][a-z0-9_]*)\s*\=\s*([\s\x21-\x7E]+?)\s*$/is or next;$self->addTag($1,$2)}(undef,$string)=$self->consumeComment($string);$self}sub produceBody() {my$self=shift}sub addAttribute($;@) {my$self=shift;$self->log(ERROR=>'No attributes for DKIM headers.');$self}sub addTag($$) {my ($self,$name)=(shift,lc shift);$self->{MMFD_tags}{$name}=join ' ',@_;$self}sub tag($) {$_[0]->{MMFD_tags}{lc $_[1]}}sub tagAlgorithm() {shift->tag('a')}sub tagSignData() {shift->tag('b')}sub tagSignature() {shift->tag('bh')}sub tagC14N() {shift->tag('c')}sub tagDomain() {shift->tag('d')}sub tagSignedHeaders() {shift->tag('h')}sub tagAgentID() {shift->tag('i')}sub tagBodyLength(){shift->tag('l')}sub tagQueryMethods() {shift->tag('q')}sub tagSelector() {shift->tag('s')}sub tagTimestamp() {shift->tag('t')}sub tagExpires() {shift->tag('x')}sub tagVersion() {shift->tag('v')}sub tagExtract() {shift->tag('z')}1;
MAIL_MESSAGE_FIELD_DKIM

$fatpacked{"Mail/Message/Field/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_DATE';
  package Mail::Message::Field::Date;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Structured';use warnings;use strict;use POSIX qw/mktime tzset/;my$dayname=qr/Mon|Tue|Wed|Thu|Fri|Sat|Sun/;my@months=qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;my%monthnr;{my$i;$monthnr{$_}=++$i for@months}my%tz=qw/EDT -0400 EST -0500 CDT -0500 CST -0600 MDT -0600 MST -0700 PDT -0700 PST -0800 UT +0000 GMT +0000/;sub parse($) {my ($self,$string)=@_;my ($dn,$d,$mon,$y,$h,$min,$s,$z)=$string =~ m/ ^ \s*
             (?: ($dayname) \s* \, \s* )?
             ( 0?[1-9] | [12][0-9] | 3[01] ) \s*    # day
             \s+ ( [A-Z][a-z][a-z]|[0-9][0-9] ) \s+ # month
             ( (?: 19 | 20 | ) [0-9][0-9] ) \s+     # year
                    ( [0-1]?[0-9] | 2[0-3] ) \s*    # hour
                 [:.] ( [0-5][0-9] ) \s*            # minute
             (?: [:.] ( [0-5][0-9] ) )? \s+         # second
             ( [+-][0-9]{4} | [A-Z]+ )?             # zone
             \s* /x or return undef;defined$dn or $dn='';$dn =~ s/\s+//g;$mon=$months[$mon-1]if$mon =~ /[0-9]+/;$y += 2000 if$y < 50;$y += 1900 if$y < 100;$z ||='-0000';$z=$tz{$z}|| '-0000' if$z =~ m/[A-Z]/;$self->{MMFD_date}=sprintf "%s%s%02d %s %04d %02d:%02d:%02d %s" ,$dn,(length$dn ? ', ' : ''),$d,$mon,$y,$h,$min,$s,$z;$self}sub produceBody() {shift->{MMFD_date}}sub date() {shift->{MMFD_date}}sub addAttribute($;@) {my$self=shift;$self->log(ERROR=>'No attributes for date fields.');$self}sub time() {my$date=shift->{MMFD_date};my ($d,$mon,$y,$h,$min,$s,$z)=$date =~ m/^ (?:\w\w\w\,\s+)? (\d\d)\s+(\w+)\s+(\d\d\d\d)
                       \s+ (\d\d)\:(\d\d)\:(\d\d) \s+ ([+-]\d\d\d\d)? \s*$ /x;my$oldtz=$ENV{TZ};$ENV{TZ}='UTC';tzset;my$timestamp=mktime$s,$min,$h,$d,$monthnr{$mon}-1,$y-1900;if(defined$oldtz){$ENV{TZ}=$oldtz}else {delete$ENV{TZ}}tzset;$timestamp += ($1 eq '-' ? 1 : -1)* ($2*3600 + $3*60)if$z =~ m/^([+-])(\d\d)(\d\d)$/;$timestamp}1;
MAIL_MESSAGE_FIELD_DATE

$fatpacked{"Mail/Message/Field/Fast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_FAST';
  package Mail::Message::Field::Fast;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field';use strict;use warnings;sub new($;$@) {my$class=shift;my ($name,$body)=$class->consume(@_==1 ? (shift): (shift,shift));return ()unless defined$body;my$self=bless [$name,$body],$class;$self->comment(shift)if @_==1;$self->attribute(shift,shift)while @_ > 1;$self}sub clone() {my$self=shift;bless [@$self ],ref$self}sub length() {my$self=shift;length($self->[0])+ 1 + length($self->[1])}sub name() {lc shift->[0]}sub Name() {shift->[0]}sub folded() {my$self=shift;return$self->[0].':'.$self->[1]unless wantarray;my@lines=$self->foldedBody;my$first=$self->[0].':'.shift@lines;($first,@lines)}sub unfoldedBody($;@) {my$self=shift;$self->[1]=$self->fold($self->[0],@_)if @_;$self->unfold($self->[1])}sub foldedBody($) {my ($self,$body)=@_;if(@_==2){$self->[1]=$body}else {$body=$self->[1]}wantarray ? (split m/^/,$body): $body}sub print(;$) {my$self=shift;my$fh=shift || select;if(ref$fh eq 'GLOB'){print$fh $self->[0].':'.$self->[1]}else {$fh->print($self->[0].':'.$self->[1])}$self}1;
MAIL_MESSAGE_FIELD_FAST

$fatpacked{"Mail/Message/Field/Flex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_FLEX';
  package Mail::Message::Field::Flex;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field';use strict;use warnings;use Carp;sub new($;$$@) {my$class=shift;my$args=@_ <= 2 ||!ref $_[-1]? {}: ref $_[-1]eq 'ARRAY' ? {@{pop @_}}: pop @_;my ($name,$body)=$class->consume(@_==1 ? (shift): (shift,shift));return ()unless defined$body;my$attr=$args->{attributes};$attr=[%$attr ]if defined$attr && ref$attr eq 'HASH';push @$attr,@_;$class->SUPER::new(%$args,name=>$name,body=>$body,attributes=>$attr)}sub init($) {my ($self,$args)=@_;@$self{qw/MMFF_name MMFF_body/ }=@$args{qw/name body/ };$self->comment($args->{comment})if exists$args->{comment};my$attr=$args->{attributes};$self->attribute(shift @$attr,shift @$attr)while @$attr;$self}sub clone() {my$self=shift;(ref$self)->new($self->Name,$self->body)}sub length() {my$self=shift;length($self->{MMFF_name})+ 1 + length($self->{MMFF_body})}sub name() {lc shift->{MMFF_name}}sub Name() {shift->{MMFF_name}}sub folded(;$) {my$self=shift;return$self->{MMFF_name}.':'.$self->{MMFF_body}unless wantarray;my@lines=$self->foldedBody;my$first=$self->{MMFF_name}.':'.shift@lines;($first,@lines)}sub unfoldedBody($;@) {my$self=shift;$self->{MMFF_body}=$self->fold($self->{MMFF_name},@_)if @_;$self->unfold($self->{MMFF_body})}sub foldedBody($) {my ($self,$body)=@_;if(@_==2){$self->{MMFF_body}=$body}else {$body=$self->{MMFF_body}}wantarray ? (split /^/,$body): $body}1;
MAIL_MESSAGE_FIELD_FLEX

$fatpacked{"Mail/Message/Field/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_FULL';
  package Mail::Message::Field::Full;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field';use strict;use warnings;use utf8;use Encode ();use MIME::QuotedPrint ();use Storable 'dclone';use Mail::Message::Field::Addresses;use Mail::Message::Field::AuthResults;use Mail::Message::Field::Date;use Mail::Message::Field::DKIM;use Mail::Message::Field::Structured;use Mail::Message::Field::Unstructured;use Mail::Message::Field::URIs;my$atext=q[a-zA-Z0-9!#\$%&'*+\-\/=?^_`{|}~];my$atext_ill=q/\[\]/;use overload '""'=>sub {shift->decodedBody};my%implementation;BEGIN {$implementation{$_}='Addresses' for qw/from to sender cc bcc reply-to envelope-to resent-from resent-to resent-cc resent-bcc resent-reply-to resent-sender x-beenthere errors-to mail-follow-up x-loop delivered-to original-sender x-original-sender/;$implementation{$_}='URIs' for qw/list-help list-post list-subscribe list-unsubscribe list-archive list-owner/;$implementation{$_}='Structured' for qw/content-disposition content-type content-id/;$implementation{$_}='Date' for qw/date resent-date/;$implementation{$_}='AuthResults' for qw/authentication-results/;$implementation{$_}='DKIM' for qw/dkim-signature/}sub new($;$$@) {my$class=shift;my$name=shift;my$body=@_ % 2 ? shift : undef;my%args=@_;$body=delete$args{body}if defined$args{body};unless(defined$body){(my$n,$body)=split /\s*\:\s*/s,$name,2;$name=$n if defined$body}return$class->SUPER::new(%args,name=>$name,body=>$body)if$class ne __PACKAGE__;my$myclass='Mail::Message::Field::' .($implementation{lc$name}|| 'Unstructured');$myclass->SUPER::new(%args,name=>$name,body=>$body)}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMFF_name}=$args->{name};my$body=$args->{body};if(!defined$body ||!length$body || ref$body){}elsif(index($body,"\n")>= 0){$self->foldedBody($body)}else {$self->unfoldedBody($body)}$self}sub clone() {dclone(shift)}sub name() {lc shift->{MMFF_name}}sub Name() {shift->{MMFF_name}}sub folded() {my$self=shift;return$self->{MMFF_name}.':'.$self->foldedBody unless wantarray;my@lines=$self->foldedBody;my$first=$self->{MMFF_name}.':'.shift@lines;($first,@lines)}sub unfoldedBody($;$) {my ($self,$body)=(shift,shift);if(defined$body){$self->foldedBody(scalar$self->fold($self->{MMFF_name},$body));return$body}$body=$self->foldedBody;$body =~ s/^ //;$body =~ s/\r?\n\s?/ /g;$body =~ s/ +$//;$body}sub foldedBody($) {my ($self,$body)=@_;if(@_==2){$self->parse($body);$body =~ s/^\s*/ /m;$self->{MMFF_body}=$body}elsif(defined($body=$self->{MMFF_body})){}else {$self->{MMFF_body}=$body =$self->fold($self->{MMFF_name},$self->produceBody)}wantarray ? (split /^/,$body): $body}sub from($@) {my ($class,$field)=(shift,shift);defined$field ? $class->new($field->Name,$field->foldedBody,@_): ()}sub decodedBody() {my$self=shift;$self->decode($self->unfoldedBody,@_)}sub createComment($@) {my ($thing,$comment)=(shift,shift);$comment=$thing->encode($comment,@_)if @_;local $_=$comment;s#\\[()]#xx#g;s#[^()]#x#g;while(s#\(([^()]*)\)#x$1x#){}substr($comment,CORE::length($_),0,'\\')while s#[()][^()]*$##;$comment =~ s#\\+$##;"($comment)"}sub createPhrase($) {my$self=shift;local $_=shift;$_=$self->encode($_,@_)if @_;if(m/[^$atext]/){s#\\#\\\\#g;s#"#\\"#g;$_=qq["$_"]}$_}sub beautify() {shift}sub _mime_word($$) {"$_[0]$_[1]?="}sub _encode_b($) {MIME::Base64::encode_base64(shift,'')}sub _encode_q($) {my$chunk=shift;$chunk =~ s#([\x00-\x1F=\x7F-\xFF])#sprintf "=%02X", ord $1#ge;$chunk =~ s#([_\?])#sprintf "=%02X", ord $1#ge;$chunk =~ s/ /_/g;$chunk}sub encode($@) {my ($self,$utf8,%args)=@_;my ($charset,$lang,$encoding);if($charset=$args{charset}){$self->log(WARNING=>"Illegal character in charset '$charset'")if$charset =~ m/[\x00-\ ()<>@,;:"\/[\]?.=\\]/}else {$charset='us-ascii'}if($lang=$args{language}){$self->log(WARNING=>"Illegal character in language '$lang'")if$lang =~ m/[\x00-\ ()<>@,;:"\/[\]?.=\\]/}if($encoding=$args{encoding}){unless($encoding =~ m/^[bBqQ]$/){$self->log(WARNING=>"Illegal encoding '$encoding', used 'q'");$encoding='q'}}else {$encoding='q'}my$name=$args{name};my$lname=defined$name ? length($name)+1 : 0;return$utf8 if lc($encoding)eq 'q' && $utf8 =~ m/\A[\p{IsASCII}]+\z/ms &&!$args{force};my$pre='=?'.$charset.($lang ? '*'.$lang : '').'?'.$encoding.'?';my@result;if(lc($encoding)eq 'q'){my$chunk='';my$llen=73 - length($pre)- $lname;while(length(my$chr=substr($utf8,0,1,''))){$chr=_encode_q Encode::encode($charset,$chr,0);if(bytes::length($chunk)+ bytes::length($chr)> $llen){push@result,_mime_word($pre,$chunk);$chunk='';$llen=73 - length$pre}$chunk .= $chr}push@result,_mime_word($pre,$chunk)if length($chunk)}else {my$chunk='';my$llen=int((73 - length($pre)- $lname)/ 4)* 3;while(length(my$chr=substr($utf8,0,1,''))){my$chr=Encode::encode($charset,$chr,0);if(bytes::length($chunk)+ bytes::length($chr)> $llen){push@result,_mime_word($pre,_encode_b($chunk));$chunk='';$llen=int((73 - length$pre)/ 4)* 3}$chunk .= $chr}push@result,_mime_word($pre,_encode_b($chunk))if length$chunk}join ' ',@result}sub _decoder($$$) {my ($charset,$encoding,$encoded)=@_;$charset =~ s/\*[^*]+$//;my$to_utf8=Encode::find_encoding($charset || 'us-ascii');$to_utf8 or return$encoded;my$decoded;if($encoding !~ /\S/){$decoded=$encoded}elsif(lc($encoding)eq 'q'){$encoded =~ s/_/ /g;$decoded=MIME::QuotedPrint::decode_qp($encoded)}elsif(lc($encoding)eq 'b'){require MIME::Base64;$decoded=MIME::Base64::decode_base64($encoded)}else {return$encoded}$to_utf8->decode($decoded,Encode::FB_DEFAULT)}sub decode($@) {my$thing=shift;my@encoded=split /(\=\?[^?\s]*\?[bqBQ]?\?[^?]*\?\=)/,shift;@encoded or return '';my%args=@_;my$is_text=defined$args{is_text}? $args{is_text}: 1;my@decoded=shift@encoded;while(@encoded){shift(@encoded)=~ /\=\?([^?\s]*)\?([^?\s]*)\?([^?]*)\?\=/;push@decoded,_decoder $1,$2,$3;@encoded or last;if($is_text && $encoded[0]!~ m/\S/){shift@encoded}else {push@decoded,shift@encoded}}join '',@decoded}sub parse($) {shift}sub consumePhrase($) {my ($thing,$string)=@_;my$phrase;if($string =~ s/^\s*\" ((?:[^"\r\n\\]*|\\.)*) (?:\"|\s*$)//x){($phrase=$1)=~ s/\\\"/"/g}elsif($string =~ s/^\s*([${atext}${atext_ill}\ \t.]+)//o){($phrase=$1)=~ s/\s+$//;CORE::length($phrase)or undef$phrase}defined$phrase ? ($thing->decode($phrase),$string): (undef,$string)}sub consumeComment($) {my ($thing,$string)=@_;return (undef,$string)unless$string =~ s/^\s*\(((?:[^)\\]+|\\.)*)\)//;my$comment=$1;while(1){(my$count=$comment)=~ s/\\./xx/g;last if$count =~ tr/(//==$count =~ tr/)//;return (undef,$_[1])unless$string =~ s/^((?:[^)\\]+|\\.)*)\)//;$comment .= ')'.$1}$comment =~ s/\\([()])/$1/g;($comment,$string)}sub consumeDotAtom($) {my ($self,$string)=@_;my ($atom,$comment);while(1){(my$c,$string)=$self->consumeComment($string);if(defined$c){$comment .= $c;next}last unless$string =~ s/^\s*([$atext]+(?:\.[$atext]+)*)//o;$atom .= $1}($atom,$string,$comment)}sub produceBody() {$_[0]->{MMFF_body}}1;
MAIL_MESSAGE_FIELD_FULL

$fatpacked{"Mail/Message/Field/Structured.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_STRUCTURED';
  package Mail::Message::Field::Structured;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Full';use strict;use warnings;use Mail::Message::Field::Attribute;use Storable 'dclone';sub init($) {my ($self,$args)=@_;$self->{MMFS_attrs}={};$self->{MMFS_datum}=$args->{datum};$self->SUPER::init($args);my$attr=$args->{attributes}|| [];$attr=[%$attr ]if ref$attr eq 'HASH';while(@$attr){my$name=shift @$attr;if(ref$name){$self->attribute($name)}else {$self->attribute($name,shift @$attr)}}$self}sub clone() {dclone(shift)}sub attribute($;$) {my ($self,$attr)=(shift,shift);my$name;if(ref$attr){$name=$attr->name}elsif(!@_){return$self->{MMFS_attrs}{lc$attr}}else {$name=$attr;$attr=Mail::Message::Field::Attribute->new($name,@_)}delete$self->{MMFF_body};$self->{MMFS_attrs}{$name}=$attr}sub attributes() {values %{shift->{MMFS_attrs}}}sub beautify() {delete shift->{MMFF_body}}sub attrPairs() {map +($_->name,$_->value),shift->attributes}sub parse($) {my ($self,$string)=@_;$string =~ s/\r?\n\s?/ /gs;$string =~ s/ +$//;my$datum='';while(length$string && substr($string,0,1)ne ';'){(undef,$string)=$self->consumeComment($string);$datum .= $1 if$string =~ s/^([^;(]+)//}$self->{MMFS_datum}=$datum;my$found='';while($string =~ m/\S/){my$len=length$string;if($string =~ s/^\s*\;\s*// && length$found){my ($name)=$found =~ m/^([^*]+)\*/;if($name && (my$cont=$self->attribute($name))){$cont->addComponent($found)}else {my$attr=Mail::Message::Field::Attribute->new($found);$self->attribute($attr)}$found=''}(undef,$string)=$self->consumeComment($string);$string =~ s/^\n//;(my$text,$string)=$self->consumePhrase($string);$found .= $text if defined$text;if(length($string)==$len){$string =~ s/^\s*\S//}}if(length$found){my ($name)=$found =~ m/^([^*]+)\*/;if($name && (my$cont=$self->attribute($name))){$cont->addComponent($found)}else {my$attr=Mail::Message::Field::Attribute->new($found);$self->attribute($attr)}}1}sub produceBody() {my$self=shift;my$attrs=$self->{MMFS_attrs};my$datum=$self->{MMFS_datum};join '; ' ,(defined$datum ? $datum : ''),map {$_->string}@{$attrs}{sort keys %$attrs}}sub datum(@) {my$self=shift;@_ or return$self->{MMFS_datum};delete$self->{MMFF_body};$self->{MMFS_datum}=shift}1;
MAIL_MESSAGE_FIELD_STRUCTURED

$fatpacked{"Mail/Message/Field/URIs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_URIS';
  package Mail::Message::Field::URIs;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Structured';use warnings;use strict;use URI;sub init($) {my ($self,$args)=@_;my ($body,@body);if($body=delete$args->{body}){@body=ref$body eq 'ARRAY' ? @$body : ($body);return ()unless@body}$self->{MMFU_uris}=[];if(@body > 1 || ref$body[0]){$self->addURI($_)foreach@body}elsif(defined$body){$body="<$body>\n" unless index($body,'<')>= 0;$args->{body}=$body}$self->SUPER::init($args)}sub parse($) {my ($self,$string)=@_;my@raw=$string =~ m/\<([^>]+)\>/g;$self->addURI($_)foreach@raw;$self}sub produceBody() {my@uris=sort map {$_->as_string}shift->URIs;local $"='>, <';@uris ? "<@uris>" : undef}sub addURI(@) {my$self=shift;my$uri=ref $_[0]? shift : URI->new(@_);push @{$self->{MMFU_uris}},$uri->canonical if defined$uri;delete$self->{MMFF_body};$uri}sub URIs() {@{shift->{MMFU_uris}}}sub addAttribute($;@) {my$self=shift;$self->log(ERROR=>'No attributes for URI fields.');$self}1;
MAIL_MESSAGE_FIELD_URIS

$fatpacked{"Mail/Message/Field/Unstructured.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_FIELD_UNSTRUCTURED';
  package Mail::Message::Field::Unstructured;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Field::Full';use strict;use warnings;sub init($) {my ($self,$args)=@_;if($args->{body}&& ($args->{encoding}|| $args->{charset})){$args->{body}=$self->encode($args->{body},%$args)}$self->SUPER::init($args)or return;$self->log(WARNING=>"Attributes are not supported for unstructured fields")if defined$args->{attributes};$self->log(WARNING=>"No extras for unstructured fields")if defined$args->{extra};$self}1;
MAIL_MESSAGE_FIELD_UNSTRUCTURED

$fatpacked{"Mail/Message/Head.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD';
  package Mail::Message::Head;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;use Mail::Message::Head::Complete;use Mail::Message::Field::Fast;use Carp;use Scalar::Util 'weaken';use overload qq("")=>'string_unless_carp' ,bool=>'isEmpty';sub toString() {shift->load->toString}sub string() {shift->load->string}sub string_unless_carp() {my$self=shift;return$self->toString unless (caller)[0]eq 'Carp';(my$class=ref$self)=~ s/^Mail::Message/MM/;"$class object"}sub new(@) {my$class=shift;return Mail::Message::Head::Complete->new(@_)if$class eq __PACKAGE__;$class->SUPER::new(@_)}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMH_field_type}=$args->{field_type}if$args->{field_type};$self->message($args->{message})if defined$args->{message};$self->{MMH_fields}={};$self->{MMH_order}=[];$self->{MMH_modified}=$args->{modified}|| 0;$self}sub build(@) {shift;Mail::Message::Head::Complete->build(@_)}sub isDelayed {1}sub modified(;$) {my$self=shift;return$self->isModified unless @_;$self->{MMH_modified}=shift}sub isModified() {shift->{MMH_modified}}sub isEmpty {scalar keys %{shift->{MMH_fields}}}sub message(;$) {my$self=shift;if(@_){$self->{MMH_message}=shift;weaken($self->{MMH_message})}$self->{MMH_message}}sub orderedFields() {grep defined $_,@{shift->{MMH_order}}}sub knownNames() {keys %{shift->{MMH_fields}}}sub get($;$) {my$known=shift->{MMH_fields};my$value=$known->{lc(shift)};my$index=shift;if(defined$index){return!defined$value ? undef : ref$value eq 'ARRAY' ? $value->[$index]: $index==0 ? $value : undef}elsif(wantarray){return!defined$value ? (): ref$value eq 'ARRAY' ? @$value : ($value)}else {return!defined$value ? undef : ref$value eq 'ARRAY' ? $value->[-1]: $value}}sub get_all(@) {my@all=shift->get(@_)}sub setField($$) {shift->add(@_)}sub study($;$) {my$self=shift;return map {$_->study}$self->get(@_)if wantarray;my$got=$self->get(@_);defined$got ? $got->study : undef}sub isMultipart() {my$type=shift->get('Content-Type',0);$type && scalar$type->body =~ m[^multipart/]i}sub read($) {my ($self,$parser)=@_;my@fields=$parser->readHeader;@$self{qw/MMH_begin MMH_end/ }=(shift@fields,shift@fields);my$type=$self->{MMH_field_type}|| 'Mail::Message::Field::Fast';$self->addNoRealize($type->new(@$_))for@fields;$self}sub addOrderedFields(@) {my$order=shift->{MMH_order};for (@_){push @$order,$_;weaken($order->[-1])}@_}sub load($) {shift}sub fileLocation() {my$self=shift;@$self{qw/MMH_begin MMH_end/ }}sub moveLocation($) {my ($self,$dist)=@_;$self->{MMH_begin}-= $dist;$self->{MMH_end}-= $dist;$self}sub setNoRealize($) {my ($self,$field)=@_;my$known=$self->{MMH_fields};my$name=$field->name;$self->addOrderedFields($field);$known->{$name}=$field;$field}sub addNoRealize($) {my ($self,$field)=@_;my$known=$self->{MMH_fields};my$name=$field->name;$self->addOrderedFields($field);if(defined$known->{$name}){if(ref$known->{$name}eq 'ARRAY'){push @{$known->{$name}},$field}else {$known->{$name}=[$known->{$name},$field ]}}else {$known->{$name}=$field}$field}1;
MAIL_MESSAGE_HEAD

$fatpacked{"Mail/Message/Head/Complete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_COMPLETE';
  package Mail::Message::Head::Complete;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head';use strict;use warnings;use Mail::Box::Parser;use Mail::Message::Head::Partial;use Scalar::Util qw/weaken/;use List::Util qw/sum/;use Sys::Hostname qw/hostname/;sub clone(;@) {my$self=shift;my$copy=ref($self)->new($self->logSettings);$copy->addNoRealize($_->clone)for$self->grepNames(@_);$copy->modified(1);$copy}sub build(@) {my$class=shift;my$self=$class->new;while(@_){my$name=shift;defined$name or next;if($name->isa('Mail::Message::Field')){$self->add($name);next}my$content=shift;defined$content or next;if(ref$content && $content->isa('Mail::Message::Field')){$self->log(WARNING=>"Field objects have an implied name ($name)");$self->add($content);next}$self->add($name,$content)}$self}sub isDelayed() {0}sub nrLines() {sum 1,map $_->nrLines,shift->orderedFields}sub size() {sum 1,map $_->size,shift->orderedFields}sub wrap($) {my ($self,$length)=@_;$_->setWrapLength($length)for$self->orderedFields}sub add(@) {my$self=shift;my$field =@_==1 && ref $_[0]? shift : ($self->{MMH_field_type}|| 'Mail::Message::Field::Fast')->new(@_);return if!defined$field;$field->setWrapLength;my$known=$self->{MMH_fields};my$name=$field->name;$self->addOrderedFields($field);if(defined$known->{$name}){if(ref$known->{$name}eq 'ARRAY'){push @{$known->{$name}},$field}else {$known->{$name}=[$known->{$name},$field ]}}else {$known->{$name}=$field}$self->{MMH_modified}++;$field}sub count($) {my$known=shift->{MMH_fields};my$value=$known->{lc shift};!defined$value ? 0 : ref$value ? @$value : 1}sub names() {shift->knownNames}sub grepNames(@) {my$self=shift;my@take;push@take,(ref $_ eq 'ARRAY' ? @$_ : $_)foreach @_;return$self->orderedFields unless@take;my$take;if(@take==1 && ref$take[0]eq 'Regexp'){$take=$take[0]}else {local $"=')|(?:';$take=qr/^(?:(?:@take))/i}grep {$_->name =~ $take}$self->orderedFields}my@skip_none=qw/content-transfer-encoding content-disposition content-description content-id/;my%skip_none=map {($_=>1)}@skip_none;sub set(@) {my$self=shift;my$type=$self->{MMH_field_type}|| 'Mail::Message::Field::Fast';$self->{MMH_modified}++;my$field=@_==1 && ref $_[0]? shift->clone : $type->new(@_);my$name=$field->name;my$known=$self->{MMH_fields};if($skip_none{$name}&& $field->body eq 'none'){delete$known->{$name};return$field}$field->setWrapLength;$known->{$name}=$field;$self->addOrderedFields($field);$field}sub reset($@) {my ($self,$name)=(shift,lc shift);my$known=$self->{MMH_fields};if(@_==0){$self->{MMH_modified}++ if delete$known->{$name};return ()}$self->{MMH_modified}++;my@fields=map $_->clone,@_;if(@_==1){$known->{$name}=$fields[0]}else {$known->{$name}=[@fields]}$self->addOrderedFields(@fields);$self}sub delete($) {$_[0]->reset($_[1])}sub removeField($) {my ($self,$field)=@_;my$name=$field->name;my$known=$self->{MMH_fields};if(!defined$known->{$name}){}elsif(ref$known->{$name}eq 'ARRAY'){for(my$i=0;$i < @{$known->{$name}};$i++){return splice @{$known->{$name}},$i,1 if$known->{$name}[$i]eq $field}}elsif($known->{$name}eq $field){return delete$known->{$name}}$self->log(WARNING=>"Cannot remove field $name from header: not found.");return}sub removeFields(@) {my$self=shift;(bless$self,'Mail::Message::Head::Partial')->removeFields(@_)}sub removeFieldsExcept(@) {my$self=shift;(bless$self,'Mail::Message::Head::Partial')->removeFieldsExcept(@_)}sub removeContentInfo() {shift->removeFields(qr/^Content-/,'Lines')}sub removeResentGroups(@) {my$self=shift;(bless$self,'Mail::Message::Head::Partial')->removeResentGroups(@_)}sub removeListGroup(@) {my$self=shift;(bless$self,'Mail::Message::Head::Partial')->removeListGroup(@_)}sub removeSpamGroups(@) {my$self=shift;(bless$self,'Mail::Message::Head::Partial')->removeSpamGroups(@_)}sub spamDetected() {my$self=shift;my@sgs=$self->spamGroups or return undef;grep {$_->spamDetected}@sgs}sub print(;$) {my$self=shift;my$fh=shift || select;$_->print($fh)foreach$self->orderedFields;if(ref$fh eq 'GLOB'){print$fh "\n"}else {$fh->print("\n")}$self}sub printUndisclosed($) {my ($self,$fh)=@_;$_->print($fh)foreach grep {$_->toDisclose}$self->orderedFields;if(ref$fh eq 'GLOB'){print$fh "\n"}else {$fh->print("\n")}$self}sub printSelected($@) {my ($self,$fh)=(shift,shift);for my$field ($self->orderedFields){my$Name=$field->Name;my$name=$field->name;my$found;for my$pattern (@_){$found=ref$pattern?($Name =~ $pattern):($name eq lc$pattern);last if$found}if(!$found){}elsif(ref$fh eq 'GLOB'){print$fh "\n"}else {$fh->print("\n")}}$self}sub toString() {shift->string}sub string() {my$self=shift;my@lines=map {$_->string}$self->orderedFields;push@lines,"\n";wantarray ? @lines : join('',@lines)}sub resentGroups() {my$self=shift;require Mail::Message::Head::ResentGroup;Mail::Message::Head::ResentGroup->from($self)}sub addResentGroup(@) {my$self=shift;require Mail::Message::Head::ResentGroup;my$rg=@_==1 ? (shift): Mail::Message::Head::ResentGroup->new(@_);my@fields=$rg->orderedFields;my$order=$self->{MMH_order};my$i;for($i=0;$i < @$order;$i++){next unless defined$order->[$i];last if$rg->isResentGroupFieldName($order->[$i]->name)}my$known=$self->{MMH_fields};while(@fields){my$f=pop@fields;splice @$order,$i,0,$f;weaken($order->[$i]);my$name=$f->name;if(!defined$known->{$name}){$known->{$name}=$f}elsif(ref$known->{$name}eq 'ARRAY'){unshift @{$known->{$name}},$f}else {$known->{$name}=[$f,$known->{$name}]}}$rg->messageHead($self);$self->modified(1);$rg}sub listGroup() {my$self=shift;eval "require 'Mail::Message::Head::ListGroup'";Mail::Message::Head::ListGroup->from($self)}sub addListGroup($) {my ($self,$lg)=@_;$lg->attach($self)}sub spamGroups(@) {my$self=shift;require Mail::Message::Head::SpamGroup;my@types=@_ ? (types=>\@_): ();my@sgs=Mail::Message::Head::SpamGroup->from($self,@types);wantarray || @_!=1 ? @sgs : $sgs[0]}sub addSpamGroup($) {my ($self,$sg)=@_;$sg->attach($self)}sub timestamp() {shift->guessTimestamp || time}sub recvstamp() {my$self=shift;return$self->{MMH_recvstamp}if exists$self->{MMH_recvstamp};my$recvd=$self->get('received',0)or return$self->{MMH_recvstamp}=undef;my$stamp=Mail::Message::Field->dateToTimestamp($recvd->comment);$self->{MMH_recvstamp}=defined$stamp && $stamp > 0 ? $stamp : undef}sub guessTimestamp() {my$self=shift;return$self->{MMH_timestamp}if exists$self->{MMH_timestamp};my$stamp;if(my$date=$self->get('date')){$stamp=Mail::Message::Field->dateToTimestamp($date)}unless($stamp){for (reverse$self->get('received')){$stamp=Mail::Message::Field->dateToTimestamp($_->comment);last if$stamp}}$self->{MMH_timestamp}=defined$stamp && $stamp > 0 ? $stamp : undef}sub guessBodySize() {my$self=shift;my$cl=$self->get('Content-Length');return $1 if defined$cl && $cl =~ m/(\d+)/;my$lines=$self->get('Lines');return $1 * 40 if defined$lines && $lines =~ m/(\d+)/;undef}sub createFromLine() {my$self=shift;my$sender=$self->message->sender;my$stamp=$self->recvstamp || $self->timestamp || time;my$addr=defined$sender ? $sender->address : 'unknown';"From $addr ".(gmtime$stamp)."\n"}my$msgid_creator;sub createMessageId() {$msgid_creator ||=$_[0]->messageIdPrefix;$msgid_creator->(@_)}sub messageIdPrefix(;$$) {my$thing=shift;return$msgid_creator unless @_ ||!defined$msgid_creator;return$msgid_creator=shift if @_==1 && ref $_[0]eq 'CODE';my$prefix=shift || "mailbox-$$";my$hostname=shift;if(!defined$hostname){eval "require Net::Domain";$@ or $hostname=Net::Domain::hostfqdn()}$hostname ||=hostname || 'localhost';eval "require Time::HiRes";if(Time::HiRes->can('gettimeofday')){return$msgid_creator =sub {my ($sec,$micro)=Time::HiRes::gettimeofday();"$prefix-$sec-$micro\@$hostname"}}my$unique_id=time;$msgid_creator =sub {$unique_id++;"$prefix-$unique_id\@$hostname"}}1;
MAIL_MESSAGE_HEAD_COMPLETE

$fatpacked{"Mail/Message/Head/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_DELAYED';
  package Mail::Message::Head::Delayed;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Message::Head';use strict;use warnings;use Object::Realize::Later becomes=>'Mail::Message::Head::Complete',realize=>'load',believe_caller=>1;use Scalar::Util 'weaken';sub build(@) {shift->log(ERROR=>"Cannot build() a delayed header.")}sub init($$) {my ($self,$args)=@_;$self->SUPER::init($args);if(defined$args->{message}){$self->{MMHD_message}=$args->{message};weaken($self->{MMHD_message})}$self}sub isDelayed() {1}sub modified(;$) {return 0 if @_==1 ||!$_[1];shift->forceRealize->modified(1)}sub isModified() {0}sub isEmpty() {0}sub get($;$) {my$self=shift;$self->load->get(@_)}sub guessBodySize() {undef}sub guessTimestamp() {undef}sub read($) {my ($self,$parser,$headtype,$bodytype)=@_;$self->{MMH_where}=0;$self}sub load() {$_[0]=$_[0]->message->loadHead}sub setNoRealize($) {shift->log(INTERNAL=>"Setting field on a delayed?")}1;
MAIL_MESSAGE_HEAD_DELAYED

$fatpacked{"Mail/Message/Head/FieldGroup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_FIELDGROUP';
  package Mail::Message::Head::FieldGroup;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;sub new(@) {my$class=shift;my@fields;push@fields,shift while ref $_[0];$class->SUPER::new(@_,fields=>\@fields)}sub init($$) {my ($self,$args)=@_;$self->SUPER::init($args);my$head=$self->{MMHF_head}=$args->{head}|| Mail::Message::Head::Partial->new;$self->add($_)foreach @{$args->{fields}};$self->add($_,delete$args->{$_})foreach grep m/^[A-Z]/,keys %$args;$self->{MMHF_version}=$args->{version}if defined$args->{version};$self->{MMHF_software}=$args->{software}if defined$args->{software};$self->{MMHF_type}=$args->{type}if defined$args->{type};$self->{MMHF_fns}=[];$self}sub implementedTypes() {shift->notImplemented}sub from($) {shift->notImplemented}sub clone() {my$self=shift;my$clone=bless %$self,ref$self;$clone->{MMHF_fns}=[$self->fieldNames ];$clone}sub head() {shift->{MMHF_head}}sub attach($) {my ($self,$head)=@_;$head->add($_->clone)for$self->fields;$self}sub delete() {my$self=shift;my$head=$self->head;$head->removeField($_)foreach$self->fields;$self}sub add(@) {my$self=shift;my$field=$self->head->add(@_)or return ();push @{$self->{MMHF_fns}},$field->name;$self}sub fields() {my$self=shift;my$head=$self->head;map {$head->get($_)}$self->fieldNames}sub fieldNames() {@{shift->{MMHF_fns}}}sub addFields(@) {my$self=shift;my$head=$self->head;push @{$self->{MMHF_fns}},@_;@_}sub version() {shift->{MMHF_version}}sub software() {shift->{MMHF_software}}sub type() {shift->{MMHF_type}}sub detected($$$) {my$self=shift;@$self{qw/MMHF_type MMHF_software MMHF_version/ }=@_}sub collectFields(;$) {shift->notImplemented}sub print(;$) {my$self=shift;my$out=shift || select;$_->print($out)foreach$self->fields}sub details() {my$self=shift;my$type=$self->type || 'Unknown';my$software=$self->software;undef$software if defined($software)&& $type eq $software;my$version=$self->version;my$release =defined$software ? (defined$version ? " ($software $version)" : " ($software)"): (defined$version ? " ($version)" : '');my$fields=scalar$self->fields;"$type $release, $fields fields"}1;
MAIL_MESSAGE_HEAD_FIELDGROUP

$fatpacked{"Mail/Message/Head/ListGroup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_LISTGROUP';
  package Mail::Message::Head::ListGroup;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head::FieldGroup';use strict;use warnings;use List::Util 'first';sub init($$) {my ($self,$args)=@_;$self->SUPER::init($args);my$address=$args->{address};if(!defined$address){}elsif(!ref$address ||!$address->isa('Mail::Message::Field::Address')){require Mail::Message::Field::Address;my$mi=Mail::Message::Field::Address->coerce($address);$self->log(ERROR=>"Cannot convert \"$address\" into an address object"),return unless defined$mi;$address=$mi}$self->{MMHL_address}=$address if defined$args->{address};$self->{MMHL_listname}=$args->{listname}if defined$args->{listname};$self->{MMHL_rfc}=$args->{rfc}if defined$args->{rfc};$self->{MMHL_fns}=[];$self}sub from($) {my ($class,$from)=@_;my$head=$from->isa('Mail::Message::Head')? $from : $from->head;my$self=$class->new(head=>$head);return ()unless$self->collectFields;my ($type,$software,$version,$field);if(my$communigate=$head->get('X-ListServer')){($software,$version)=$communigate =~ m/^(.*)\s+LIST\s*([\d.]+)\s*$/i;$type=($software =~ m/Pro/ ? 'CommuniGatePro' : 'CommuniGate')}elsif(my$mailman=$head->get('X-Mailman-Version')){$version="$mailman";$type='Mailman'}elsif(my$majordomo=$head->get('X-Majordomo-Version')){$version="$majordomo";$type='Majordomo'}elsif(my$ecartis=$head->get('X-Ecartis-Version')){($software,$version)=$ecartis =~ m/^(.*)\s+(v[\d.]+)/;$type='Ecartis'}elsif(my$listar=$head->get('X-Listar-Version')){($software,$version)=$listar =~ m/^(.*?)\s+(v[\w.]+)/;$type='Listar'}elsif(defined($field=$head->get('List-Software'))&& $field =~ m/listbox/i){($software,$version)=$field =~ m/^(\S*)\s*(v[\d.]+)\s*$/;$type='Listbox'}elsif($field=first {m!LISTSERV-TCP/IP!s}$head->get('Received')){($software,$version)=$field =~ m!\( (LISTSERV-TCP/IP) \s+ release \s+ (\S+) \)!xs;$type='Listserv'}elsif(defined($field=$head->get('X-Mailing-List'))&& $field =~ m[archive/latest]){$type='Smartlist'}elsif(defined($field=$head->get('Mailing-List'))&& $field =~ m/yahoo/i){$type='YahooGroups'}elsif(defined($field)&& $field =~ m/(ezmlm)/i){$type='Ezmlm'}elsif(my$fml=$head->get('X-MLServer')){($software,$version)=$fml =~ m/^\s*(\S+)\s*\[\S*\s*([^\]]*?)\s*\]/;$type='FML'}elsif(defined($field=$head->get('List-Subscribe')|| $head->get('List-Unsubscribe'))&& $field =~ m/sympa/i){$type='Sympa'}elsif(first {m/majordom/i}$head->get('Received')){$type="Majordomo"}elsif($field=$head->get('List-ID')&& $field =~ m/listbox\.com/i){$type="Listbox"}$self->detected($type,$software,$version);$self}sub rfc() {my$self=shift;return$self->{MMHL_rfc}if defined$self->{MMHL_rfc};my$head=$self->head;defined$head->get('List-Post')? 'rfc2369' : defined$head->get('List-Id')? 'rfc2919' : undef}sub address() {my$self=shift;return$self->{MMHL_address}if exists$self->{MMHL_address};my$type=$self->type || 'Unknown';my$head=$self->head;my ($field,$address);if($type eq 'Smartlist' && defined($field=$head->get('X-Mailing-List'))){$address=$1 if$field =~ m/\<([^>]+)\>/}elsif($type eq 'YahooGroups'){$address=$head->get('X-Apparently-To')->unfoldedBody}elsif($type eq 'Listserv'){$address=$head->get('Sender')}$address ||=$head->get('List-Post')|| $head->get('Reply-To')|| $head->get('Sender');$address=$address->study if ref$address;if(!defined$address){}elsif(!ref$address){$address =~ s/\bowner-|-(?:owner|bounce|admin)\@//i;$address=Mail::Message::Field::Address->new(address=>$address)}elsif($address->isa('Mail::Message::Field::Addresses')){$address=($address->addresses)[0];my$username=defined$address ? $address->username : '';if($username =~ s/^owner-|-(owner|bounce|admin)$//i){$address=Mail::Message::Field::Address->new (username=>$username,domain=>$address->domain)}}elsif($address->isa('Mail::Message::Field::URIs')){my$uri=first {$_->scheme eq 'mailto'}$address->URIs;$address=defined$uri ? Mail::Message::Field::Address->new(address=>$uri->to): undef}else {undef$address}$self->{MMHL_address}=$address}sub listname() {my$self=shift;return$self->{MMHL_listname}if exists$self->{MMHL_listname};my$head=$self->head;my$list=$head->get('List-ID')|| $head->get('X-List')|| $head->get('X-ML-Name');my$listname;if(defined$list){$listname=$list->study->decodedBody}elsif(my$address=$self->address){$listname=$address->phrase || $address->address}$self->{MMHL_listname}=$listname}my$list_field_names =qr/ ^ (?: List|X-Envelope|X-Original ) - 
        | ^ (?: Precedence|Mailing-List|Approved-By ) $
        | ^ X-(?: Loop|BeenThere|Sequence|List|Sender|MLServer ) $
        | ^ X-(?: Mailman|Listar|Egroups|Encartis|ML ) -
        | ^ X-(?: Archive|Mailing|Original|Mail|ListServer ) -
        | ^ (?: Mail-Followup|Delivered|Errors|X-Apperently ) -To $
        /xi;sub isListGroupFieldName($) {$_[1]=~ $list_field_names}sub collectFields() {my$self=shift;my@names=map {$_->name}$self->head->grepNames($list_field_names);$self->addFields(@names);@names}sub details() {my$self=shift;my$type=$self->type || 'Unknown';my$software=$self->software;undef$software if defined($software)&& $type eq $software;my$version=$self->version;my$release =defined$software ? (defined$version ? " ($software $version)" : " ($software)"): (defined$version ? " ($version)" : '');my$address=$self->address || 'unknown address';my$fields=scalar$self->fields;"$type at $address$release, $fields fields"}1;
MAIL_MESSAGE_HEAD_LISTGROUP

$fatpacked{"Mail/Message/Head/Partial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_PARTIAL';
  package Mail::Message::Head::Partial;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head::Complete';use strict;use warnings;use Scalar::Util 'weaken';sub removeFields(@) {my$self=shift;my$known=$self->{MMH_fields};for my$match (@_){if(ref$match){$_ =~ $match && delete$known->{$_}foreach keys %$known}else {delete$known->{lc$match}}}$self->cleanupOrderedFields}sub removeFieldsExcept(@) {my$self=shift;my$known=$self->{MMH_fields};my%remove=map {($_=>1)}keys %$known;for my$match (@_){if(ref$match){$_ =~ $match && delete$remove{$_}foreach keys%remove}else {delete$remove{lc$match}}}delete @$known{keys%remove };$self->cleanupOrderedFields}sub removeResentGroups() {my$self=shift;require Mail::Message::Head::ResentGroup;my$known=$self->{MMH_fields};my$found=0;for my$name (keys %$known){next unless Mail::Message::Head::ResentGroup ->isResentGroupFieldName($name);delete$known->{$name};$found++}$self->cleanupOrderedFields;$self->modified(1)if$found;$found}sub removeListGroup() {my$self=shift;require Mail::Message::Head::ListGroup;my$known=$self->{MMH_fields};my$found=0;for my$name (keys %$known){next unless Mail::Message::Head::ListGroup->isListGroupFieldName($name);delete$known->{$name};$found++}$self->cleanupOrderedFields if$found;$self->modified(1)if$found;$found}sub removeSpamGroups() {my$self=shift;require Mail::Message::Head::SpamGroup;my$known=$self->{MMH_fields};my$found=0;for my$name (keys %$known){next unless Mail::Message::Head::SpamGroup->isSpamGroupFieldName($name);delete$known->{$name};$found++}$self->cleanupOrderedFields if$found;$self->modified(1)if$found;$found}sub cleanupOrderedFields() {my$self=shift;my@take=grep {defined $_}@{$self->{MMH_order}};weaken($_)foreach@take;$self->{MMH_order}=\@take;$self}1;
MAIL_MESSAGE_HEAD_PARTIAL

$fatpacked{"Mail/Message/Head/ResentGroup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_RESENTGROUP';
  package Mail::Message::Head::ResentGroup;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head::FieldGroup';use strict;use warnings;use Scalar::Util 'weaken';use Mail::Message::Field::Fast;use Sys::Hostname 'hostname';use Mail::Address;my@ordered_field_names=('return-path','delivered-to','received','resent-date' ,'resent-from','resent-sender',,'resent-to','resent-cc' ,'resent-bcc','resent-message-id');my%resent_field_names=map {($_=>1)}@ordered_field_names;sub init($$) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MMHR_real}=$args->{message_head};$self->set(Received=>$self->createReceived)if$self->orderedFields &&!$self->received;$self}sub from($@) {return $_[0]->resentFrom if @_==1;my ($class,$from,%args)=@_;my$head=$from->isa('Mail::Message::Head')? $from : $from->head;my (@groups,$group,$return_path,$delivered_to);for my$field ($head->orderedFields){my$name=$field->name;next unless$resent_field_names{$name};if($name eq 'return-path'){$return_path=$field}elsif($name eq 'delivered-to'){$delivered_to=$field}elsif(substr($name,0,7)eq 'resent-'){$group->add($field)if defined$group}elsif($name eq 'received'){$group=Mail::Message::Head::ResentGroup ->new($field,message_head=>$head);push@groups,$group;$group->add($delivered_to)if defined$delivered_to;undef$delivered_to;$group->add($return_path)if defined$return_path;undef$return_path}}@groups}sub messageHead(;$) {my$self=shift;@_ ? $self->{MMHR_real}=shift : $self->{MMHR_real}}sub orderedFields() {my$head=shift->head;map {$head->get($_)|| ()}@ordered_field_names}sub set($;$) {my$self=shift;my$field;if(@_==1){$field=shift}else {my ($fn,$value)=@_;my$name=$resent_field_names{lc$fn}? $fn : "Resent-$fn";$field=Mail::Message::Field::Fast->new($name,$value)}$self->head->set($field);$field}sub fields() {shift->orderedFields}sub fieldNames() {map {$_->Name}shift->orderedFields}sub delete() {my$self=shift;my$head=$self->messageHead;$head->removeField($_)foreach$self->fields;$self}sub add(@) {shift->set(@_)}sub addFields(@) {shift->notImplemented}sub returnPath() {shift->{MMHR_return_path}}sub deliveredTo() {shift->head->get('Delivered-To')}sub received() {shift->head->get('Received')}sub receivedTimestamp() {my$received=shift->received or return;my$comment=$received->comment or return;Mail::Message::Field->dateToTimestamp($comment)}sub date($) {shift->head->get('resent-date')}sub dateTimestamp() {my$date=shift->date or return;Mail::Message::Field->dateToTimestamp($date->unfoldedBody)}sub resentFrom() {my$from=shift->head->get('resent-from')or return ();wantarray ? $from->addresses : $from}sub sender() {my$sender=shift->head->get('resent-sender')or return ();wantarray ? $sender->addresses : $sender}sub to() {my$to=shift->head->get('resent-to')or return ();wantarray ? $to->addresses : $to}sub cc() {my$cc=shift->head->get('resent-cc')or return ();wantarray ? $cc->addresses : $cc}sub bcc() {my$bcc=shift->head->get('resent-bcc')or return ();wantarray ? $bcc->addresses : $bcc}sub destinations() {my$self=shift;($self->to,$self->cc,$self->bcc)}sub messageId() {shift->head->get('resent-message-id')}sub isResentGroupFieldName($) {$resent_field_names{lc $_[1]}}my$unique_received_id='rc'.time;sub createReceived(;$) {my ($self,$domain)=@_;unless(defined$domain){my$sender=($self->sender)[0]|| ($self->resentFrom)[0];$domain=$sender->host if defined$sender}my$received ='from ' .$domain .' by ' .hostname .' with SMTP' .' id ' .$unique_received_id++ .' for ' .$self->head->get('Resent-To').'; '.Mail::Message::Field->toDate;$received}1;
MAIL_MESSAGE_HEAD_RESENTGROUP

$fatpacked{"Mail/Message/Head/SpamGroup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_SPAMGROUP';
  package Mail::Message::Head::SpamGroup;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head::FieldGroup';use strict;use warnings;use Carp 'confess';my%fighters;my$fighterfields;sub knownFighters() {keys%fighters}sub fighter($;@) {my ($thing,$name)=(shift,shift);if(@_){my%args=@_;defined$args{fields}or confess "Spamfighters require fields\n";defined$args{isspam}or confess "Spamfighters require isspam\n";$fighters{$name}=\%args;my@fields=map {$_->{fields}}values%fighters;local $"='|';$fighterfields=qr/@fields/}%{$fighters{$name}}}BEGIN {__PACKAGE__->fighter(SpamAssassin=>fields=>qr/^X-Spam-/i ,isspam=>sub {my ($sg,$head)=@_;my$f=$head->get('X-Spam-Flag')|| $head->get('X-Spam-Status')or return 0;$f =~ m/^yes\b/i},version=>sub {my ($sg,$head)=@_;my$assin=$head->get('X-Spam-Checker-Version')or return ();my ($software,$version)=$assin =~ m/^(.*)\s+(.*?)\s*$/;($software,$version)});__PACKAGE__->fighter('Habeas-SWE'=>fields=>qr/^X-Habeas-SWE/i ,isspam=>sub {my ($sg,$head)=@_;not $sg->habeasSweFieldsCorrect});__PACKAGE__->fighter(MailScanner=>fields=>qr/^X-MailScanner/i ,isspam=>sub {my ($sg,$head)=@_;my$subject=$head->get('subject');$subject =~ m/^\{ (?:spam|virus)/xi})}sub from($@) {my ($class,$from,%args)=@_;my$head=$from->isa('Mail::Message::Head')? $from : $from->head;my ($self,@detected);my@types=defined$args{types}? @{$args{types}}: $class->knownFighters;for my$type (@types){$self=$class->new(head=>$head)unless defined$self;next unless$self->collectFields($type);my%fighter=$self->fighter($type);my ($software,$version)=defined$fighter{version}? $fighter{version}->($self,$head): ();$self->detected($type,$software,$version);$self->spamDetected($fighter{isspam}->($self,$head));push@detected,$self;undef$self}@detected}sub collectFields($) {my ($self,$set)=@_;my%fighter=$self->fighter($set)or confess "ERROR: No spam set $set.";my@names=map {$_->name}$self->head->grepNames($fighter{fields});return ()unless@names;$self->addFields(@names);@names}sub isSpamGroupFieldName($) {$_[1]=~ $fighterfields}my@habeas_lines=('winter into spring','brightly anticipated','like Habeas SWE (tm)','Copyright 2002 Habeas (tm)','Sender Warranted Email (SWE) (tm). The sender of this','email in exchange for a license for this Habeas','warrant mark warrants that this is a Habeas Compliant','Message (HCM) and not spam. Please report use of this','mark in spam to <http://www.habeas.com/report/>.');sub habeasSweFieldsCorrect(;$) {my$self;if(@_ > 1){my ($class,$thing)=@_;my$head=$thing->isa('Mail::Message::Head')? $thing : $thing->head;$self=$head->spamGroups('Habeas-SWE')or return}else {$self=shift;my$type=$self->type;return unless defined$type && $type eq 'Habeas-SWE'}my$head=$self->head;return if$self->fields!=@habeas_lines;for(my$nr=1;$nr <= $#habeas_lines;$nr++){my$f=$head->get("X-Habeas-SWE-$nr")or return;return if$f->unfoldedBody ne $habeas_lines[$nr-1]}1}sub spamDetected(;$) {my$self=shift;@_? ($self->{MMFS_spam}=shift): $self->{MMFS_spam}}1;
MAIL_MESSAGE_HEAD_SPAMGROUP

$fatpacked{"Mail/Message/Head/Subset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_HEAD_SUBSET';
  package Mail::Message::Head::Subset;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Message::Head';use strict;use warnings;use Object::Realize::Later becomes=>'Mail::Message::Head::Complete',realize=>'load',believe_caller=>1;use Date::Parse qw(str2time);sub count($) {my ($self,$name)=@_;my@values=$self->get($name)or return$self->load->count($name);scalar@values}sub get($;$) {my$self=shift;if(wantarray){my@values=$self->SUPER::get(@_);return@values if@values}else {my$value=$self->SUPER::get(@_);return$value if defined$value}$self->load->get(@_)}sub guessBodySize() {my$self=shift;my$cl=$self->SUPER::get('Content-Length');return $1 if defined$cl && $cl =~ m/(\d+)/;my$lines=$self->SUPER::get('Lines');return $1*40 if defined$lines && $lines =~ m/(\d+)/;undef}sub guessTimestamp() {my$self=shift;return$self->{MMHS_timestamp}if$self->{MMHS_timestamp};my$stamp;if(my$date=$self->SUPER::get('date')){$stamp=str2time($date,'GMT')}unless($stamp){for ($self->SUPER::get('received')){$stamp=str2time($_,'GMT');last if$stamp}}$self->{MMHS_timestamp}=$stamp}sub load() {$_[0]=$_[0]->message->loadHead}1;
MAIL_MESSAGE_HEAD_SUBSET

$fatpacked{"Mail/Message/Part.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_PART';
  package Mail::Message::Part;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message';use strict;use warnings;use Scalar::Util 'weaken';use Carp;sub init($) {my ($self,$args)=@_;$args->{head}||=Mail::Message::Head::Complete->new;$self->SUPER::init($args);confess "No container specified for part.\n" unless exists$args->{container};weaken($self->{MMP_container})if$self->{MMP_container}=$args->{container};$self}sub coerce($@) {my ($class,$thing,$container)=(shift,shift,shift);if($thing->isa($class)){$thing->container($container);return$thing}return$class->buildFromBody($thing,$container,@_)if$thing->isa('Mail::Message::Body');my$message=$thing->isa('Mail::Box::Message')? $thing->clone : $thing;my$part=$class->SUPER::coerce($message);$part->container($container);$part}sub buildFromBody($$;@) {my ($class,$body,$container)=(shift,shift,shift);my@log=$body->logSettings;my$head=Mail::Message::Head::Complete->new(@log);while(@_){if(ref $_[0]){$head->add(shift)}else {$head->add(shift,shift)}}my$part=$class->new (head=>$head ,container=>$container ,@log);$part->body($body);$part}sub container(;$) {my$self=shift;return$self->{MMP_container}unless @_;$self->{MMP_container}=shift;weaken($self->{MMP_container})}sub toplevel() {my$body=shift->container or return;my$msg=$body->message or return;$msg->toplevel}sub isPart() {1}sub partNumber() {my$self=shift;my$body=$self->container or confess 'no container';$body->partNumberOf($self)}sub readFromParser($;$) {my ($self,$parser,$bodytype)=@_;my$head=$self->readHead($parser)|| Mail::Message::Head::Complete->new (message=>$self ,field_type=>$self->{MM_field_type},$self->logSettings);my$body=$self->readBody($parser,$head,$bodytype)|| Mail::Message::Body::Lines->new(data=>[]);$self->head($head);$self->storeBody($body->contentInfoFrom($head));$self}sub printEscapedFrom($) {my ($self,$out)=@_;$self->head->print($out);$self->body->printEscapedFrom($out)}sub destruct() {my$self=shift;$self->log(ERROR=>'You cannot destruct message parts, only whole messages');undef}1;
MAIL_MESSAGE_PART

$fatpacked{"Mail/Message/Replace/MailHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_REPLACE_MAILHEADER';
  package Mail::Message::Replace::MailHeader;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::Head::Complete';use strict;use warnings;sub new(@) {my$class=shift;unshift @_,'raw_data' if @_ % 2;$class->SUPER::new(@_)}sub init($) {my ($self,$args)=@_;defined$self->SUPER::init($args)or return;$self->modify ($args->{Modify}|| $args->{Reformat}|| 0);$self->fold_length($args->{FoldLength}|| 79);$self->mail_from ($args->{MailFrom}|| 'KEEP');$self}sub delete($;$) {my ($self,$tag)=(shift,shift);return$self->delete($tag)unless @_;my$index=shift;my@fields=$self->get($tag);my ($field)=splice@fields,$index,1;$self->reset($tag,@fields);$field}sub add($$) {my$self=shift;my$field=$self->add(shift);$field->unfoldedBody}sub replace($$;$) {my ($self,$tag,$line,$index)=@_;$line =~ s/^([^:]+)\:\s*// && ($tag=$1)unless defined$tag;my$field=Mail::Message::Field::Fast->new($tag,$line);my@fields=$self->get($tag);$fields[$index||0 ]=$field;$self->reset($tag,@fields);$field}sub get($;$) {my$head=shift->head;my@ret=map {$head->get(@_)}@_;if(wantarray){return@ret ? map({$_->unfoldedBody}@ret): ()}else {return@ret ? $ret[0]->unfoldedBody : undef}}sub modify(;$) {my$self=shift;@_ ? ($self->{MH_refold}=shift): $self->{MH_refold}}sub mail_from(;$) {my$self=shift;return$self->{MH_mail_from}unless @_;my$choice=uc(shift);die "bad Mail-From choice: '$choice'" unless$choice =~ /^(IGNORE|ERROR|COERCE|KEEP)$/;$self->{MH_mail_from}=$choice}sub fold(;$) {my$self=shift;my$wrap=@_ ? shift : $self->fold_length;$_->setWrapLength($wrap)foreach$self->orderedFields;$self}sub unfold(;$) {my$self=shift;my@fields=@_ ? $self->get(shift): $self->orderedFields;$_->setWrapLength(100_000)foreach@fields;$self}sub extract($) {my ($self,$lines)=@_;my$parser=Mail::Box::Parser::Perl->new (filename=>'extract from array' ,data=>$lines ,trusted=>1);$self->read($parser);$parser->close;shift @$lines while @$lines && $lines->[0]!=m/^[\r\n]+/;shift @$lines if @$lines;$self}sub read($) {my ($self,$file)=@_;my$parser=Mail::Box::Parser::Perl->new (filename=>('from file-handle '.ref$file),file=>$file ,trusted=>1);$self->read($parser);$parser->close;$self}sub empty() {shift->removeFields(m/^/)}sub header(;$) {my$self=shift;$self->extract(shift)if @_;$self->fold if$self->modify;[$self->orderedFields ]}sub header_hashref($) {die "Don't use header_hashref!!!"}sub combine($;$) {die "Don't use combine()!!!"}sub exists() {shift->count}sub as_string() {shift->string}sub fold_length(;$$) {my$self=shift;return$self->{MH_wrap}unless @_;my$old=$self->{MH_wrap};my$wrap=$self->{MH_wrap}=shift;$self->fold($wrap)if$self->modify;$old}sub tags() {shift->names}sub dup() {shift->clone}sub cleanup() {shift}BEGIN {no warnings;*Mail::Header::new=sub {my$class=shift;Mail::Message::Replace::MailHeader->new(@_)}}sub isa($) {my ($thing,$class)=@_;return 1 if$class eq 'Mail::Mailer';$thing->SUPER::isa($class)}1;
MAIL_MESSAGE_REPLACE_MAILHEADER

$fatpacked{"Mail/Message/Replace/MailInternet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_REPLACE_MAILINTERNET';
  package Mail::Message::Replace::MailInternet;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message';use strict;use warnings;use Mail::Box::FastScalar;use Mail::Box::Parser::Perl;use Mail::Message::Body::Lines;use File::Spec;sub new(@) {my$class=shift;my$data=@_ % 2 ? shift : undef;$class=__PACKAGE__ if$class eq 'Mail::Internet';$class->SUPER::new(@_,raw_data=>$data)}sub init($) {my ($self,$args)=@_;$args->{head_type}||='Mail::Message::Replace::MailHeader';$args->{head}||=$args->{Header};$args->{body}||=$args->{Body};defined$self->SUPER::init($args)or return;$self->{MI_wrap}=$args->{FoldLength}|| 79;$self->{MI_mail_from}=$args->{MailFrom};$self->{MI_modify}=exists$args->{Modify}? $args->{Modify}: 1;$self->processRawData($self->{raw_data},!defined$args->{Header},!defined$args->{Body})if defined$self->{raw_data};$self}sub processRawData($$$) {my ($self,$data,$get_head,$get_body)=@_;return$self unless$get_head || $get_body;my ($filename,$lines);if(ref$data eq 'ARRAY'){$filename='array of lines';$lines=$data}elsif(ref$data eq 'GLOB'){$filename='file (GLOB)';$lines=[<$data> ]}elsif(ref$data && $data->isa('IO::Handle')){$filename='file ('.ref($data).')';$lines=[$data->getlines ]}else {$self->log(ERROR=>"Mail::Internet does not support this kind of data");return undef}return unless @$lines;my$buffer=join '',@$lines;my$file=Mail::Box::FastScalar->new(\$buffer);my$parser=Mail::Box::Parser::Perl->new (filename=>$filename ,file=>$file ,trusted=>1);my$head;if($get_head){my$from=substr($lines->[0],0,5)eq 'From ' ? shift @$lines : undef;my$head=$self->{MM_head_type}->new (MailFrom=>$self->{MI_mail_from},Modify=>$self->{MI_modify},FoldLength=>$self->{MI_wrap});$head->read($parser);$head->mail_from($from)if defined$from;$self->head($head)}else {$head=$self->head}$self->storeBody($self->readBody($parser,$head))if$get_body;$self->addReport($parser);$parser->stop;$self}sub dup() {my$self=shift;ref($self)->coerce($self->clone)}sub empty() {shift->DESTROY}sub MailFrom(;$) {my$self=shift;@_ ? ($self->{MI_mail_from}=shift): $self->{MU_mail_from}}sub read($@) {my$thing=shift;return$thing->SUPER::read(@_)unless ref$thing;my$data=shift;$thing->processRawData($data,1,1)}sub read_body($) {my ($self,$data)=@_;$self->processRawData($data,0,1)}sub read_header($) {my ($self,$data)=@_;$self->processRawData($data,1,0)}sub extract($) {my ($self,$data)=@_;$self->processRawData($data,1,1)}sub reply(@) {my ($self,%args)=@_;my$reply_head=$self->{MM_head_type}->new;my$home=$ENV{HOME}|| File::Spec->curdir;my$headtemp=File::Spec->catfile($home,'.mailhdr');if(open HEAD,'<:raw',$headtemp){my$parser=Mail::Box::Parser::Perl->new (filename=>$headtemp ,file=>\*HEAD ,trusted=>1);$reply_head->read($parser);$parser->close}$args{quote}||=delete$args{Inline}|| '>';$args{group_reply}||=delete$args{ReplyAll}|| 0;my$keep=delete$args{Keep}|| [];my$exclude=delete$args{Exclude}|| [];my$reply=$self->SUPER::reply(%args);my$head=$self->head;$reply_head->add($_->clone)foreach map {$head->get($_)}@$keep;$reply_head->reset($_)foreach @$exclude;ref($self)->coerce($reply)}sub add_signature(;$) {my$self=shift;my$filename=shift || File::Spec->catfile($ENV{HOME}|| File::Spec->curdir,'.signature');$self->sign(File=>$filename)}sub sign(@) {my ($self,$args)=@_;my$sig;if(my$filename=delete$self->{File}){$sig=Mail::Message::Body->new(file=>$filename)}elsif(my$sig=delete$self->{Signature}){$sig=Mail::Message::Body->new(data=>$sig)}return unless defined$sig;my$body=$self->decoded->stripSignature;my$set=$body->concatenate($body,"-- \n",$sig);$self->body($set)if defined$set;$set}sub send($@) {my ($self,$type,%args)=@_;$self->send(via=>$type)}sub nntppost(@) {my ($self,%args)=@_;$args{port}||=delete$args{Port};$args{nntp_debug}||=delete$args{Debug};$self->send(via=>'nntp',%args)}sub head(;$) {my$self=shift;return$self->SUPER::head(@_)if @_;$self->SUPER::head || $self->{MM_head_type}->new(message=>$self)}sub header(;$) {shift->head->header(@_)}sub fold(;$) {shift->head->fold(@_)}sub fold_length(;$$) {shift->head->fold_length(@_)}sub combine($;$) {shift->head->combine(@_)}sub print_header(@) {shift->head->print(@_)}sub clean_header() {shift->header}sub tidy_headers() {}sub add(@) {shift->head->add(@_)}sub replace(@) {shift->head->replace(@_)}sub get(@) {shift->head->get(@_)}sub delete(@) {my$self=shift;@_ ? $self->head->delete(@_): $self->SUPER::delete}sub body(@) {my$self=shift;unless(@_){my$body=$self->body;return defined$body ? scalar($body->lines): []}my$data=ref $_[0]eq 'ARRAY' ? shift : \@_;my$body=Mail::Message::Body::Lines->new(data=>$data);$self->body($body);$body}sub print_body(@) {shift->SUPER::body->print(@_)}sub bodyObject(;$) {shift->SUPER::body(@_)}sub remove_sig(;$) {my$self=shift;my$lines=shift || 10;my$stripped=$self->decoded->stripSignature(max_lines=>$lines);$self->body($stripped)if defined$stripped;$stripped}sub tidy_body(;$) {my$self=shift;my$body=$self->body or return;my@body=$body->lines;shift@body while@body && $body[0]=~ m/^\s*$/;pop@body while@body && $body[-1]=~ m/^\s*$/;return$body if$body->nrLines==@body;my$new=Mail::Message::Body::Lines->new(based_on=>$body,data=>\@body);$self->body($new)}sub smtpsend(@) {my ($self,%args)=@_;my$from=$args{MailFrom}|| $ENV{MAILADDRESS}|| $ENV{USER}|| 'unknown';$args{helo}||=delete$args{Hello};$args{port}||=delete$args{Port};$args{smtp_debug}||=delete$args{Debug};my$host=$args{Host};unless(defined$host){my$hosts=$ENV{SMTPHOSTS};$host=(split /\:/,$hosts)[0]if defined$hosts}$args{host}=$host;$self->send(via=>'smtp',%args)}sub as_mbox_string() {my$self=shift;my$mboxmsg=Mail::Box::Mbox->coerce($self);my$buffer='';my$file=Mail::Box::FastScalar->new(\$buffer);$mboxmsg->print($file);$buffer}BEGIN {no warnings;*Mail::Internet::new=sub (@) {my$class=shift;Mail::Message::Replace::MailInternet->new(@_)}}sub isa($) {my ($thing,$class)=@_;return 1 if$class eq 'Mail::Internet';$thing->SUPER::isa($class)}sub coerce() {confess}1;
MAIL_MESSAGE_REPLACE_MAILINTERNET

$fatpacked{"Mail/Message/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TEST';
  package Mail::Message::Test;use vars '$VERSION';$VERSION='3.008';use base 'Exporter';use strict;use warnings;use File::Copy 'copy';use List::Util 'first';use IO::File;use File::Spec;use Cwd qw(getcwd);use Sys::Hostname qw(hostname);use Test::More;our@EXPORT=qw/compare_message_prints reproducable_text $raw_html_data $crlf_platform/;our$crlf_platform=$^O =~ m/mswin32/i;sub compare_message_prints($$$) {my ($first,$second,$label)=@_;if($crlf_platform){$first =~ s/Content-Length: (\d+)/Content-Length: <removed>/g;$second =~ s/Content-Length: (\d+)/Content-Length: <removed>/g}is($first,$second,$label)}sub reproducable_text($) {my$text=shift;my@lines=split /^/m,$text;for (@lines){s/((?:references|message-id|date|content-length)\: ).*/$1<removed>/i;s/boundary-\d+/boundary-<removed>/g}join '',@lines}our$raw_html_data=<<'TEXT';1;
  <HTML>
  <HEAD>
  <TITLE>My home page</TITLE>
  </HEAD>
  <BODY BGCOLOR=red>
  
  <H1>Life according to Brian</H1>
  
  This is normal text, but not in a paragraph.<P>New paragraph
  in a bad way.
  
  And this is just a continuation.  When texts get long, they must be
  auto-wrapped; and even that is working already.
  
  <H3>Silly subsection at once</H3>
  <H1>and another chapter</H1>
  <H2>again a section</H2>
  <P>Normal paragraph, which contains an <IMG
  SRC=image.gif>, some
  <I>italics with linebreak
  </I> and <TT>code</TT>
  
  <PRE>
  And now for the preformatted stuff
     it should stay as it was
        even   with   strange blanks
    and indentations
  </PRE>
  
  And back to normal text...
  <UL>
  <LI>list item 1
      <OL>
      <LI>list item 1.1
      <LI>list item 1.2
      </OL>
  <LI>list item 2
  </UL>
  </BODY>
  </HTML>
  TEXT
MAIL_MESSAGE_TEST

$fatpacked{"Mail/Message/TransferEnc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC';
  package Mail::Message::TransferEnc;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Reporter';use strict;use warnings;my%encoder=(base64=>'Mail::Message::TransferEnc::Base64' ,'7bit'=>'Mail::Message::TransferEnc::SevenBit' ,'8bit'=>'Mail::Message::TransferEnc::EightBit' ,'quoted-printable'=>'Mail::Message::TransferEnc::QuotedPrint');sub create($@) {my ($class,$type)=(shift,shift);my$encoder=$encoder{lc$type};unless($encoder){$class->new(@_)->log(WARNING=>"No decoder for transfer encoding $type.");return}eval "require $encoder";if($@){$class->new(@_)->log(ERROR=>"Decoder for transfer encoding $type does not work:\n$@");return}$encoder->new(@_)}sub addTransferEncoder($$) {my ($class,$type,$encoderclass)=@_;$encoder{lc$type}=$encoderclass;$class}sub name {shift->notImplemented}sub check($@) {shift->notImplemented}sub decode($@) {shift->notImplemented}sub encode($) {shift->notImplemented}1;
MAIL_MESSAGE_TRANSFERENC

$fatpacked{"Mail/Message/TransferEnc/Base64.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC_BASE64';
  package Mail::Message::TransferEnc::Base64;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::TransferEnc';use strict;use warnings;use MIME::Base64;sub name() {'base64'}sub check($@) {my ($self,$body,%args)=@_;$body}sub decode($@) {my ($self,$body,%args)=@_;my$lines=decode_base64($body->string);unless($lines){$body->transferEncoding('none');return$body}my$bodytype =defined$args{result_type}? $args{result_type}: $body->isBinary ? 'Mail::Message::Body::File' : ref$body;$bodytype->new (based_on=>$body ,transfer_encoding=>'none' ,data=>$lines)}sub encode($@) {my ($self,$body,%args)=@_;my$bodytype=$args{result_type}|| ref$body;$bodytype->new (based_on=>$body ,checked=>1 ,transfer_encoding=>'base64' ,data=>encode_base64($body->string))}1;
MAIL_MESSAGE_TRANSFERENC_BASE64

$fatpacked{"Mail/Message/TransferEnc/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC_BINARY';
  package Mail::Message::TransferEnc::Binary;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::TransferEnc';use strict;use warnings;sub name() {'binary'}sub check($@) {my ($self,$body,%args)=@_;$body}sub decode($@) {my ($self,$body,%args)=@_;$body->transferEncoding('none');$body}sub encode($@) {my ($self,$body,%args)=@_;my@lines;my$changes=0;for ($body->lines){$changes++ if s/[\000\013]//g;push@lines,$_}unless($changes){$body->transferEncoding('none');return$body}my$bodytype=$args{result_type}|| ref($self->load);$bodytype->new (based_on=>$self ,transfer_encoding=>'none' ,data=>\@lines)}1;
MAIL_MESSAGE_TRANSFERENC_BINARY

$fatpacked{"Mail/Message/TransferEnc/EightBit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC_EIGHTBIT';
  package Mail::Message::TransferEnc::EightBit;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::TransferEnc';use strict;use warnings;sub name() {'8bit'}sub check($@) {my ($self,$body,%args)=@_;$body}sub decode($@) {my ($self,$body,%args)=@_;$body->transferEncoding('none');$body}sub encode($@) {my ($self,$body,%args)=@_;my@lines;my$changes=0;for ($body->lines){$changes++ if s/[\000\013]//g;$changes++ if length > 997;push@lines,substr($_,0,996,'')."\n" while length > 997;push@lines,$_}unless($changes){$body->transferEncoding('8bit');return$body}my$bodytype=$args{result_type}|| ref$body;$bodytype->new (based_on=>$body ,transfer_encoding=>'8bit' ,data=>\@lines)}1;
MAIL_MESSAGE_TRANSFERENC_EIGHTBIT

$fatpacked{"Mail/Message/TransferEnc/QuotedPrint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC_QUOTEDPRINT';
  package Mail::Message::TransferEnc::QuotedPrint;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::TransferEnc';use strict;use warnings;use MIME::QuotedPrint;sub name() {'quoted-printable'}sub check($@) {my ($self,$body,%args)=@_;$body}sub decode($@) {my ($self,$body,%args)=@_;my$bodytype=$args{result_type}|| ref$body;$bodytype->new (based_on=>$body ,transfer_encoding=>'none' ,data=>decode_qp($body->string))}sub encode($@) {my ($self,$body,%args)=@_;my$bodytype=$args{result_type}|| ref$body;$bodytype->new (based_on=>$body ,transfer_encoding=>'quoted-printable' ,data=>encode_qp($body->string))}1;
MAIL_MESSAGE_TRANSFERENC_QUOTEDPRINT

$fatpacked{"Mail/Message/TransferEnc/SevenBit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_TRANSFERENC_SEVENBIT';
  package Mail::Message::TransferEnc::SevenBit;use vars '$VERSION';$VERSION='3.008';use base 'Mail::Message::TransferEnc';use strict;use warnings;sub name() {'7bit'}sub check($@) {my ($self,$body,%args)=@_;$body}sub decode($@) {my ($self,$body,%args)=@_;$body->transferEncoding('none');$body}sub encode($@) {my ($self,$body,%args)=@_;my@lines;my$changes=0;for ($body->lines){$changes++ if s/([^\000-\127])/chr(ord($1) & 0x7f)/ge;$changes++ if s/[\000\013]//g;$changes++ if length > 997;push@lines,substr($_,0,996,'')."\n" while length > 997;push@lines,$_}unless($changes){$body->transferEncoding('7bit');return$body}my$bodytype=$args{result_type}|| ref$body;$bodytype->new (based_on=>$body ,transfer_encoding=>'7bit' ,data=>\@lines)}1;
MAIL_MESSAGE_TRANSFERENC_SEVENBIT

$fatpacked{"Mail/Message/Wrapper/SpamAssassin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_MESSAGE_WRAPPER_SPAMASSASSIN';
  package Mail::Message::Wrapper::SpamAssassin;use vars '$VERSION';$VERSION='3.007';use base 'Mail::SpamAssassin::Message';use strict;use warnings;use Carp;use Mail::Message::Body;BEGIN {my$v=$Mail::SpamAssassin::VERSION;die "ERROR: spam-assassin version $v is not supported (only versions 2.x)\n" if$v >= 3.0}sub new(@) {my ($class,$message,%args)=@_;$_->delete for$message->head->spamGroups('SpamAssassin');$class->SUPER::new({message=>$message})->init(\%args)}sub init($) {shift}sub create_new() {croak "Should not be used"}sub get($) {$_[0]->get_header($_[1])}sub get_header($) {my ($self,$name)=@_;my$head=$self->get_mail_object->head;return map {$_->unfoldedBody}$head->get($name)if wantarray;my$field=$head->get($name);defined$field ? $field->unfoldedBody : undef}sub get_pristine_header($) {my ($self,$name)=@_;my$field=$self->get_mail_object->head->get($name);defined$field ? $field->foldedBody : undef}sub put_header($$) {my ($self,$name,$value)=@_;my$head=$self->get_mail_object->head;$value =~ s/\s{2,}/ /g;$value =~ s/\s*$//;return ()unless length$value;$head->add($name=>$value)}sub get_all_headers($) {my$head=shift->get_mail_object->head;"$head"}sub replace_header($$) {my$head=shift->get_mail_object->head;my ($name,$value)=@_;$head->set($name,$value)}sub delete_header($) {my$head=shift->get_mail_object->head;my$name=shift;$head->delete($name)}sub get_body() {shift->get_mail_object->body->lines}sub get_pristine() {shift->get_mail_object->head->string}sub replace_body($) {my ($self,$data)=@_;my$body=Mail::Message::Body->new(data=>$data);$self->get_mail_object->storeBody($body)}sub replace_original_message($) {my ($self,$lines)=@_;die "We will not replace the message.  Use report_safe = 0\n"}1;
MAIL_MESSAGE_WRAPPER_SPAMASSASSIN

$fatpacked{"Mail/Reporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_REPORTER';
  package Mail::Reporter;use vars '$VERSION';$VERSION='3.008';use strict;use warnings;use Carp;use Scalar::Util 'dualvar';my@levelname=(undef,qw(DEBUG NOTICE PROGRESS WARNING ERROR NONE INTERNAL));my%levelprio=(ERRORS=>5,WARNINGS=>4,NOTICES=>2);for(my$l=1;$l < @levelname;$l++){$levelprio{$levelname[$l]}=$l;$levelprio{$l}=$l}sub new(@) {my$class=shift;(bless {MR_log=>1,MR_trace=>1},$class)->init({@_})}my($default_log,$default_trace,$trace_callback);sub init($) {my ($self,$args)=@_;$self->{MR_log}=$levelprio{$args->{log}|| $default_log};$self->{MR_trace}=$levelprio{$args->{trace}|| $default_trace};$self}sub _trace_warn($$$) {my ($who,$level,$text)=@_;warn "$level: $text\n"}sub defaultTrace(;$$) {my$thing=shift;return ($default_log,$default_trace)unless @_;my$level=shift;my$prio=$thing->logPriority($level)or croak "Unknown trace-level $level.";if(!@_){$default_log=$default_trace=$prio;$trace_callback=\&_trace_warn}elsif(ref $_[0]){$default_log=$thing->logPriority('NONE');$default_trace=$prio;$trace_callback=shift}else {$default_log=$prio;$default_trace=$thing->logPriority(shift);$trace_callback=\&_trace_warn}($default_log,$default_trace)}__PACKAGE__->defaultTrace('WARNINGS');sub trace(;$$) {my$self=shift;return$self->logPriority($self->{MR_trace})unless @_;my$level=shift;my$prio=$levelprio{$level}or croak "Unknown trace-level $level.";$self->{MR_trace}=$prio}sub log(;$@) {my$thing=shift;if(ref$thing){return$thing->logPriority($thing->{MR_log})unless @_;my$level=shift;my$prio=$levelprio{$level}or croak "Unknown log-level $level";return$thing->{MR_log}=$prio unless @_;my$text=join '',@_;$trace_callback->($thing,$level,$text)if$prio >= $thing->{MR_trace};use Carp;$thing->{MR_trace}or confess;push @{$thing->{MR_report}[$prio]},$text if$prio >= $thing->{MR_log}}else {my$level=shift;my$prio=$levelprio{$level}or croak "Unknown log-level $level";$trace_callback->($thing,$level,join('',@_))if$prio >= $default_trace}$thing}sub report(;$) {my$self=shift;my$reports=$self->{MR_report}|| return ();if(@_){my$level=shift;my$prio=$levelprio{$level}or croak "Unknown report level $level.";return$reports->[$prio]? @{$reports->[$prio]}: ()}my@reports;for(my$prio=1;$prio < @$reports;$prio++){next unless$reports->[$prio];my$level=$levelname[$prio];push@reports,map {[$level,$_ ]}@{$reports->[$prio]}}@reports}sub addReport($) {my ($self,$other)=@_;my$reports=$other->{MR_report}|| return ();for(my$prio=1;$prio < @$reports;$prio++){push @{$self->{MR_report}[$prio]},@{$reports->[$prio]}if exists$reports->[$prio]}$self}sub reportAll(;$) {my$self=shift;map {[$self,@$_ ]}$self->report(@_)}sub errors(@) {shift->report('ERRORS')}sub warnings(@) {shift->report('WARNINGS')}sub notImplemented(@) {my$self=shift;my$package=ref$self || $self;my$sub=(caller 1)[3];$self->log(ERROR=>"Package $package does not implement $sub.");confess "Please warn the author, this shouldn't happen."}sub logPriority($) {my$level=$levelprio{$_[1]}or return undef;dualvar$level,$levelname[$level]}sub logSettings() {my$self=shift;(log=>$self->{MR_log},trace=>$self->{MR_trace})}sub AUTOLOAD(@) {my$thing=shift;our$AUTOLOAD;my$class=ref$thing || $thing;(my$method=$AUTOLOAD)=~ s/^.*\:\://;$Carp::MaxArgLen=20;confess "Method $method() is not defined for a $class.\n"}sub DESTROY {shift}1;
MAIL_REPORTER

$fatpacked{"Mail/Send.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_SEND';
  package Mail::Send;use vars '$VERSION';$VERSION='2.21';use strict;use Mail::Mailer ();sub Version {our$VERSION}sub new(@) {my ($class,%attr)=@_;my$self=bless {},$class;while(my($key,$value)=each%attr){$key=lc$key;$self->$key($value)}$self}sub set($@) {my ($self,$hdr,@values)=@_;$self->{$hdr}=[@values ]if@values;@{$self->{$hdr}|| []}}sub add($@) {my ($self,$hdr,@values)=@_;push @{$self->{$hdr}},@values}sub delete($) {my($self,$hdr)=@_;delete$self->{$hdr}}sub to {my$self=shift;$self->set('To',@_)}sub cc {my$self=shift;$self->set('Cc',@_)}sub bcc {my$self=shift;$self->set('Bcc',@_)}sub subject {my$self=shift;$self->set('Subject',join (' ',@_))}sub open(@) {my$self=shift;Mail::Mailer->new(@_)->open($self)}1;
MAIL_SEND

$fatpacked{"Mail/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_SERVER';
  package Mail::Server;use vars '$VERSION';$VERSION='3.007';use base 'Mail::Reporter';use strict;use warnings;1;
MAIL_SERVER

$fatpacked{"Mail/Transport.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT';
  package Mail::Transport;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Reporter';use strict;use warnings;use Carp;use File::Spec;my%mailers=(exim=>'::Exim' ,imap=>'::IMAP4' ,imap4=>'::IMAP4' ,mail=>'::Mailx' ,mailx=>'::Mailx' ,pop=>'::POP3' ,pop3=>'::POP3' ,postfix=>'::Sendmail' ,qmail=>'::Qmail' ,sendmail=>'::Sendmail' ,smtp=>'::SMTP');sub new(@) {my$class=shift;return$class->SUPER::new(@_)unless$class eq __PACKAGE__ || $class eq "Mail::Transport::Send";my%args=@_;my$via=lc($args{via}|| '')or croak "No transport protocol provided";$via='Mail::Transport'.$mailers{$via}if exists$mailers{$via};eval "require $via";return undef if $@;$via->new(@_)}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);$self->{MT_hostname}=defined$args->{hostname}? $args->{hostname}: 'localhost';$self->{MT_port}=$args->{port};$self->{MT_username}=$args->{username};$self->{MT_password}=$args->{password};$self->{MT_interval}=$args->{interval}|| 30;$self->{MT_retry}=$args->{retry}|| -1;$self->{MT_timeout}=$args->{timeout}|| 120;$self->{MT_proxy}=$args->{proxy};if(my$exec=$args->{executable}|| $args->{proxy}){$self->{MT_exec}=$exec;$self->log(WARNING=>"Avoid program abuse: specify an absolute path for $exec.")unless File::Spec->file_name_is_absolute($exec);unless(-x $exec){$self->log(WARNING=>"Executable $exec does not exist.");return undef}}$self}sub remoteHost() {my$self=shift;@$self{qw/MT_hostname MT_port MT_username MT_password/ }}sub retry() {my$self=shift;@$self{qw/MT_interval MT_retry MT_timeout/ }}my@safe_directories =qw(/usr/local/bin /usr/bin /bin /sbin /usr/sbin /usr/lib);sub findBinary($@) {my ($self,$name)=(shift,shift);return$self->{MT_exec}if exists$self->{MT_exec};for (@_,@safe_directories){my$fullname=File::Spec->catfile($_,$name);return$fullname if -x $fullname}undef}1;
MAIL_TRANSPORT

$fatpacked{"Mail/Transport/Exim.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_EXIM';
  package Mail::Transport::Exim;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport::Send';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$args->{via}='exim';$self->SUPER::init($args)or return;$self->{MTS_program}=$args->{proxy}|| (-x '/usr/sbin/exim4' ? '/usr/sbin/exim4' : undef)|| $self->findBinary('exim','/usr/exim/bin')|| return;$self}sub trySend($@) {my ($self,$message,%args)=@_;my$from=$args{from}|| $message->sender;$from=$from->address if ref$from && $from->isa('Mail::Address');my@to=map {$_->address}$self->destinations($message,$args{to});my$program=$self->{MTS_program};if(open(MAILER,'|-')==0){{exec$program,'-i','-f',$from,@to}$self->log(NOTICE=>"Errors when opening pipe to $program: $!");exit 1}$self->putContent($message,\*MAILER,undisclosed=>1);unless(close MAILER){$self->log(ERROR=>"Errors when closing Exim mailer $program: $!");$? ||=$!;return 0}1}1;
MAIL_TRANSPORT_EXIM

$fatpacked{"Mail/Transport/Mailx.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_MAILX';
  package Mail::Transport::Mailx;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport::Send';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$args->{via}='mailx';$self->SUPER::init($args)or return;$self->{MTM_program}=$args->{proxy}|| $self->findBinary('mailx')|| $self->findBinary('Mail')|| $self->findBinary('mail')|| return;$self->{MTM_style}=defined$args->{style}? $args->{style}: $^O =~ m/linux|freebsd|bsdos|netbsd|openbsd/ ? 'BSD' : 'RFC822';$self}sub _try_send_bsdish($$) {my ($self,$message,$args)=@_;my@options=('-s'=>$message->subject);{local $"=',';my@cc=map {$_->format}$message->cc;push@options,('-c'=>"@cc")if@cc;my@bcc=map {$_->format}$message->bcc;push@options,('-b'=>"@bcc")if@bcc}my@to=map {$_->format}$message->to;my$program=$self->{MTM_program};if((open MAILER,'|-')==0){close STDOUT;{exec$program,@options,@to}$self->log(NOTICE=>"Cannot start contact to $program: $!");exit 1}$self->putContent($message,\*MAILER,body_only=>1);my$msgid=$message->messageId;if(close MAILER){$self->log(PROGRESS=>"Message $msgid send.")}else {$self->log(ERROR=>"Sending via mailx mailer $program failed: $! ($?)");return 0}1}sub trySend($@) {my ($self,$message,%args)=@_;return$self->_try_send_bsdish($message,\%args)if$self->{MTM_style}eq 'BSD';my$program=$self->{MTM_program};unless(open MAILER,'|-',$program,'-t'){$self->log(NOTICE=>"Cannot start contact to $program: $!");return 0}$self->putContent($message,\*MAILER);unless(close MAILER){$self->log(ERROR=>"Sending via mailx mailer $program failed: $! ($?)");return 0}1}1;
MAIL_TRANSPORT_MAILX

$fatpacked{"Mail/Transport/Qmail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_QMAIL';
  package Mail::Transport::Qmail;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport::Send';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$args->{via}='qmail';$self->SUPER::init($args)or return;$self->{MTM_program}=$args->{proxy}|| $self->findBinary('qmail-inject','/var/qmail/bin')|| return;$self}sub trySend($@) {my ($self,$message,%args)=@_;my$program=$self->{MTM_program};if(open(MAILER,'|-')==0){{exec$program}$self->log(NOTICE=>"Errors when opening pipe to $program: $!");exit 1}$self->putContent($message,\*MAILER,undisclosed=>1);unless(close MAILER){$self->log(ERROR=>"Errors when closing Qmail mailer $program: $!");$? ||=$!;return 0}1}1;
MAIL_TRANSPORT_QMAIL

$fatpacked{"Mail/Transport/Receive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_RECEIVE';
  package Mail::Transport::Receive;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport';use strict;use warnings;sub receive(@) {shift->notImplemented}1;
MAIL_TRANSPORT_RECEIVE

$fatpacked{"Mail/Transport/SMTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_SMTP';
  package Mail::Transport::SMTP;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport::Send';use strict;use warnings;use Net::SMTP;sub init($) {my ($self,$args)=@_;my$hosts=$args->{hostname};unless($hosts){require Net::Config;$hosts=$Net::Config::NetConfig{smtp_hosts};undef$hosts unless @$hosts;$args->{hostname}=$hosts}$args->{via}||='smtp';$args->{port}||='25';$self->SUPER::init($args)or return;my$helo=$args->{helo}|| eval {require Net::Config;$Net::Config::NetConfig{inet_domain}}|| eval {require Net::Domain;Net::Domain::hostfqdn()};$self->{MTS_net_smtp_opts}=+{Hello=>$helo ,Debug=>($args->{smtp_debug}|| 0)};$self->{MTS_esmtp_options}=$args->{esmtp_options};$self->{MTS_from}=$args->{from};$self}sub trySend($@) {my ($self,$message,%args)=@_;my%send_options=(%{$self->{MTS_esmtp_options}|| {}},%{$args{esmtp_options}|| {}});my$from=$args{from}|| $self->{MTS_from}|| $message->sender || '<>';$from=$from->address if ref$from && $from->isa('Mail::Address');!defined$args{To}or $self->log(WARNING=>"Use option `to' to overrule the destination: `To' refers to a field");my@to=map $_->address,$self->destinations($message,$args{to});unless(@to){$self->log(NOTICE=>'No addresses found to send the message to, no connection made');return 1}my@headers;require IO::Lines;my$lines=IO::Lines->new(\@headers);$message->head->printUndisclosed($lines);if(wantarray){my$server;return (0,500,"Connection Failed","CONNECT",0)unless$server=$self->contactAnyServer;return (0,$server->code,$server->message,'FROM',$server->quit)unless$server->mail($from,%send_options);for (@to){next if$server->to($_);return (0,$server->code,$server->message,"To $_",$server->quit)}$server->data;$server->datasend($_)for@headers;my$bodydata=$message->body->file;if(ref$bodydata eq 'GLOB'){$server->datasend($_)while <$bodydata>}else {while(my$l=$bodydata->getline){$server->datasend($l)}}$server->dataend or return (0,$server->code,$server->message,'DATA',$server->quit);my$accept=($server->message)[-1];chomp$accept;my$rc=$server->quit;return ($rc,$server->code,$server->message,'QUIT',$rc,$accept)}my$server;return 0 unless$server=$self->contactAnyServer;$server->quit,return 0 unless$server->mail($from,%send_options);for (@to){next if$server->to($_);$server->quit;return 0}$server->data;$server->datasend($_)for@headers;my$bodydata=$message->body->file;if(ref$bodydata eq 'GLOB'){$server->datasend($_)while <$bodydata>}else {while(my$l=$bodydata->getline){$server->datasend($l)}}$server->quit,return 0 unless$server->dataend;$server->quit}sub contactAnyServer() {my$self=shift;my ($enterval,$count,$timeout)=$self->retry;my ($host,$port,$username,$password)=$self->remoteHost;my@hosts=ref$host ? @$host : $host;for my$host (@hosts){my$server=$self->tryConnectTo ($host,Port=>$port,,%{$self->{MTS_net_smtp_opts}},Timeout=>$timeout);defined$server or next;$self->log(PROGRESS=>"Opened SMTP connection to $host.");if(defined$username){if($server->auth($username,$password)){$self->log(PROGRESS=>"$host: Authentication succeeded.")}else {$self->log(ERROR=>"Authentication failed.");return undef}}return$server}undef}sub tryConnectTo($@) {my ($self,$host)=(shift,shift);Net::SMTP->new($host,@_)}1;
MAIL_TRANSPORT_SMTP

$fatpacked{"Mail/Transport/Send.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_SEND';
  package Mail::Transport::Send;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport';use strict;use warnings;use Carp;use File::Spec;use Errno 'EAGAIN';sub new(@) {my$class=shift;return$class->SUPER::new(@_)if$class ne __PACKAGE__;require Mail::Transport::Sendmail;Mail::Transport::Sendmail->new(@_)}sub send($@) {my ($self,$message,%args)=@_;unless($message->isa('Mail::Message')){$message=Mail::Message->coerce($message);confess "Unable to coerce object into Mail::Message." unless defined$message}return 1 if$self->trySend($message,%args);return 0 unless $?==EAGAIN;my ($interval,$retry)=$self->retry;$interval=$args{interval}if exists$args{interval};$retry=$args{retry}if exists$args{retry};while($retry!=0){sleep$interval;return 1 if$self->trySend($message,%args);return 0 unless $?==EAGAIN;$retry--}0}sub trySend($@) {my$self=shift;$self->log(ERROR=>"Transporters of type ".ref($self)." cannot send.")}sub putContent($$@) {my ($self,$message,$fh,%args)=@_;if($args{body_only}){$message->body->print($fh)}elsif($args{undisclosed}){$message->Mail::Message::print($fh)}else {$message->head->printUndisclosed($fh);$message->body->print($fh)}$self}sub destinations($;$) {my ($self,$message,$overrule)=@_;my@to;if(defined$overrule){my@addr=ref$overrule eq 'ARRAY' ? @$overrule : ($overrule);@to=map {ref $_ && $_->isa('Mail::Address')? ($_): Mail::Address->parse($_)}@addr}elsif(my@rgs=$message->head->resentGroups){@to=$rgs[0]->destinations;$self->log(WARNING=>"Resent group does not specify a destination"),return ()unless@to}else {@to=$message->destinations;$self->log(WARNING=>"Message has no destination"),return ()unless@to}@to}1;
MAIL_TRANSPORT_SEND

$fatpacked{"Mail/Transport/Sendmail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_TRANSPORT_SENDMAIL';
  package Mail::Transport::Sendmail;use vars '$VERSION';$VERSION='3.004';use base 'Mail::Transport::Send';use strict;use warnings;use Carp;sub init($) {my ($self,$args)=@_;$args->{via}='sendmail';$self->SUPER::init($args)or return;$self->{MTS_program}=$args->{proxy}|| $self->findBinary('sendmail')|| return;$self->{MTS_opts}=$args->{sendmail_options}|| [];$self}sub trySend($@) {my ($self,$message,%args)=@_;my$program=$self->{MTS_program};if(open(MAILER,'|-')==0){my$options=$args{sendmail_options}|| [];my@to=map {$_->address}$self->destinations($message,$args{to});{exec$program,'-i',@{$self->{MTS_opts}},@$options,@to}$self->log(NOTICE=>"Errors when opening pipe to $program: $!");exit 1}$self->putContent($message,\*MAILER,undisclosed=>1);unless(close MAILER){$self->log(NOTICE=>"Errors when closing sendmail mailer $program: $!");$? ||=$!;return 0}1}1;
MAIL_TRANSPORT_SENDMAIL

$fatpacked{"Mail/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIL_UTIL';
  package Mail::Util;use vars '$VERSION';$VERSION='2.21';use base 'Exporter';use strict;use Carp;our@EXPORT_OK=qw(read_mbox maildomain mailaddress);sub Version {our$VERSION}my ($domain,$mailaddress);my@sendmailcf=qw(/etc /etc/sendmail /etc/ucblib /etc/mail /usr/lib /var/adm/sendmail);sub read_mbox($) {my$file=shift;local*FH;open FH,'<',$file or croak "cannot open '$file': $!\n";local $_;my@mbox;my$mail=[];my$blank=1;while(<FH>){if($blank && /^From .*\d{4}/){push@mbox,$mail if @$mail;$mail=[$_ ];$blank=0}else {$blank=m/^$/ ? 1 : 0;push @$mail,$_}}push@mbox,$mail if @$mail;close FH;wantarray ? @mbox : \@mbox}sub maildomain() {return$domain if defined$domain;$domain=$ENV{MAILDOMAIN}and return$domain;my$config=(grep -r,map {"$_/sendmail.cf"}@sendmailcf)[0];local*CF;local $_;if(defined$config && open CF,'<',$config){my%var;while(<CF>){if(my ($v,$arg)=/^D([a-zA-Z])([\w.\$\-]+)/){$arg =~ s/\$([a-zA-Z])/exists $var{$1} ? $var{$1} : '$'.$1/eg;$var{$v}=$arg}}close CF;$domain=$var{j}if defined$var{j};$domain=$var{M}if defined$var{M};$domain=$1 if$domain && $domain =~ m/([A-Za-z0-9](?:[\.\-A-Za-z0-9]+))/;return$domain if defined$domain && $domain !~ /\$/}if(open CF,'<',"/usr/lib/smail/config"){while(<CF>){if(/\A\s*hostnames?\s*=\s*(\S+)/){$domain=(split /\:/,$1)[0];last}}close CF;return$domain if defined$domain}if(eval {require Net::SMTP}){for my$host (qw(mailhost localhost)){my$smtp=eval {Net::SMTP->new($host,Timeout=>5)};if(defined$smtp){$domain=$smtp->domain;$smtp->quit;last}}}$domain=Net::Domain::domainname()if!defined$domain && eval {require Net::Domain};$domain ||="localhost"}sub mailaddress(;$) {$mailaddress=shift if @_;return$mailaddress if defined$mailaddress;$mailaddress=$ENV{MAILADDRESS};unless($mailaddress || $^O ne 'MacOS'){require Mac::InternetConfig;no strict;Mac::InternetConfig->import;$mailaddress=$InternetConfig{kICEmail()}}$mailaddress ||=$ENV{USER}|| $ENV{LOGNAME}|| eval {getpwuid $>}|| "postmaster";$mailaddress .= '@' .maildomain if$mailaddress !~ /\@/;$mailaddress =~ s/(^.*<|>.*$)//g;$mailaddress}1;
MAIL_UTIL

$fatpacked{"MailTools.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAILTOOLS';
  package MailTools;use vars '$VERSION';$VERSION='2.21';1;
MAILTOOLS

$fatpacked{"Object/Realize/Later.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OBJECT_REALIZE_LATER';
  package Object::Realize::Later;use vars '$VERSION';$VERSION='0.21';use Carp;use Scalar::Util 'weaken';use warnings;use strict;no strict 'refs';my$named='ORL_realization_method';my$helper='ORL_fake_realized';sub init_code($) {my$args=shift;<<INIT_CODE}sub isa_code($) {my$args=shift;<<ISA_CODE}sub can_code($) {my$args=shift;my$becomes=$args->{becomes};<<CAN_CODE}sub AUTOLOAD_code($) {my$args=shift;<<'CODE1' .($args->{believe_caller}? '' : <<NOT_BELIEVE).<<CODE2}sub realize_code($) {my$args=shift;my$pkg=__PACKAGE__;my$argspck=join "'\n         , '",%$args;<<REALIZE_CODE .($args->{warn_realization}? <<'WARN' : '').<<REALIZE_CODE}sub will_realize_code($) {my$args=shift;my$becomes=$args->{becomes};<<WILL_CODE}sub realize(@) {my ($class,%args)=@_;my$object=${$args{ref_object}};my$realize=$args{realize};my$already=$class->realizationOf($object);if(defined$already && ref$already ne ref$object){if($args{warn_realize_again}){my (undef,$filename,$line)=@{$args{caller}};warn "Attempt to realize object again: old reference caught at $filename line $line.\n"}return ${$args{ref_object}}=$already}my$loaded=ref$realize ? $realize->($object): $object->$realize;warn "Load produces a ".ref($loaded)." where a $args{becomes} is expected.\n" unless$loaded->isa($args{becomes});${$args{ref_object}}=$loaded;$class->realizationOf($object,$loaded)}my%realization;sub realizationOf($;$) {my ($class,$object)=(shift,shift);my$unique="$object";if(@_){$realization{$unique}=shift;weaken$realization{$unique}}$realization{$unique}}sub import(@) {my ($class,%args)=@_;confess "Require 'becomes'" unless$args{becomes};confess "Require 'realize'" unless$args{realize};$args{class}=caller;$args{warn_realization}||=0;$args{warn_realize_again}||=0;$args{source_module}||=$args{becomes};if(ref$args{realize}eq 'CODE'){my$named_method="$args{class}::$named";*{$named_method}=$args{realize};$args{realize}=$named_method}my$args=\%args;my$eval =init_code($args).isa_code($args).can_code($args).AUTOLOAD_code($args).realize_code($args).will_realize_code($args);eval$eval;die $@ if $@;1}1;
    package $args->{class};
    require $args->{source_module};
  
    my \$$helper = bless {}, '$args->{becomes}';
  INIT_CODE
    sub isa(\$)
    {   my (\$thing, \$what) = \@_;
        return 1 if \$thing->SUPER::isa(\$what);  # real dependency?
        \$$helper\->isa(\$what);
    }
  ISA_CODE
    sub can(\$)
    {   my (\$thing, \$method) = \@_;
        my \$func;
        \$func = \$thing->SUPER::can(\$method)
           and return \$func;
  
        \$func = \$$helper\->can(\$method)
           or return;
  
        # wrap func() to trigger load if needed.
        sub { ref \$thing
              ? \$func->(\$thing->forceRealize, \@_)
              : \$func->(\$thing, \@_)
            };
    }
  CAN_CODE
    our $AUTOLOAD;
    sub AUTOLOAD(@)
    {  my $call = substr $AUTOLOAD, rindex($AUTOLOAD, ':')+1;
       return if $call eq 'DESTROY';
  CODE1
  
       unless(\$$helper->can(\$call) || \$$helper->can('AUTOLOAD'))
       {   use Carp;
           croak "Unknown method \$call called";
       }
  NOT_BELIEVE
      # forward as class method if required
      shift and return $args->{becomes}->\$call( \@_ ) unless ref \$_[0];
  
       \$_[0]->forceRealize;
       my \$made = shift;
       \$made->\$call(\@_);
    }
  CODE2
    sub forceRealize(\$)
    {
  REALIZE_CODE
        require Carp;
        Carp::carp("Realization of $_[0]");
  WARN
        ${pkg}->realize
          ( ref_object => \\\${_[0]}
          , caller     => [ caller 1 ]
          , '$argspck'
          );
    }
  REALIZE_CODE
  sub willRealize() {'$becomes'}
  WILL_CODE
OBJECT_REALIZE_LATER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||=Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||=[@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"User/Identity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY';
  package User::Identity;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;use Carp;use overload '""'=>'fullName';my@attributes=qw/charset courtesy birth full_name formal_name firstname gender initials language nickname prefix surname titles/;sub init($) {my ($self,$args)=@_;exists$args->{$_}&& ($self->{'UI_'.$_}=delete$args->{$_})foreach@attributes;$self->SUPER::init($args)}sub type() {'user'}sub user() {shift}sub charset() {shift->{UI_charset}|| $ENV{LC_CTYPE}}sub nickname() {my$self=shift;$self->{UI_nickname}|| $self->name}sub firstname() {my$self=shift;$self->{UI_firstname}|| ucfirst$self->nickname}sub initials() {my$self=shift;return$self->{UI_initials}if defined$self->{UI_initials};if(my$firstname=$self->firstname){my$i='';while($firstname =~ m/(\w+)(\-)?/g){my ($part,$connect)=($1,$2);$connect ||='.';$part =~ m/^(chr|th|\w)/i;$i .= ucfirst(lc $1).$connect}return$i}}sub prefix() {shift->{UI_prefix}}sub surname() {shift->{UI_surname}}sub fullName() {my$self=shift;return$self->{UI_full_name}if defined$self->{UI_full_name};my ($first,$prefix,$surname)=@$self{qw/UI_firstname UI_prefix UI_surname/};$surname=ucfirst$self->nickname if defined$first &&!defined$surname;$first=$self->firstname if!defined$first && defined$surname;my$full=join ' ',grep {defined $_}($first,$prefix,$surname);$full=$self->firstname unless length$full;$full}sub formalName() {my$self=shift;return$self->{UI_formal_name}if defined$self->{UI_formal_name};my$initials=$self->initials;my$firstname=$self->{UI_firstname};$firstname="($firstname)" if defined$firstname;my$full=join ' ',grep {defined $_}$self->courtesy,$initials ,@$self{qw/UI_prefix UI_surname UI_titles/ }}my%male_courtesy =(mister=>'en' ,mr=>'en' ,sir=>'en' ,'de heer'=>'nl' ,mijnheer=>'nl' ,dhr=>'nl' ,herr=>'de');my%male_courtesy_default =(en=>'Mr.' ,nl=>'De heer' ,de=>'Herr');my%female_courtesy =(miss=>'en' ,ms=>'en' ,mrs=>'en' ,madam=>'en' ,mevr=>'nl' ,mevrouw=>'nl' ,frau=>'de');my%female_courtesy_default =(en=>'Madam' ,nl=>'Mevrouw' ,de=>'Frau');sub courtesy() {my$self=shift;return$self->{UI_courtesy}if defined$self->{UI_courtesy};my$table =$self->isMale ? \%male_courtesy_default : $self->isFemale ? \%female_courtesy_default : return undef;my$lang=lc$self->language;return$table->{$lang}if exists$table->{$lang};$lang =~ s/\..*//;return$table->{$lang}if exists$table->{$lang};$lang =~ s/[-_].*//;$table->{$lang}}sub language() {shift->{UI_language}|| 'en'}sub gender() {shift->{UI_gender}}sub isMale() {my$self=shift;if(my$gender=$self->{UI_gender}){return$gender =~ m/^[mh]/i}if(my$courtesy=$self->{UI_courtesy}){$courtesy=lc$courtesy;$courtesy =~ s/[^\s\w]//g;return 1 if exists$male_courtesy{$courtesy}}undef}sub isFemale() {my$self=shift;if(my$gender=$self->{UI_gender}){return$gender =~ m/^[vf]/i}if(my$courtesy=$self->{UI_courtesy}){$courtesy=lc$courtesy;$courtesy =~ s/[^\s\w]//g;return 1 if exists$female_courtesy{$courtesy}}undef}sub dateOfBirth() {shift->{UI_birth}}sub birth() {my$birth=shift->dateOfBirth;my$time;if($birth =~ m/^\s*(\d{4})[-\s]*(\d{2})[-\s]*(\d{2})\s*$/){return sprintf "%04d%02d%02d",$1,$2,$3}eval "require Date::Parse";unless($@){my ($day,$month,$year)=(Date::Parse::strptime($birth))[3,4,5];if(defined$year){return sprintf "%04d%02d%02d" ,($year + 1900),(defined$month ? $month+1 : 0),($day || 0)}}undef}sub age() {my$birth=shift->birth or return;my ($year,$month,$day)=$birth =~ m/^(\d{4})(\d\d)(\d\d)$/;my ($today,$tomonth,$toyear)=(localtime)[3,4,5];$tomonth++;my$age=$toyear+1900 - $year;$age-- if$month > $tomonth || ($month==$tomonth && $day >= $today);$age}sub titles() {shift->{UI_titles}}1;
USER_IDENTITY

$fatpacked{"User/Identity/Archive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_ARCHIVE';
  package User::Identity::Archive;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;sub type {"archive"}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args)or return;if(my$from=delete$args->{from}){$self->from($from)or return}$self}1;
USER_IDENTITY_ARCHIVE

$fatpacked{"User/Identity/Archive/Plain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_ARCHIVE_PLAIN';
  package User::Identity::Archive::Plain;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Archive';use strict;use warnings;use Carp;my%abbreviations=(user=>'User::Identity' ,email=>'Mail::Identity' ,location=>'User::Identity::Location' ,system=>'User::Identity::System' ,list=>'User::Identity::Collection::Emails');sub init($) {my ($self,$args)=@_;$self->SUPER::init($args)or return;my%only;if(my$only=delete$args->{only}){my@only=ref$only ? @$only : $only;$only{$_}++ for@only}while(my($k,$v)=each%abbreviations){$self->abbreviation($k,$v)unless keys%only &&!$only{$k}}if(my$abbrevs=delete$args->{abbreviations}){$abbrevs={@$abbrevs }if ref$abbrevs eq 'ARRAY';while(my($k,$v)=each %$abbrevs){$self->abbreviation($k,$v)unless keys%only &&!$only{$k}}}for (keys%only){warn "Option 'only' specifies undefined abbreviation '$_'\n" unless defined$self->abbreviation($_)}$self->{UIAP_items}={};$self->{UIAP_tabstop}=delete$args->{tabstop}|| 8;$self}sub from($@) {my ($self,$in,%args)=@_;my$verbose=$args{verbose}|| 0;my ($source,@lines);if(ref$in){($source,@lines)=ref$in eq 'ARRAY' ? ('array',@$in): ref$in eq 'GLOB' ? ('GLOB',<$in>): $in->isa('IO::Handle')? (ref$in,$in->getlines): confess "Cannot read from a ",ref$in,"\n"}elsif(open IN,"<",$in){$source="file $in";@lines=<IN>}else {warn "Cannot read archive from file $in: $!\n";return$self}print "reading data from $source\n" if$verbose;return$self unless@lines;my$tabstop=$args{tabstop}|| $self->defaultTabStop;$self->_set_lines($source,\@lines,$tabstop);while(my$starter=$self->_get_line){$self->_accept_line;my$indent=$self->_indentation($starter);print "  adding $starter" if$verbose > 1;my$item=$self->_collectItem($starter,$indent);$self->add($item->type=>$item)if defined$item}$self}sub _set_lines($$$) {my ($self,$source,$lines,$tab)=@_;$self->{UIAP_lines}=$lines;$self->{UIAP_source}=$source;$self->{UIAP_curtab}=$tab;$self->{UIAP_linenr}=0;$self}sub _get_line() {my$self=shift;my ($lines,$linenr,$line)=@$self{qw/UIAP_lines UIAP_linenr UIAP_line/};return$line if defined$line;$line='';while($linenr < @$lines){my$reading=$lines->[$linenr];$linenr++,next if$reading =~ m/^\s*\#/;$linenr++,next unless$reading =~ m/\S/;$line .= $reading;if($line =~ s/\\\s*$//){$linenr++;next}if($line =~ m/^\s*tabstop\s*\=\s*(\d+)/){$self->{UIAP_curtab}=$1;$line='';next}last}return ()unless length$line || $linenr < @$lines;$self->{UIAP_linenr}=$linenr;$self->{UIAP_line}=$line;$line}sub _accept_line() {my$self=shift;delete$self->{UIAP_line};$self->{UIAP_linenr}++}sub _location() {@{(shift)}{qw/UIAP_source UIAP_linenr/ }}sub _indentation($) {my ($self,$line)=@_;return -1 unless defined$line;my ($indent)=$line =~ m/^(\s*)/;return length($indent)unless index($indent,"\t")>= 0;my$column=0;my$tab=$self->{UIAP_curtab};my@chars=split //,$indent;while(my$char=shift@chars){$column++,next if$char eq ' ';$column=(int($column/$tab+0.0001)+1)*$tab}$column}sub _collectItem($$) {my ($self,$starter,$indent)=@_;my ($type,$name)=$starter =~ m/(\w+)\s*(.*?)\s*$/;my$class=$abbreviations{$type};my$skip=!defined$class;my (@fields,@items);while(1){my$line=$self->_get_line;my$this_indent=$self->_indentation($line);last if$this_indent <= $indent;$self->_accept_line;$line =~ s/[\r\n]+$//;next if$skip;my$next_line=$self->_get_line;my$next_indent=$self->_indentation($next_line);if($this_indent < $next_indent){my$item=$self->_collectItem($line,$this_indent);push@items,$item if defined$item}elsif($this_indent==$next_indent && $line =~ m/^\s*(\w*)\s*(\w+)\s*\=\s*(.*)/){my ($group,$name,$lookup)=($1,$2,$3);my$item;push@items,$item if defined$item}else {my ($group,$name)=$line =~ m/(\w+)\s*(.*)/;$name =~ s/\s*$//;push@fields,$group=>$name;next}}return ()unless@fields || @items;my$warn=0;my$warn_sub=$SIG{__WARN__};$SIG{__WARN__}=sub {$warn++;$warn_sub ? $warn_sub->(@_): print STDERR @_};my$item=$class->new(name=>$name,@fields);$SIG{__WARN__}=$warn_sub;if($warn){my ($source,$linenr)=$self->_location;$linenr -= 1;warn "  found in $source around line $linenr\n"}$item->add($_->type=>$_)foreach@items;$item}sub defaultTabStop(;$) {my$self=shift;@_ ? ($self->{UIAP_tabstop}=shift): $self->{UIAP_tabstop}}sub abbreviation($;$) {my ($self,$name)=(shift,shift);return$self->{UIAP_abbrev}{$name}unless @_;my$class=shift;return delete$self->{UIAP_abbrev}{$name}unless defined$class;eval "require $class";die "Class $class is not usable, because of errors:\n$@" if $@;$self->{UIAP_abbrev}{$name}=$class}sub abbreviations() {sort keys %{shift->{UIAP_abbrev}}}1;
USER_IDENTITY_ARCHIVE_PLAIN

$fatpacked{"User/Identity/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_COLLECTION';
  package User::Identity::Collection;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;use User::Identity;use Carp;use List::Util qw/first/;use overload '""'=>sub {my$self=shift;$self->name .": " .join(", ",sort map {$_->name}$self->roles)};use overload '@{}'=>sub {[shift->roles ]};sub type {"people"}sub init($) {my ($self,$args)=@_;defined($self->SUPER::init($args))or return;$self->{UIC_itype}=delete$args->{item_type}or die;$self->{UIC_roles}={};my$roles=$args->{roles};my@roles =!defined$roles ? (): ref$roles eq 'ARRAY' ? @$roles : $roles;$self->addRole($_)foreach@roles;$self}sub roles() {values %{shift->{UIC_roles}}}sub itemType {shift->{UIC_itype}}sub addRole(@) {my$self=shift;my$maintains=$self->itemType;my$role;if(ref $_[0]&& ref $_[0]ne 'ARRAY'){$role=shift;croak "ERROR: Wrong type of role for ".ref($self).": requires a $maintains but got a ".ref($role)unless$role->isa($maintains)}else {$role=$maintains->new(ref $_[0]? @{$_[0]}: @_);croak "ERROR: Cannot create a $maintains to add this to my collection." unless defined$role}$role->parent($self);$self->{UIC_roles}{$role->name}=$role;$role}sub removeRole($) {my ($self,$which)=@_;my$name=ref$which ? $which->name : $which;my$role=delete$self->{UIC_roles}{$name}or return ();$role->parent(undef);$role}sub renameRole($$$) {my ($self,$which,$newname)=@_;my$name=ref$which ? $which->name : $which;if(exists$self->{UIC_roles}{$newname}){$self->log(ERROR=>"Cannot rename $name into $newname: already exists");return ()}my$role=delete$self->{UIC_roles}{$name};unless(defined$role){$self->log(ERROR=>"Cannot rename $name into $newname: doesn't exist");return ()}$role->name($newname);$self->{UIC_roles}{$newname}=$role}sub sorted() {sort {$a->name cmp $b->name}shift->roles}sub find($) {my ($self,$select)=@_;!defined$select ? ($self->roles)[0]:!ref$select ? $self->{UIC_roles}{$select}: wantarray ? grep ({$select->($_,$self)}$self->roles): first {$select->($_,$self)}$self->roles}1;
USER_IDENTITY_COLLECTION

$fatpacked{"User/Identity/Collection/Emails.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_COLLECTION_EMAILS';
  package User::Identity::Collection::Emails;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Collection';use strict;use warnings;use Mail::Identity;sub new(@) {my$class=shift;$class->SUPER::new(name=>'emails',@_)}sub init($) {my ($self,$args)=@_;$args->{item_type}||='Mail::Identity';$self->SUPER::init($args)}sub type() {'mailgroup'}1;
USER_IDENTITY_COLLECTION_EMAILS

$fatpacked{"User/Identity/Collection/Locations.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_COLLECTION_LOCATIONS';
  package User::Identity::Collection::Locations;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Collection';use strict;use warnings;use User::Identity::Location;use Carp qw/croak/;sub new(@) {my$class=shift;$class->SUPER::new(locations=>@_)}sub init($) {my ($self,$args)=@_;$args->{item_type}||='User::Identity::Location';$self->SUPER::init($args);$self}sub type() {'whereabouts'}1;
USER_IDENTITY_COLLECTION_LOCATIONS

$fatpacked{"User/Identity/Collection/Systems.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_COLLECTION_SYSTEMS';
  package User::Identity::Collection::Systems;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Collection';use strict;use warnings;use User::Identity::System;sub new(@) {my$class=shift;$class->SUPER::new(systems=>@_)}sub init($) {my ($self,$args)=@_;$args->{item_type}||='User::Identity::System';$self->SUPER::init($args);$self}sub type() {'network'}1;
USER_IDENTITY_COLLECTION_SYSTEMS

$fatpacked{"User/Identity/Collection/Users.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_COLLECTION_USERS';
  package User::Identity::Collection::Users;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Collection';use strict;use warnings;use User::Identity;sub new(@) {my$class=shift;$class->SUPER::new(systems=>@_)}sub init($) {my ($self,$args)=@_;$args->{item_type}||='User::Identity';$self->SUPER::init($args);$self}sub type() {'people'}1;
USER_IDENTITY_COLLECTION_USERS

$fatpacked{"User/Identity/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_ITEM';
  package User::Identity::Item;use vars '$VERSION';$VERSION='0.99';use strict;use warnings;use Scalar::Util qw/weaken/;use Carp;sub new(@) {my$class=shift;return undef unless @_;unshift @_,'name' if @_ %2;my%args=@_;my$self=(bless {},$class)->init(\%args);if(my@missing=keys%args){local $"='", "';warn "WARNING: Unknown ".(@missing==1? 'option' : 'options')." \"@missing\" for a $class\n"}$self}sub init($) {my ($self,$args)=@_;unless(defined($self->{UII_name}=delete$args->{name})){croak "ERROR: Each item requires a name"}$self->{UII_description}=delete$args->{description};$self}sub name(;$) {my$self=shift;@_ ? ($self->{UII_name}=shift): $self->{UII_name}}sub description() {shift->{UII_description}}our%collectors=(emails=>'User::Identity::Collection::Emails' ,locations=>'User::Identity::Collection::Locations' ,systems=>'User::Identity::Collection::Systems' ,users=>'User::Identity::Collection::Users');sub addCollection(@) {my$self=shift;return unless @_;my$object;if(ref $_[0]){$object=shift;croak "ERROR: $object is not a collection" unless$object->isa('User::Identity::Collection')}else {unshift @_,'type' if @_ % 2;my%args=@_;my$type=delete$args{type};croak "ERROR: Don't know what type of collection you want to add" unless$type;my$class=$collectors{$type}|| $collectors{$type.'s'}|| $type;eval "require $class";croak "ERROR: Cannot load collection module $type ($class); $@\n" if $@;$object=$class->new(%args);croak "ERROR: Creation of a collection via $class failed\n" unless defined$object}$object->parent($self);$self->{UI_col}{$object->name}=$object}sub removeCollection($) {my$self=shift;my$name=ref $_[0]? $_[0]->name : $_[0];delete$self->{UI_col}{$name}|| delete$self->{UI_col}{$name.'s'}}sub collection($;$) {my$self=shift;my$collname=shift;my$collection =$self->{UI_col}{$collname}|| $self->{UI_col}{$collname.'s'}|| return;wantarray ? $collection->roles : $collection}sub add($$) {my ($self,$collname)=(shift,shift);my$collection =ref$collname && $collname->isa('User::Identity::Collection')? $collname : ($self->collection($collname)|| $self->addCollection($collname));unless($collection){carp "No collection $collname";return}$collection->addRole(@_)}sub type {"item"}sub parent(;$) {my$self=shift;return$self->{UII_parent}unless @_;$self->{UII_parent}=shift;weaken($self->{UII_parent});$self->{UII_parent}}sub user() {my$self=shift;my$parent=$self->parent;defined$parent ? $parent->user : undef}sub find($$) {my$all=shift->{UI_col};my$collname=shift;my$collection =ref$collname && $collname->isa('User::Identity::Collection')? $collname : ($all->{$collname}|| $all->{$collname.'s'});defined$collection ? $collection->find(shift): ()}1;
USER_IDENTITY_ITEM

$fatpacked{"User/Identity/Location.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_LOCATION';
  package User::Identity::Location;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;use User::Identity;use Scalar::Util 'weaken';sub type {"location"}sub init($) {my ($self,$args)=@_;$args->{postal_code}||=delete$args->{pc};$self->SUPER::init($args);exists$args->{$_}&& ($self->{'UIL_'.$_}=delete$args->{$_})foreach qw/city country country_code fax organization pobox pobox_pc postal_code state street phone/;$self}sub street() {shift->{UIL_street}}sub postalCode() {shift->{UIL_postal_code}}sub pobox() {shift->{UIL_pobox}}sub poboxPostalCode() {shift->{UIL_pobox_pc}}sub city() {shift->{UIL_city}}sub state() {shift->{UIL_state}}sub country() {my$self=shift;return$self->{UIL_country}if defined$self->{UIL_country};my$cc=$self->countryCode or return;eval 'require Geography::Countries';return if $@;scalar Geography::Countries::country($cc)}sub countryCode() {shift->{UIL_country_code}}sub organization() {shift->{UIL_organization}}sub phone() {my$self=shift;my$phone=$self->{UIL_phone}or return ();my@phone=ref$phone ? @$phone : $phone;wantarray ? @phone : $phone[0]}sub fax() {my$self=shift;my$fax=$self->{UIL_fax}or return ();my@fax=ref$fax ? @$fax : $fax;wantarray ? @fax : $fax[0]}sub fullAddress() {my$self=shift;my$cc=$self->countryCode || 'en';my ($address,$pc);if($address=$self->pobox){$pc=$self->poboxPostalCode}else {$address=$self->street;$pc=$self->postalCode}my ($org,$city,$state)=@$self{qw/UIL_organization UIL_city UIL_state/ };return unless defined$city && defined$address;my$country=$self->country;$country =defined$country ? "\n$country" : defined$cc ? "\n".uc($cc): '';if(defined$org){$org .= "\n"}else {$org=''};if($cc eq 'nl'){$pc="$1 ".uc($2)."  " if defined$pc && $pc =~ m/(\d{4})\s*([a-zA-Z]{2})/;return "$org$address\n$pc$city$country\n"}else {$state ||='';return "$org$address\n$city$state$country\n$pc"}}1;
USER_IDENTITY_LOCATION

$fatpacked{"User/Identity/System.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'USER_IDENTITY_SYSTEM';
  package User::Identity::System;use vars '$VERSION';$VERSION='0.99';use base 'User::Identity::Item';use strict;use warnings;use User::Identity;use Scalar::Util 'weaken';sub type {"network"}sub init($) {my ($self,$args)=@_;$self->SUPER::init($args);exists$args->{$_}&& ($self->{'UIS_'.$_}=delete$args->{$_})foreach qw/hostname location os password username/;$self->{UIS_hostname}||='localhost';$self}sub hostname() {shift->{UIS_hostname}}sub username() {shift->{UIS_username}}sub os() {shift->{UIS_os}}sub password() {shift->{UIS_password}}sub location() {my$self=shift;my$location=$self->{MI_location}or return;unless(ref$location){my$user=$self->user or return;$location=$user->find(location=>$location)}$location}1;
USER_IDENTITY_SYSTEM

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

